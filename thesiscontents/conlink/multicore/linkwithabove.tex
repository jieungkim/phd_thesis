
\subsection{Linking with the Layer on Local Layer Interfaces}
\label{chapter:linking:subsec:linking-with-the-layer-on-local-layer-interface}


We define multiple intermediate languages for multicore linking during this section.
We have also provided the refinement proofs between those intermediate languages, which can be further used to link the languages and proofs with  local layer interfaces that users want to use 
it to build abstraction layers, which is described in the grey box in Figure~\ref{fig:chapter:conlink:concurrent-linking-structure} (a) as well as in Figure~\ref{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking}.
It is out of our scope in our multicore-linking framework,
because this process heavily relies on the hardware configurations as well as the machine model.
Local layer interfaces are the machine model for $\compcertx$ in our case. 
Due to the dependencies of it with the instance of concurrent program verification, 
we discuss it in the next chapter, which shows the verification for concurrent $\certikos$ in our case. 
However, connecting all the previous machine models via
all our refinement lemmas is an
easy task when we adequately provide the instance for all hardware configurations.
That is because all those proofs follow the refinement proof that can apply to the proof for the backward simulation property in $\compcert$ with little effort. 
We explain this by providing our $\coq$ implementation in the next chapter.
