
\subsection{Global Log Optimization for Better Interface}
\label{chapter:linking:subsec:global-log-optimization}

We have defined the single core machine model from the multicore machine model with providing refinements between those machines. 
The single core machine in Section~\ref{chapter:linking:subsec:single-core-machine-model} , however, 
is not sufficient to work as a 
basis of local layer interfaces in Section~\ref{chapter:ccal:subsec:local-layer-interface}. 
First, the state definition in machine model differs from the machine that we used for building layers with the support for the compositional compilation, $\compcertx$. 
In this sense, optimization is required to match the machine state for a single core machine with a machine state of $\compcertx$, $\lasmmach$. 
Second, the oracle query in the machine is operational step style, 
which always query the oracle at each step of the evaluation.
Adding this oracle query in between all steps in the $\compcertx$ machine model ($\lasmmach$) is not feasible because it requires the modification of the machine model itself as well as the compilation path of $\compcertx$. 
Therefore, 
optimization on the point of oracle query has to be adjusted. 
Third, the global oracle contains multiple scheduling events in it as well as not practical for us to build multiple disjoint shared object since it includes too many unnecessary events for other objects when we focus on a single shared object. 
This section deals with intermediate machine models resolving those stated issues with brief explanations. 



%%%%%%%
\begin{figure}
\noindent\fbox{fairness:}
$$
\begin{array}{llll}
\timebound & : & \nattype &\mbox{(time bound for wating scheduling)} \\
\end{array}
$$

\noindent\fbox{Yield Back Function:}
\begin{center}
\begin{tabular}{l}
$ \yieldbackfunckwd_{(n : \nattype)} (curid : \ztype) (l \ res : \mclog) (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) : \mclog := $\\
\ \ \ $ \left\{\begin{array}{lr}
       \optionnone & \text{for } n  = O \\
       
       \optionsome\ res' & \text{for } n = S\ n' \wedge \oget{\set{curid}}{\mclog}{\mcevent}{\listappoppo{res}{l}}{oracle}{e}\\ 
                  & \wedge res' := \listconsoppo{e}{res} \wedge \yieldbackfunc{n'}{curid}{l}{res'}{oracle}{r} \\
                  & \wedge e = \yieldbackev{curid'} \wedge curid = curid' \\
        r & \text{for }n = S\ n' \wedge \oget{\set{curid}}{\mclog}{\mcevent}{\listappoppo{res}{l}}{oracle}{e}\\ 
                  & \wedge res' := \listconsoppo{e}{res} \wedge \yieldbackfunc{n'}{curid}{l}{res'}{oracle}{r} \\
                  & (\wedge e \neq \yieldbackev{curid'} \vee (\wedge e = \yieldbackev{curid'} \wedge curid \neq curid')) \\
          \optionnone  & \text{for }n = S\ n' \wedge \ogetnoeq{\set{curid}}{\mclog}{\mcevent}{\listappoppo{res}{l}}{oracle} = r \wedge r \neq \optionsome \ e \\
        \end{array}\right .
$\\
\end{tabular}
\end{center}

\noindent\fbox{single big step: ${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) :  \singlestatekwd \rightarrow \cctracekwd \rightarrow \singlestatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[progress]
{ ls = \localstate{ps}{\bfalse} \\
ls' = \localstate{ps'}{\btrue} \\\\
\hardwarelocalstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{l'})}}
{\singlebigstep{curid}{oracle}{(\singlestate{curid}{ls}{l})}{\ccemptytrace}{(\singlestate{curid}{ls'}{(\listappoppo{l'}{l})})}}

\inferrule[yield]
{ l_0 = \listconsoppo{\yieldbackev{curid}}{l} \\
 ls = \localstate{ps}{\btrue} \\
ls' = \localstate{ps}{\bfalse} \\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l'}}
{\singlebigstep{curid}{oracle}{(\singlestate{curid}{ls}{l})}{\ccemptytrace}{(\singlestate{curid'}{ls'}{l'})}}
\end{mathpar}

\noindent\fbox{rstate:}
$$
\begin{array}{lll}
\rstatekwd & := & \rstate{(ps : \privatestate)}{(log: \mclog)}\\
\end{array}
$$

\fbox{single big' step:
$
{}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) :  \rstatekwd \rightarrow \cctracekwd \rightarrow \rstatekwd \rightarrow \mcprop
$}
\begin{mathpar}
\inferrule[progress]
{  l_0 = \listconsoppo{\yieldbackev{curid}}{l} \\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l_1} \\
\hardwarelocalstep{curid}{(\localview{ps}{(\listappoppo{l_1}{l_0})})}{(\localview{ps'}{l'})}}
{\singlebigtwostep{curid}{oracle}{(\rstate{ps}{l})}{\ccemptytrace}{(\rstate{ps'}{(\listappoppo{l'}{\listappoppo{l_1}{l_0}})})}}
\end{mathpar}
\caption{Single Core Machine Model with Big Step Style Oracle Query.}
\label{fig:chapter:conlink:single-core-big-step}
\end{figure}

\subsubsection{Big Step Oracle Query}

Querying the environmental context after each local step is subtle in defining local layer interface;
thus, simplification is desirable. 
We define two intermediate machine model for this optimization,
which is presented in Figure~\ref{fig:chapter:conlink:single-core-big-step} based on the one, the fairness of the evaluation chance for each CPU, which is notated as $\timebound$. 
The fairness assumes that each core will always evaluate at least one step evaluation within 
$\timebound$,  the maximum number
of events in between two evaluations of the CPU.
With the fairness assumption, 
the $\yieldbackfunckwd$ gives us the way to merge multiple oracles queries in
the single core machine in Section~\ref{chapter:linking:subsec:single-core-machine-model} 
into a single big-step style query,
which is defined in the $\textsf{YIELD}$ rule in the $\singlebigstepkwd$.
The $\singlebigtwostepkwd$ even merge the two rules in  $\singlebigstepkwd$ to simplify 
the evaluation rule of the machine, which removes the boolean flag in the local view (as well as in  the definition of state $\rstatekwd$) 
what we have added when introducing our hardware oracle (in Section~\ref{chapter:linking:subsec:multicore-machine-model-with-hardware-scheduler}) to indicate whether the current state is for the hardware scheduler or for the local evaluation.
We, of course provides the refinement lemmas between those machines.
Similar to the previous steps, 
we show  refinement proofs between those machine models,
which are stated in Lemma~\ref{lemma:chapter:linking:one-step-big-refines-single} and Lemma~\ref{lemma:chapter:linking:one-step-big-p-refines-big}.
%
%\begin{figure}
%\noindent\fbox{variables for match relation}
%$$
%\begin{array}{lllr}
%cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
%si\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mcevent} &  \mbox{(oracle for a single cpu)}\\
%\end{array}
%$$
%
%\noindent\fbox{match state : $\envstatekwd_{[\coreset]} \rightarrow \mcstatekwd \rightarrow \mcprop$}
%\begin{mathpar}
%
%\end{mathpar}

%\noindent\fbox{hypothesis}
%\begin{enumerate}
%\item valid$\_$cpuid: $cpuid \in \coreset$
%\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\set{cpuid}}{si\_o }$
%\end{enumerate}
%
%\noindent\fbox{top lemmas}
%
%\begin{enumerate}
%\item start$\_$step$\_$get$\_$env$\_$log: \\
%$\begin{array}{l}
%\forall \ n \ l \ res \ l' \ ps \ curid . \ cpuid \neq curid \rightarrow \yieldbackfunc{n}{cpuid}{l}{res}{si\_o}{l'} \rightarrow\\
%\ccstarstep{\singlestep{cpuid}{si\_o}{(\singlestate{curid}{ps}{(\listappoppo{res}{l})})}{\ccemptytrace}{(\singlestate{cpuid}{ps}{(\listappoppo{l'}{l})})}}\\ 
%\end{array}
%$
%\item one$\_$step$\_$big$\_$refines$\_$single : \\
%$
%\begin{array}{l}
%\forall \ s_h \ s_h' \ t \ s_l . \ \singlebigstep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchbsstatesstate{s_h}{s_l} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s\_l' . \  \ccplusstep{\singlestep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchbsstatesstate{s_h'}{s_l'}\\
%\end{array}
%$
%\end{enumerate}
%\caption{Big Refines Single}
%\label{fig:chapter:conlink:big-refines-single}
%\end{figure}
%
%\begin{hypothesis}[valid$\_$cpuid]
%\begin{tabular}{P{0.95\textwidth}}
%$cpuid \in \coreset$
%\end{tabular}
%\end{hypothesis}
%
%\begin{hypothesis}[valid$\_$oracle$\_$def]
%\begin{tabular}{P{0.95\textwidth}}
%$\validoraclenoeq{cpuid}{\set{cpuid}}{si\_o }$
%\end{tabular}
%\end{hypothesis}

\begin{lemma}[one$\_$step$\_$big$\_$refines$\_$single]
\label{lemma:chapter:linking:one-step-big-refines-single}
Let's assume that there is a valid CPU ID $start\_cpu$ ($start\_cpu \in \coreset$)
and a single core oracle $si\_o$.
When the single oracle is valid ($ \validoraclenoeq{start\_cpu}{\set{start\_cpu}}{si\_o}$) we assume the following fact:
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlebigstep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchbsstatesstate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s\_l' . \  \ccplusstep{\singlestep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchbsstatesstate{s_h'}{s_l'}\\
\end{array}
$
\end{tabular}
\end{center}
when the match relation for two states between those machine models is defined as 
\begin{mathpar}
\inferrule[match state]
{ s_h = s_l \\
s_h = \singlestate{tid}{(\localstate{ps}{b})}{l} \\
\validlog{cpuid}{l} \\
l \neq \listconsoppo{\yieldev{\_}}{\_}\\
\getcuridfromlog{cpuid}{l}{cpuid}\\
(b = \bfalse \rightarrow \exists \ e \ l' . \ l = \listconsoppo{e}{l'} \wedge e = \yieldbackev{cpuid})}
{\matchbsstatesstate{s_h}{s_l}}
\end{mathpar}
\end{lemma}

%
%\begin{figure}
%\noindent\fbox{match state : $\rstatekwd \rightarrow \singlestatekwd \rightarrow \mcprop$}
%\begin{mathpar}
%\inferrule[match state]
%{\ }
%{\matchrstatesinglestate{cpuid}{(\rstate{ps}{l})}{(\singlestate{cpuid}{(\localstate{ps}{true})}{l}}}
%\end{mathpar}
%%
%%\noindent\fbox{hypothesis}
%%\begin{enumerate}
%%\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\coreset}{hw\_o }$
%%\end{enumerate}
%
%%\noindent\fbox{top lemmas}
%%\begin{enumerate}
%%\item one$\_$step$\_$big2$\_$refines$\_$big : \\
%%$
%%\begin{array}{l}
%%\forall \ s_h \ s_h' \ t \ s_l . \ \singlebigtwostep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchrstatesinglestate{cpuid}{s_h}{s_l} \rightarrow \\
%%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s\_l' . \  \ccplusstep{\singlebigstep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchrstatesinglestate{cpuid}{s_h'}{s_l'}\\
%%\end{array}
%%$
%%\end{enumerate}
%\caption{Big2 Refines Big} 
%\label{fig:chapter:conlink:bigtwo-refines-big}
%\end{figure}

\begin{lemma}[one$\_$step$\_$big'$\_$refines$\_$big]
\label{lemma:chapter:linking:one-step-big-p-refines-big}
Let's assume that there is a valid CPU ID $start\_cpu$ ($start\_cpu \in \coreset$)
and a single core oracle $si\_o$.
When the single oracle is valid ($ \validoraclenoeq{start\_cpu}{\set{start\_cpu}}{si\_o}$) we can show the following fact:
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlebigtwostep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchrstatesinglestate{cpuid}{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s\_l' . \  \ccplusstep{\singlebigstep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchrstatesinglestate{cpuid}{s_h'}{s_l'}\\
\end{array}
$
\end{tabular}
\end{center}
when the match relation for two states between those machine models is defined as 
\begin{mathpar}
\inferrule{\ }
{\matchrstatesinglestate{cpuid}{(\rstate{ps}{l})}{(\singlestate{cpuid}{(\localstate{ps}{true})}{l}}}
\end{mathpar}
\end{lemma}

%
%
%\begin{lemma}[start$\_$step$\_$get$\_$env$\_$log]
%\begin{tabular}{P{0.95\textwidth}}
%$
%\begin{array}{l}
%\forall \ n \ l \ res \ l' \ ps \ curid . \ cpuid \neq curid \rightarrow \yieldbackfunc{n}{cpuid}{l}{res}{si\_o}{l'} \rightarrow\\
%\ccstarstep{\singlestep{cpuid}{si\_o}{(\singlestate{curid}{ps}{(\listappoppo{res}{l})})}{\ccemptytrace}{(\singlestate{cpuid}{ps}{(\listappoppo{l'}{l})})}}\\ 
%\end{array}
%$
%\end{tabular}
%\end{lemma}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\noindent\fbox{single local view:}
$$
\begin{array}{lll}
\singlelocalviewkwd & := & \singlelocalview{(ps:\privatestate)}\\
\end{array}
$$

\noindent\fbox{single local step: $\ztype \rightarrow \singlelocalviewkwd \rightarrow \singlelocalviewkwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[private]
{\programcounter{ps}{\privatecmdkwd}\\
\privatestep{curid}{ps}{ps'}}
{ \singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
\end{mathpar}

\fbox{single log step: $\ztype \rightarrow \localviewkwd \rightarrow \localviewkwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[acquire shared]
{\programcounter{ps}{\acqsharedcmd{id}}\\
\calowner{l}{id}{\ofreestate{d}}\\
\setsharedstep{ps}{d}{ps'}}
{ \singlelogstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listconsoppo{\acqev{curid}{id}}{\nulllist})})}}

\inferrule[release shared]
{\programcounter{ps}{\relsharedcmd{id}}\\
\calowner{l}{id}{\ownstate{curid}}\\
\getsharedstep{ps}{d}{ps'}}
{ \singlelogstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listconsoppo{\relev{curid}{id}{d}}{\nulllist})})}}

\inferrule[atomic]
{  \programcounter{ps}{\atomiccmd{id}{\atomiceventident{e}}}\\
\atomicstep{curid}{id}{ps}{l}{ps'}{e}}
{ \singlelogstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listconsoppo{\atomicev{curid}{id}{e}}{\nulllist})})}}
\end{mathpar}
\caption{Single Local and Log Step Rules.}
\label{fig:chapter:conlink:single-local-and-log-step-rules}
\end{figure}

\subsubsection{Reordering and  zipping}

Another optimization that is required  is  reordering the point that queries the environmental context 
and zipping the multiple adjacent scheduling events into the single scheduling event (and finally remove them).
Those steps 
first, require the separation on the local step rules as two folds;
the step rules with visible behavior and the step rules with silent behavior and depending on
whether the rules generate visible events or not during their evaluations. 
Those newly defined local step rules are in Figure~\ref{fig:chapter:conlink:single-local-and-log-step-rules},
and we define 
the new machine model
 in Figure~\ref{fig:chapter:conlink:single-split-step-rules}.
 This new machine model defers the update on the global log based on the program counter. 
If the current local step is a visible step, then it will update the cached log to the global log to update the view of the shared state. 
It, however, only adds the cached log instead of propagating the result to the global log when the program counter points out the command that will perform a silent step. 
By doing that, the machine updates the global log only when the focused CPU performs its shared operation,
which corresponds to the second rule of the machine.
%%%%%%%%%%%%%%%%
\begin{figure}
\noindent\fbox{srstate:}
$$
\begin{array}{lll}
\srstatekwd & := & \srstate{(ps:\privatestate)}{(log_{global}: \mclog)}{(log_{cache} :\mclog)}\\
\end{array}
$$

\noindent\fbox{split step: ${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) :  \srstatekwd \rightarrow \cctracekwd \rightarrow \srstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule
{al_0 = \listconsoppo{\yieldev{curid}}{al}\\
l_0 = \listappoppo{al_0}{l}\\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l_1}\\
\singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
{\singlesplitstep{curid}{oracle}{(\srstate{ps}{l}{al})}{\ccemptytrace}{(\srstate{ps'}{l}{(\listappoppo{l_1}{al_0})})}}

\inferrule
{l_0 = \listappoppo{\listconsoppo{\yieldev{curid}}{al}}{l}\\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l_1}\\
\singlelogstep{curid}{(\localview{ps}{(\listappoppo{l_1}{l_0})})}{(\localview{ps'}{l'})}}
{\singlesplitstep{curid}{oracle}{(\srstate{ps}{l}{al})}{\ccemptytrace}{(\srstate{ps'}{(\listappoppo{l'}{\listappoppo{l_1}{l_0}})}{\nulllist})}}
\end{mathpar}
\caption{Split Machine Model.}
\label{fig:chapter:conlink:single-split-step-rules}
\end{figure}



%\begin{mathpar}
%\inferrule[match state]
%{l' = \listappoppo{al}{l}}
%{\matchsrstaterstate{(\srstate{ps}{l}{al})}{(\rstate{ps}{l'})}}
%\end{mathpar}


%%%%%%%%%%%%%%%%%
%\begin{figure}
%\noindent\fbox{match state : $\srstatekwd \rightarrow \rstatekwd \rightarrow \mcprop$}
%
%\begin{mathpar}
%\inferrule[match state]
%{l' = \listappoppo{al}{l}}
%{\matchsrstaterstate{(\srstate{ps}{l}{al})}{(\rstate{ps}{l'})}}
%\end{mathpar}
%
%%\noindent\fbox{top lemmas}
%
%\begin{enumerate}
%\item single$\_$local$\_$imply$\_$env:\\
%$
%\begin{array}{l}
%\forall \ cpuid \ l \ ps \ ps' .\ \singlelocalstep{cpuid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hardwarelocalstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{\nulllist})}\\
%\end{array}
%$
%\item single$\_$log$\_$imply$\_$env:\\
%$
%\begin{array}{l}
%\forall \ cpuid \ l \ l' \ ps \ ps' .\ \singlelogstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{l'})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hardwarelocalstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{l'})}\\
%\end{array}
%$
%\item one$\_$step$\_$split$\_$refines$\_$big2 : \\
%$
%\begin{array}{l}
%\forall \ cpuid \ si\_o \ s_h \ s_h' \ t \ s_l . \ \singlesplitstep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchsrstaterstate{s_h}{s_l} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \ccplusstep{\singlebigtwostep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchsrstaterstate{s_h'}{s_l'}\\
%\end{array}
%%$
%%\end{enumerate}
%\caption{Split Refines Big2}
%\label{fig:chapter:conlink:split-refines-bigtwo}
%\end{figure}
%%%%%%%%%%%%%%%%
%The refinmeent 
%The refinement between this $\singlesplitstep
% and the big step style single core machine requires the refinement between local step rules as shown in lemma 1 and lemma 2 in Figure~\ref{fig:chapter:conlink:split-refines-bigtwo}. 
%With those lemmas 
%the top-level proof, the lemma 3 in  Figure~\ref{fig:chapter:conlink:split-refines-bigtwo} is straightforward.
%
%%
%
%\begin{lemma}[single$\_$local$\_$imply$\_$env]
%\begin{tabular}{P{0.95\textwidth}}
%$
%\begin{array}{l}
%\forall \ cpuid \ l \ ps \ ps' .\ \singlelocalstep{cpuid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hardwarelocalstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{\nulllist})}\\
%\end{array}
%$
%\end{tabular}
%\end{lemma}
%
%
%\begin{lemma}[single$\_$log$\_$imply$\_$env]
%\begin{tabular}{P{0.95\textwidth}}
%$
%\begin{array}{l}
%\forall \ cpuid \ l \ l' \ ps \ ps' .\ \singlelogstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{l'})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hardwarelocalstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{l'})}\\
%\end{array}
%$
%\end{tabular}
%\end{lemma}
%


\begin{figure}
\noindent\fbox{reorder step: ${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mclog}) :  \srstatekwd \rightarrow \cctracekwd \rightarrow \srstatekwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule
{\singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
{\singlereorderstep{curid}{oracle}{(\rstate{ps}{l})}{\ccemptytrace}{(\rstate{ps'}{l})}}

\inferrule
{\oget{\set{curid}}{\mclog}{\mclog}{l}{oracle}{l_0}\\
\singlelogstep{curid}{(\localview{ps}{(\listappoppo{l_0}{l})})}{(\localview{ps'}{l'})}}
{\singlereorderstep{curid}{oracle}{(\rstate{ps}{l})}{\ccemptytrace}{(\rstate{ps'}{(\listappoppo{l'}{\listappoppo{l_0}{l}})})}}
\end{mathpar}
\caption{Reorder Step Machine.}
\label{fig:chapter:conlink:reorder-step-machine}
\end{figure}
%%%%%%%%%%%%%%%%
The machine model in Figure~\ref{fig:chapter:conlink:single-split-step-rules}  queries the oracle as a big-step style (\ie, updating multiple events in a single oracle query),
but it relies on the oracle query function $\yieldbackfunckwd$. 
As a part of optimization, another model has been introduced to 
remove the oracle query function as well as to replace the 
oracle type with the proper type (which returns a log instead of an event) for a big step oracle query,
and the machine model for this oracle query zipping is defined in Figure~\ref{fig:chapter:conlink:reorder-step-machine}.
Similar to the previous steps, we 
also provide refinement lemmas for both steps. 

First, Lemma~\ref{lemma:chapter:conlink:split-refines-big-p} shows the refinement between 
the machine model in Figure~\ref{fig:chapter:conlink:single-split-step-rules} and the machine model in Figure~\ref{fig:chapter:conlink:single-core-big-step}, which shows the connection between the evaluation with the delayed update on the global log  and the evaluation with the prompt update on the at each moment.
\begin{lemma}[one$\_$step$\_$split$\_$refines$\_$big2]
\label{lemma:chapter:conlink:split-refines-big-p}
We says that 
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ cpuid \ si\_o \ s_h \ s_h' \ t \ s_l . \ \singlesplitstep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchsrstaterstate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \ccplusstep{\singlebigtwostep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchsrstaterstate{s_h'}{s_l'}\\
\end{array}
$ 
\end{tabular}
\end{center}
when the match relation between machine states of those two models is defined as
\begin{mathpar}
\inferrule
{l' = \listappoppo{al}{l}}
{\matchsrstaterstate{(\srstate{ps}{l}{al})}{(\rstate{ps}{l'})}}
\end{mathpar}
\end{lemma}

The other lemma (in Lemma ~ref{lemma:chapter:conlink:reorder-refines-split}) shows the connection between two machines 
which use different type of environmental contexts, one of which has a type $\mcoracle{\set{cpuid}}{\mclog}{\mclog}$ and the other has a type $\mcoracle{\set{cpuid}}{\mclog}{\mcevent}$. 
The lemma relies on the match relation between two different machine models in Figure~\ref{fig:chapter:conlink:reorder-refines-split}.
Similar to the environmental context constructions in the previous parts, which are parts when we introduce
environmental contexts for a hardware scheduler as well as all other components except one single focused core,
the refinement proof has to rely on an assumption due to the current limitation on our proof style. 
We can show the valid construction of the new environmental context, but connecting it with the refinement lemma that this framework provides has remained as future work. 

\begin{lemma}[one$\_$step$\_$reorder$\_$refines$\_$split]
\label{lemma:chapter:conlink:reorder-refines-split}
%
%\noindent\fbox{variables for match relation}
%$$
%\begin{array}{lllr}
%cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
%si\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mcevent} &  \mbox{(oracle for a single cpu)}\\
%re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(oracle for a single cpu - reordered)}\\
%\end{array}
%$$
Let's assume that there is a valid CPU ID $start\_cpu$ ($start\_cpu \in \coreset$),
a single core oracle $si\_o$ with the type $ \mcoracle{\set{cpuid}}{\mclog}{\mcevent}$, and a reordered oracle $re\_o$ with the type $\mcoracle{\set{cpuid}}{\mclog}{\mclog}$.
When the single oracle is valid ($ \validoraclenoeq{start\_cpu}{\set{start\_cpu}}{si\_o}$) we can show the following fact
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlereorderstep{cpuid}{re\_o}{s_h}{t}{s_h'} \rightarrow  \matchrstatesrstate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' .\ \singlesplitstep{cpuid}{si\_o}{s_l}{t}{s_l'} \wedge  \matchrstatesrstate{s_h'}{s_l'}\\
\end{array}
$
\end{tabular}
\end{center}
with the assumption about those two oracles, which is stated as 
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ ps_h \ l_h \ ps_l \ l_l \ al.\ \matchrstatesrstate{(\rstate{ps_h}{l_h})}{(\srstate{ps_l}{l_l}{al})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \validlog{cpuid}{(\listconsoppo{\yieldev{cpuid}}{\listappoppo{al}{l_l}})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \exists\ l_1. \ \yieldbackfunc{\timebound}{cpuid}{\listconsoppo{\yieldev{cpuid}}{\listappoppo{al}{l_l}}}{\nulllist}{si\_o}{l_1} \wedge \\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \forall \ l_1' .\  \oget{\set{cpuid}}{\mclog}{\mclog}{l_h}{re\_o}{l_1'} \rightarrow  l_1' = \listappoppo{l_1}{\listconsoppo{\yieldev{cpuid}}{al}} \\
\end{array}
$
\end{tabular}
\end{center}

\end{lemma}

%%%%%%%%%%%%%%%%
\begin{figure}
\noindent\fbox{auxiliary function}
%  Definition valid_cache_log_members (tid : Z) (l : Log) :=
%    forall ev, In ev l -> event_source ev <> tid \/ GetEvTy ev = YIELDTY.
\begin{mathpar}
\inferrule[nil]
{ \ }
{\validcachelogmembers{cpuid}{\nulllist}}

\inferrule[nonil]
{ev \in l\\
(\eventsourcefuncnoeq{ev} \neq cpuid \vee ev = \yieldev{\_})}
{\validcachelogmembers{cpuid}{l}}
\end{mathpar}
%
%\noindent\fbox{variables for match relation}
%$$
%\begin{array}{lllr}
%cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
%si\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mcevent} &  \mbox{(oracle for a single cpu)}\\
%re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(oracle for a single cpu - reordered)}\\
%\end{array}
%$$

\noindent\fbox{match state : $\rstatekwd \rightarrow \srstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{ ps_h = ps_l \\
l_h = l_l \\
\validlog{cpuid}{(\listappoppo{al}{l_l})}\\
\getcuridfromlog{cpuid}{\listappoppo{al}{l_l}}{cpuid}\\
l_h \neq \listconsoppo{\yieldev{\_}}{\_} \\
(al = \nulllist \vee (\exists \ ev \ al' . \ al = \listconsoppo{ev}{al'} \wedge ev = \yieldbackev{cpuid}))\\
\validcachelogmembers{cpuid}{al}}
{\matchrstatesrstate{(\rstate{ps_h}{l_h})}{(\srstate{ps_l}{l_l}{al})}}
\end{mathpar}

%\noindent\fbox{hypothesis}
%\begin{enumerate}
%\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\set{cpuid}}{si\_o }$
%\item YieldBack$\_$consistence$\_$with$\_$reorder$\_$o :\\
%$
%\begin{array}{l}
%\forall \ ps_h \ l_h \ ps_l \ l_l \ al.\ \matchrstatesrstate{(\rstate{ps_h}{l_h})}{(\srstate{ps_l}{l_l}{al})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \validlog{cpuid}{(\listconsoppo{\yieldev{cpuid}}{\listappoppo{al}{l_l}})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \exists\ l_1. \ \yieldbackfunc{\timebound}{cpuid}{\listconsoppo{\yieldev{cpuid}}{\listappoppo{al}{l_l}}}{\nulllist}{si\_o}{l_1} \wedge \\ 
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \forall \ l_1' .\  \oget{\set{cpuid}}{\mclog}{\mclog}{l_h}{re\_o}{l_1'} \rightarrow \\ 
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ l_1' = \listappoppo{l_1}{\listconsoppo{\yieldev{cpuid}}{al}} \\
%\end{array}
%$
%\end{enumerate}
%
%\noindent\fbox{top lemmas}
%\begin{enumerate}
%\item one$\_$step$\_$reorder$\_$refines$\_$split : \\
%$
%\begin{array}{l}
%\forall \ s_h \ s_h' \ t \ s_l . \ \singlereorderstep{cpuid}{re\_o}{s_h}{t}{s_h'} \rightarrow  \matchrstatesrstate{s_h}{s_l} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' .\ \singlesplitstep{cpuid}{si\_o}{s_l}{t}{s_l'} \wedge  \matchrstatesrstate{s_h'}{s_l'}\\
%\end{array}
%$
%\end{enumerate}
\caption{State Match Relation: the relation between two states of the reorder  machine model and a split machine model}
\label{fig:chapter:conlink:reorder-refines-split}
\end{figure}
%%%%%%%%%%%%%%%%
%The refinement proof between those different kinds of oracle queries needs an assumption about the relation between those two queries. 
%The hypothesis 2 in Figure~\ref{fig:chapter:conlink:reorder-refines-split} 
%states the hypothesis that is 
%required to prove the top level lemma (lemma 1) in Figure~\ref{fig:chapter:conlink:reorder-refines-split}.
%%
%%\begin{hypothesis}[valid$\_$oracle$\_$def]
%%\begin{tabular}{P{0.95\textwidth}}
%%$\validoraclenoeq{cpuid}{\set{cpuid}}{si\_o }$
%%\end{tabular}
%\end{hypothesis}

%\begin{hypothesis}[YieldBack$\_$consistence$\_$with$\_$reorder$\_$o]
%\begin{tabular}{P{0.95\textwidth}}
%$
%\begin{array}{l}
%\forall \ ps_h \ l_h \ ps_l \ l_l \ al.\ \matchrstatesrstate{(\rstate{ps_h}{l_h})}{(\srstate{ps_l}{l_l}{al})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \validlog{cpuid}{(\listconsoppo{\yieldev{cpuid}}{\listappoppo{al}{l_l}})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \exists\ l_1. \ \yieldbackfunc{\timebound}{cpuid}{\listconsoppo{\yieldev{cpuid}}{\listappoppo{al}{l_l}}}{\nulllist}{si\_o}{l_1} \wedge \\ 
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \forall \ l_1' .\  \oget{\set{cpuid}}{\mclog}{\mclog}{l_h}{re\_o}{l_1'} \rightarrow \\ 
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ l_1' = \listappoppo{l_1}{\listconsoppo{\yieldev{cpuid}}{al}} \\
%\end{array}
%$
%\end{tabular}
%\end{hypothesis}


\begin{figure}
%  Fixpoint reduce_log (l: Log) :=
%    match l with
%      | nil => nil
%      | e :: l' =>
%        match log_event_source e with
%          | None => (reduce_log l')
%          | _ => e :: (reduce_log l')
%        end
%    end.
\noindent\fbox{auxiliary function}
$$
\mcreducelogfunckwd (l : \mclog) : \mclog := 
 \left\{\begin{array}{lr}
\nulllist & \text{for } l = \nulllist \\
\listconsoppo{ev}{l_r'} & \text{for } l = \listconsoppo{ev}{l'} \wedge \mcreducelogfunc{l'}{l_r'}\\
&\wedge(ev \neq \yieldev{\_} \wedge ev \neq \yieldbackev{\_})\\
%& (ev = \acqev{\_} \vee ev = \relev{\_}{\_}{\_} \vee ev = \atomicev{\_}{\_}{\_})\\
l_r' & \text{for } l = \listconsoppo{ev}{l'} \wedge \mcreducelogfunc{l'}{l_r'}\\
&\wedge (ev = \yieldev{\_} \vee ev = \yieldbackev{\_})\\
\end{array} \right.
$$



%\fbox{match state : $\rstatekwd \rightarrow \rstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{\mcreducelogfunc{l}{l'}}
{\matchrrstaterrstae{(\rstate{ps}{l'})}{(\rstate{ps}{l})}}
\end{mathpar}
%
%\noindent\fbox{hypothesis}
%\begin{enumerate}
%\item relate$\_$reorder$\_$oracle$\_$def: \\
%$
%\begin{array}{l}
%\forall \ ps \ l.\ \matchrrstaterrstae{(\rstate{ps}{(\mcreducelogfuncnoeq{l})}}{(\rstate{ps}{l})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \forall \ l_h. \ \oget{\set{cpuid}}{\mclog}{\mclog}{(\mcreducelogfuncnoeq{l})}{hi\_re\_o}{l\_h} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists \ l. \ \oget{\set{cpuid}}{\mclog}{\mclog}{l}{lo\_re\_o}{l\_l} \wedge \mcreducelogfunc{l\_l}{l\_h} \\
%\end{array}
%$
%\end{enumerate}
%
%\noindent\fbox{top lemmas}
%\begin{enumerate}
%\item one$\_$step$\_$reorder$\_$refines$\_$reorder : \\
%$
%\begin{array}{l}
%\forall \ s_h \ s_h' \ t \ s_l . \ \singlereorderstep{cpuid}{hi\_re\_o}{s_h}{t}{s\_h'} \rightarrow \matchrrstaterrstae{s_h}{s_l} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \singlereorderstep{cpuid}{lo\_re\_o}{s_l}{t}{s\_l'} \wedge  \matchrrstaterrstae{s_h'}{s_l'}\\
%\end{array}
%$
%\end{enumerate}
\caption{State Match Relation: the relation between two states of two reorder machines}
\label{fig:chapter:conlink:reorder-refines-reorder}
\end{figure}
%%%%%%%%%%%%%%%%

The reorder machine model also can be used for 
the simplification of the global log.
At this point, the machine is not changing the currently running CPU as well as only query the environmental context before it evaluates shared operations. 
In this sense, keeping all scheduling events does not necessary, and it only increases the complexity. 
Due to this reason, we facilitate the reorder machine model to remove scheduling events in the global log. 
The refinement proof for this optimization, however, mostly relies on
the relation between two oracles. 
Connecting the proof about the relation between two environmental contexts with this refinement proof is a future work to provide a better multicore linking framework. 
The match relation between two states is in Figure~\ref{fig:chapter:conlink:reorder-refines-reorder}, which basically
says that two states are identical except the existence of scheduling events in the log.
The refinement lemma is stated in Lemma~\ref{lemma:chapter:conlink:reorder-refines-reorder}

\begin{lemma}[one$\_$step$\_$reorder$\_$refines$\_$reorder]
\label{lemma:chapter:conlink:reorder-refines-reorder}
Let's assume that there is a valid CPU ID $start\_cpu$ ($start\_cpu \in \coreset$),
and two oracles $hi\_re\_o$ and $lo\_re\_o $ with the type
$\mcoracle{\set{cpuid}}{\mclog}{\mclog}$. Then we can show the fact that
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlereorderstep{cpuid}{hi\_re\_o}{s_h}{t}{s\_h'} \rightarrow \matchrrstaterrstae{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \singlereorderstep{cpuid}{lo\_re\_o}{s_l}{t}{s\_l'} \wedge  \matchrrstaterrstae{s_h'}{s_l'}\\
\end{array}
$
\end{tabular}
\end{center}
with the assumption about the two oracles, which can be stated as
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ ps \ l.\ \matchrrstaterrstae{(\rstate{ps}{(\mcreducelogfuncnoeq{l})}}{(\rstate{ps}{l})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \forall \ l_h. \ \oget{\set{cpuid}}{\mclog}{\mclog}{(\mcreducelogfuncnoeq{l})}{hi\_re\_o}{l\_h} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists \ l. \ \oget{\set{cpuid}}{\mclog}{\mclog}{l}{lo\_re\_o}{l\_l} \wedge \mcreducelogfunc{l\_l}{l\_h} \\
\end{array}
$
\end{tabular}
\end{center}
\end{lemma}

\subsubsection{Divide the Global Log}

\begin{figure}
\noindent\fbox{separate log and sp state:}
$$
\begin{array}{lll}
\separateeventkwd & := &\separateacqevkwd\langle from : \ztype\rangle~\vert~\separaterelevkwd\langle from : \ztype, d: \sharedpiece\rangle\\
   & & \vert~\separateatomicevkwd\langle from:\ztype, e:\atomicevent\rangle\\
\separatelogtypekwd & := & \listconstructorkwd\ \separateeventkwd\\
\separatelogkwd & := &   \ztype \rightarrow \separatelogtypekwd \\
\separateoraclelogtypekwd & := & \ztype \times \separatelogtypekwd \times \primitiveid \\
\spstatekwd & := & \spstate{(ps: \privatestate)}{(log_{sep}: \separatelogkwd)} \\
\end{array}
$$

\noindent\fbox{separate log step: $ \ztype \rightarrow \ztype \rightarrow \localviewkwd \rightarrow \privatestate \rightarrow \separateeventkwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[acquire]
{\programcounter{ps}{\acqsharedcmd{id}}\\
\calowner{l}{id}{\ofreestate{d}}\\
\setsharedstep{ps}{d}{ps'}}
{\separatelogstep{curid}{id}{(\localview{ps}{l})}{ps'}{({\separateacqev{curid}})}}

\inferrule[release]
{\programcounter{ps}{\relsharedcmd{id}}\\
\calowner{l}{id}{\ownstate{curid}}\\
\setsharedstep{ps}{d}{ps'}}
{\separatelogstep{curid}{id}{(\localview{ps}{l})}{ps'}{({\separaterelev{curid}{d}})}}

\inferrule[atomic]
{  \programcounter{ps}{\atomiccmd{id}{\atomiceventident{e}}}\\
\atomicstep{curid}{id}{ps}{l}{ps'}{e}}
{\separatelogstep{curid}{id}{(\localview{ps}{l})}{ps'}{({\separateatomicev{curid}{e}})}}
\end{mathpar}
\caption{State for Separate Step Rules and Local Step Rules}
\label{fig:chapter:conlink:separate-state-definition}
\end{figure}

All previous machine models simplify the global log as well as the environmental context query 
via collecting, reordering, as well as removing  the events in the log (as well as the environmental context.)
It, however, still requires to keep the information of all shared objects in a single location, which is a single global log.
It is bothersome when building a replay function, which constructs the shared state via interpreting a global log because it requires to consider all events for all shared objects at once. 
To reduce the complexity due to this a single log,
our last optimization divides one single global log into multiple logs by using shared object identifiers.

It first requires the new definition regards the event and the log as well as 
the local evaluation rules based on the new local state that uses the new representation about the log,
and Figure~\ref{fig:chapter:conlink:separate-state-definition} presents them. 
It basically says that the state, $\spstatekwd$, for this machine model contains a partial map (from an identifier of a shared object to the log related to the shared object) for a set of log to represent a bunch of shared objects.


\begin{figure}
\noindent\fbox{auxiliary functions to convert between two types of log:}
\begin{center}
\begin{tabular}{l}
$
   \separateeventtwoeventkwd(ev : \separateeventkwd) (id : \ztype) 
      :=  \left\{\begin{array}{lr}
        \acqev{from}{id} & \text{for } \separateacqev{from}\\
        \relev{from}{id}{d} & \text{for } \separaterelev{from}{d}\\
        \atomicev{from}{id}{e} & \text{for } \separateatomicev{from}{e} \\
        \end{array} \right.
$\\
$
   \separatelogtwologkwd(log : \separatelogtypekwd) (id : \ztype) 
      :=  \left\{\begin{array}{lr}
        \nulllist & \text{for } log = \nulllist \\
        \listconsoppo{e_{sp}}{l_{sp}} & \text{for }  log = \listconsoppo{e}{l} \\
        & \wedge \separateeventtwoevent{e}{id}{e_{sp}}\\
        & \wedge \separatelogtwolog{l}{id}{l_{sp}}\\
        \end{array} \right.
$\\
$
\separateeventtwoidkwd (ev : \separateeventkwd) : \primitiveid :=
 \left\{\begin{array}{lr}
         \acqsharedid& \text{for } \separateacqev{\_}\\
        \relsharedid & \text{for } \separaterelev{\_}{\_}\\
        \atomiceventident{e} & \text{for } \separateatomicev{\_}{e} \\
 \end{array} \right.
$\\
\end{tabular}
\end{center}
$$
\begin{array}{lll}
  \getseplogkwd (id :\ztype)(spp : \separatelogkwd)  &:= & slog\ \ \ \ \ \ \ \  \ \ \ \ \  \hfill{\text{for } (id, slog) \in spp}\\
   \setseplogkwd (id :\ztype) (slog : \separatelogtypekwd) (spp: \separatelogkwd) &:= &spp/[id := slog]\\
\end{array}
$$
\caption{Auxiliary Functions for Single Separate Machine.}
\label{fig:chapter:conlink:auxiliary-funcitons-for-single-separate-machine}
\end{figure}

\begin{figure}
\noindent\fbox{sep step:
${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}) :  \spstatekwd \rightarrow \cctracekwd \rightarrow \spstatekwd \rightarrow \mcprop$
}
\begin{mathpar}
\inferrule[local]
{\singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
{\singleseparatestep{curid}{oracle}{(\spstate{ps}{gl})}{\ccemptytrace}{(\spstate{ps'}{gl})}}

\inferrule[log]
{
\getseparatelog{id}{gl}{l}\\
\oget{\set{curid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}{(id, l, \separateeventtwoidnoeq{e}}{oracle}{l_0} \\
\separatelogtwolog{(\listappoppo{l_0}{l}}{id}{sl}\\
\separatelogstep{curid}{id}{(\localview{ps}{sl})}{ps'}{e}
\setseplogkwd{id}{(\listappoppo{\listconsoppo{e}{l_0}}{l})}{gl}{gl'}
}
{\singleseparatestep{curid}{oracle}{(\spstate{ps}{gl})}{\ccemptytrace}{(\spstate{ps'}{gl'})}}
\end{mathpar}
\caption{Separate Step Machine Model.}
\label{fig:chapter:conlink:separate-step-rules}
\end{figure}

With the new state definition and multiple auxiliary functions regarding the state definition in Figure~\ref{fig:chapter:conlink:auxiliary-funcitons-for-single-separate-machine},
we presents the single separate step machine model in Figure~\ref{fig:chapter:conlink:separate-step-rules}, 
the last piece of our multicore linking framework 
as well as an abstract but expressive machine model that can be connected with 
the machine model for the local layer interface.
Again, the machine model the local layer interface is $\lasmmach$ in our case, but it is not restricted to  $\lasmmach$, but can be applied to other machines that satisfy specific properties, mostly the properties about hardware configurations. 
The machine model contains two rules; the first is for the local private evaluation
and the other is for the shared operation that updates the proper log that is associated with the shared object 
identifier and remains other logs for other shared objects as same.



%%%%%%%%%%5
\begin{figure}
\noindent\fbox{auxiliary function, valid log, and valid oracle for global log:}
%
%  Fixpoint remove_cache_event (l: Log) (tid: Z) :=
%    match l with
%      | nil => nil
%      | e :: l' =>
%        if zeq tid (event_source e) then l
%        else remove_cache_event l' tid
%    end
%

$$
\removecacheeventkwd (l : \mclog) (cpuid : \ztype): \mclog := 
 \left\{\begin{array}{lr}
\nulllist & \text{for } l = \nulllist \\
\listconsoppo{ev}{l_r'} & \text{for } l = \listcons{ev}{l'}  \wedge \eventsourcefunc{e}{cpuid}\\
    &  \wedge \removecacheevent{l'}{cpuid}{l_r'}\\
l_r' & \text{for } l = \listconsoppo{ev}{l'}  \wedge \eventsourcefuncnoeq{e}\neq {cpuid}\\
    &  \wedge \removecacheevent{l'}{cpuid}{l_r'}\\
\end{array} \right.
$$

\begin{mathpar}
\inferrule[valid log']
{\mcreducelogfunc{l}{l}}
{\validlogprim{l}}
\end{mathpar}
%
%\noindent\fbox{variables for match relation}

$$
\begin{array}{l}
\validoracleprimkwd (cpuid: \ztype) (o : \mcoracle{\set{cpuid}}{\mclog}{\mclog}) := \\
\ \ \ \ \forall \ l \ l' . \ \validlogprim{l} \rightarrow \oget{\set{cpuid}}{\mclog}{\mclog}{l}{o}{l'} \rightarrow\\
\ \ \ \ \ \ \ \ (\forall \ e . e \in l' \rightarrow \eventsourcefuncnoeq{e} \neq cpuid) \wedge \validlogprim{l'}\\
\end{array}
$$
%$$
%\begin{array}{lllr}
%cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
%sep\_o & : & \mcoracle{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd} &  \mbox{(separate log type oracle)}\\
%re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(reordered log oracle)}\\
%\end{array}
%$$

\noindent\fbox{match logs : $\ztype \rightarrow \separatelogkwd \rightarrow \mclog \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match log]
{\getseparatelog{id_{prim}}{l_{sep}}{l_{h}}\\
\loggetatom{l_{glob}}{id_{prim}}{l_l}\\
\separatelogtwolog{l_h}{id_{prim}}{\removecacheeventnoeq{l_l}{curid}}}
{\mcmatchlogs{curid}{l_{sep}}{l_{glob}}}
\end{mathpar}

\noindent\fbox{match state : $\ztype \rightarrow \spstatekwd \rightarrow \rstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{\validlogprim{l_{glob}}\\
\mcmatchlogs{curid}{l_{sep}}{l_{glob}}}
{\matchspstaterstate{curid}{(\spstate{ps}{l_{sep}})}{(\rstate{ps}{l_{glob}})}}
\end{mathpar}

%\noindent\fbox{hypothesis}
%\begin{enumerate}
%\item valid$\_$oracle$'\_$def: $\validoracleprim{cpuid}{re\_o }$
%\item relate$\_$separate$\_$oracle$\_$reorder$\_$oracle$\_$def:\\
%$
%\begin{array}{l}
%\forall \ ps \ l_{sep} \ l_{glob} \ id  \ l_{id} \ l_{id}' \ e .\ \matchspstaterstate{curid}{(\spstate{ps}{l_{sep}})}{(\rstate{ps}{l_{glob}})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \getseparatelog{id}{l_{sep}}{l_{id}} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \oget{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}{(id, l_{id}, e)}{sep\_o}{l_{id}'} \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   \exists \ l_{glob}' .\ \oget{\set{cpuid}}{\mclog}{\mclog}{l_{glob}}{re\_o}{l_{glob}'} \wedge \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \loggetatom{\listapp{l_{glob}'}{l_{glob}}}{id}{\separatelogtwolognoeq{\listapp{l_{id}'}{l_{id}}}{id}} \\
%\end{array}
%$
%\end{enumerate}
%
%\noindent\fbox{top lemmas}
%\begin{enumerate}
%\item one$\_$step$\_$separate$\_$refines$\_$reorder : \\
%$
%\begin{array}{l}
%\forall \ s_h \ s_h' \ t \ s_l . \ \singleseparatestep{cpuid}{sep\_o}{s_h}{t}{s_h'} \rightarrow  \matchspstaterstate{cpuid}{s_h}{s_l} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \singlereorderstep{cpuid}{re\_o}{s_l}{t}{s_l'} \wedge  \matchspstaterstate{cpuid}{s_h'}{s_l'}\\
%\end{array}
%$
%\end{enumerate}
\caption{Auxiliary Functions and State Match Relation: for the refinement between the separate machine model and the reorder machine model}
\label{fig:chapter:conlink:separate-refines-reorder}
\end{figure}

Proving the refinement between the evaluation on single separate machine model and the 
evaluation on the reordered machine model 
requires a few definitions and auxiliary  functions and also a math relation between states of two machines,
and Figure~\ref{fig:chapter:conlink:separate-refines-reorder} provides those definitions. 
Among them, $\removecacheeventkwd$ is a key function that maps two different types of log,
 a single global log and a set of logs. 
With those definitions, 
Lemma~\ref{lemma:chapter:conlink:separate-refines-reorder} states 
the refinement lemma between evaluations on two different machines.

%By using them, we finally prove the separate step rules in Figure~\ref{fig:chapter:conlink:separate-step-rules}. 
%It is same with the reorder step rules concerning
%having two rules, local rules for private steps and log rules for the operations on shared states. 
%
%
%Figure~\ref{fig:chapter:conlink:auxiliary-functions-separate-refines-reorder} and 
%Figure~\ref{fig:chapter:conlink:separate-refines-reorder} shows 
%the related auxiliary functions, match relations, hypothesis, and proofs for them.

%\begin{hypothesis}[valid$\_$oracle$'\_$def]
%\begin{tabular}{P{0.95\textwidth}}
%$\validoracleprim{cpuid}{re\_o }$
%\end{tabular}
%\end{hypothesis}


\begin{lemma}[one$\_$step$\_$separate$\_$refines$\_$reorder]
\label{lemma:chapter:conlink:separate-refines-reorder}
Let's assume that there is a valid CPU ID $start\_cpu$ ($start\_cpu \in \coreset$),
an oracle $re\_o$ for a global log with the type $\mcoracle{\set{cpuid}}{\mclog}{\mclog}$, and a oracle for a set of logs 
$sep\_o$ with the type $\mcoracle{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}$.
When the oracle for a global logis valid ($\validoracleprim{cpuid}{re\_o }$) we can show the following fact
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singleseparatestep{cpuid}{sep\_o}{s_h}{t}{s_h'} \rightarrow  \matchspstaterstate{cpuid}{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \singlereorderstep{cpuid}{re\_o}{s_l}{t}{s_l'} \wedge  \matchspstaterstate{cpuid}{s_h'}{s_l'}\\
\end{array}
$
\end{tabular}
\end{center}
with the assumption about two different oracles as follows:
\begin{center}
\begin{tabular}{P{0.95\textwidth}}
$
\begin{array}{l}
\forall \ ps \ l_{sep} \ l_{glob} \ id  \ l_{id} \ l_{id}' \ e .\ \matchspstaterstate{curid}{(\spstate{ps}{l_{sep}})}{(\rstate{ps}{l_{glob}})} \rightarrow \\
 \ \ \ \ \ \getseparatelog{id}{l_{sep}}{l_{id}} \rightarrow   \oget{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}{(id, l_{id}, e)}{sep\_o}{l_{id}'} \rightarrow \\
 \ \ \ \ \  \exists \ l_{glob}' .\ \oget{\set{cpuid}}{\mclog}{\mclog}{l_{glob}}{re\_o}{l_{glob}'} \wedge \\
 \ \ \ \ \ \ \ \ \ \  \ \ \ \ \loggetatom{\listapp{l_{glob}'}{l_{glob}}}{id}{\separatelogtwolognoeq{\listapp{l_{id}'}{l_{id}}}{id}} \\
\end{array}
$
\end{tabular}
\end{center}
\end{lemma}


%$$
%\begin{array}{lllr}
%cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
%sep\_o & : & \mcoracle{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd} &  \mbox{(separate log type oracle)}\\
%re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(reordered log oracle)}\\
%\end{array}
%$$



%
%
%
%\begin{hypothesis}[relate$\_$separate$\_$oracle$\_$reorder$\_$oracle$\_$def]
%\begin{tabular}{P{0.95\textwidth}}
%$
%\begin{array}{l}
%\forall \ ps \ l_{sep} \ l_{glob} \ id  \ l_{id} \ l_{id}' \ e .\ \matchspstaterstate{curid}{(\spstate{ps}{l_{sep}})}{(\rstate{ps}{l_{glob}})} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \getseparatelog{id}{l_{sep}}{l_{id}} \rightarrow \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \oget{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}{(id, l_{id}, e)}{sep\_o}{l_{id}'} \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   \exists \ l_{glob}' .\ \oget{\set{cpuid}}{\mclog}{\mclog}{l_{glob}}{re\_o}{l_{glob}'} \wedge \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \loggetatom{\listapp{l_{glob}'}{l_{glob}}}{id}{\separatelogtwolognoeq{\listapp{l_{id}'}{l_{id}}}{id}} \\
%\end{array}
%$
%\end{tabular}
%\end{hypothesis}


