
\subsection{Multithreaded Linking Overview}
\label{chapter:linking:subsec:multithreaded-linking-overview}

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{figs/conlink/thread-linking}
\end{center}
\jieung{I will redraw this figure later (better drawing is necessary)}
\caption{Thread Linking Structure}
\label{fig:chapter:conlink:threadlinking}
\end{figure}

Using them, the basic idea is similar to it for multicore linking. 
The basic structure of multithreaded linking is described in Figure~\ref{fig:chapter:conlink:threadlinking}.
To introduced the per-thread layer machine, 
the first thing is dividing a single CPU machine into multithreaded machine models,
which implies that the state of the machine is 
a set of private states a single shared log. 
A set of private states is a partial map from a thread id to its private state designed as a tuple that contains 
a register set, a memory, as well as an abstract state. 

In the figure, the bottom layer interface (\cf Figure~\ref{fig:chapter:conlink:threadlinking} (1)) is still a CPU-local layer,
and the layer contains only one register set and one private abstract data in its state.
The layer definitely captures the execution of the whole thread set of CPU $c$ 
and does not support thread-local reasoning.
As a first step of building thread-local layer interface, 
we divide our CPU-local private data (a private register set, a memory, and a private abstract data) into multiple thread-local
private datum (Figure~\ref{fig:chapter:conlink:threadlinking}). 
Since the layer contains multiple private datum, we also add the flag for currently-running thread $curid$ in the state. 
By doing this, we can also resolve one challenge in our thread-local machine, which is to replace an assembly style 
context switch with no-op like operation. 
The layer contains per-thread register sets and, thus, the register values do not need to update along the change of the currently-running thread id. By changing the thread id alone, the layer knows which thread-local private data should be 
used during the current evaluation.
Now each thread can use its own private data for its evaluation, but that is not sufficient at all. 
In fact, scheduling switches in this layer has a similar meaning with the ones in the lower layer, 
$\CSched$ (\ie, the blue $\yield$) but with differentcontext switching styles.
Ideally, we would like to reason about each thread execution 
independently, and later formally combine the reasoning to obtain a global
property for the full set of threads on the same CPU.
So, we need a machine model that gives semantics to
a partially-composed set of threads to support this.

Therefore,  a new layer (\cf Figure~\ref{fig:chapter:conlink:threadlinking} (3)) has to be introduced such that other 
threads' operations can be modeled as input strategies to the layer interface. 
Here, we introduced a new kind of environment context, $\oracle^{t}$, which contains the strategy the environmental threads and is the key to support  thread-local reasoning.
Formally, let $T_c$ be the whole thread set running over CPU $c$.
From a CPU-local layer  $\PLayer{L}{c}{}$,  we construct a 
 \emph{multithreaded} layer $\TLink{L}{c}{\threadset_a} := (\PLayer{L}{c}{},
 \Rely^t, \Guard^t)$,
which is 
parameterized over an active thread set $\threadset_a \subseteq \fullthreadset$.
The rely condition $\Rely^t$ defines a set of acceptable thread contexts
$\oracle^t$ and the guarantee condition $\Guard^t$ specifies the events generated by active threads. 
Since our machine model does not allow
preemption, $\oracle^t$ will only be queried during the execution of scheduling primitives, 
which have two kinds
of behaviors  depending on whether the \emph{target
thread} is active or not.

Considering an execution in Fig.~\ref{fig:chapter:conlink:threadlinking} (3) with active thread set
$\threadset = \{0\}$, whenever an execution switches (by $\yield$ or $\sleep$) 
to a thread outside of $\threadset_a$ (\ie, the yellow $\yield$),
it takes environmental steps (\ie, notated as arrows), repeatedly appending the 
events returned by the environment context $\oracle$ and the thread
context $\oracle^t$ to the log until a $\yield$
event indicates that control switches back to an active thread.


This layer is already a thread local because it only captures the behavior of one thread.
However, the strategy query in this layer follows small-step style, and this is insufficient to build thread-local layer interface because we do not want to query multiple times for a single yield call. 
Therefore, we introduce another  layer to merge those multiple strategy queries into a single big-query (\cf Figure~\ref{fig:chapter:conlink:threadlinking} (4)). 
Finally, the last thing to do is to connect the machine state of thread-local layers to our general concurrent layer interface, which has the form of $(\regs, m, a, l)$.
Therefore, we introduced the last layer (Figure~\ref{fig:chapter:conlink:threadlinking} (5)) that will become a base to build our multithreaded layers.
