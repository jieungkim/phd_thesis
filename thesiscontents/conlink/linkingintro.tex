\jieung{Check the notations for list app and cons (and others) - those things should be consistent with the operators in previous sections}
   

Specifically, we propose  $\ccalname$ in Chapter~\ref{chapter:ccal} and show the example of its usage, the MCS Lock verification, in Chapter~\ref{chapter:mcs-lock}.
They, however, do not mention about the last piece of concurrent program verification, 
combining the verified multiple proof instances of the program
to form the claim that the full concurrent program guarantees the correctness,
which usually named as a parallel composition. 
Chapter~\ref{chapter:ccal} also informally mention that providing a  parallel composition rule for more than one
concurrent layers associated with a partially focused set of participants in the system. 
It, however, overlooked and missed multiple challenges in the composition when it is related to real programs,
% which need to deal with details of programs, 
such as a complex interaction between private state and shared state in the actual system
and connecting the proof composition with the appropriate existing and efficient tool for verification (\ie, a $\compcert$ compiler to use C language for program verification).
Thus, this chapter focuses on  issues when providing compositions in concurrent program verification,
both for multicore and multithreaded cases.

We realize that those concurrent linking has a considerable cost when compared to building layers for local reasoning (CPU-local layers or thread-local layers).
First, concurrent linking requires machine syntax and semantics 
for the whole program as long as partial concurrent programs (or the machine that can run either of them.)
providing those machine models, however, also related to the source language of our verified programs.
To help the development of the system software, 
the tool that can support both high-level languages (C) as well as low-level ones (Assembly) and 
compose the programs written by them is necessary.
The previous work, $\compcertx$, the extension of $\compcert$
supports powerful tool for building layered programs with single threaded (or sequential like) programs with 
resolving those issues.
In this sense, 
building the sequential like programs (and providing local layer interface) discussed in Section~\ref{chapter:ccal:subsec:local-layer-interface} 
is promising with those machine models,
but they are not for parallel compositions. 
In this sense, at each time when providing parallel proof composition, 
we should give the machine model that runs multiple instances of programs (\ie, a multicore machine model and a multithreaded machine model.) 
Therefore, we formally define (sequential consistency) multicore machine model that is reusable for multiple machines (such as ARM and $\intelmachine$),  
as well as a multithreaded machine model with a capability of using software schedulers. 



Second,  
the linking proof should be generic as much as possible to reduce the impact of its high cost and complexity. 
Some of the linking proofs need to depend
on the program implementation (such as software scheduler implementation or process creation), 
but those dependencies should be minimized to apply the complex proofs to other implementations (or other machine models). 

Third, 
concurrent linking proofs (parallel composition proofs) 
are not only needed to handle the interaction between shared resources but also need to manage the private resources in sometimes. 
For example, a process creation in operating systems usually allocate the maximum resources 
for the created process (which are typically determined by their parent process).
In some cases, those resources include a private state that does not share with other threads at all. 

%First, providing the refinement between the whole program (with multicore/multithreaded machine models) means 
%that we actually need to define those machine models. 
%Second, we also need to hide the nondeterminism as soon as possible 
%to facilitate the forward-to-backward simulation techniques 
%in $\compcert$ in our 
%multicore/multithreaded machine models,
%which provides the tool for us to connect all programs runs on the all layers (or other machines) together. 
%Third, 
%optimization in the global log or environmental context query are necessary to provide the 
%them. 
%we have to introduce multiple intermediate languages, 
%prove refinement between those languages, 
%and connect those languages with the assembly machine model that can be used with CompCert. 


We overcome those issues by introducing multiple environment configurations, abstract intermediate languages,
proofs between those languages,  
as well as applying those definitions to the linking techniques to the existing verified concurrent operating systems. 
None of the previous works expose those challenges or empirical studies in linking for concurrent program verification,
that we discuss in this paper.
%This chapter is not aiming to introduce a new theory, 
%but provide a valuable empirical study that 
%about the composition of large-scale concurrent program verification that many readers are interested in it.


\section{Overview}
\label{chapter:conlink:sec:overview}

% do we need to add it for the paper version?
%\begin{figure}
%\caption{Example of Linking}
%\label{fig:conlink:overview-example}
%\end{figure}


\begin{figure}
\jieung{Need to revise those figures. If I will add the linking with concrete layers in the next section, I need to simplify those figures}
\begin{center}
\includegraphics[width=0.7\textwidth]{figs/conlink/cpu_linking_structure}\newline
(a) Multicore linking structure
\end{center}
\begin{center}
\includegraphics[width=0.7\textwidth]{figs/conlink/thread_linking_structure}\newline
(b) Multithreaded linking structure
\end{center}
\textbf{Note:} Components in grey boxes are discussed in the next chapter, but we include them in this figure for better understanding.
\caption{Concurrent Linking Structure.}
\label{fig:chapter:conlink:concurrent-linking-structure}
\end{figure}

% concurrent layer  - the proof
Certified Concurrent Abstraction Layer  ($\ccalname$) 
has proven that it is a useful and efficient tool 
for building and verifying concurrent programs with the layered structure 
as we have shown in Chapter~\ref{chapter:ccal} and Chapter~\ref{chapter:mcs-lock}.
In MCS Lock verification, for example, provide 
the theorem:
\begin{center}
$\ltyp{\PLayer{\mmcsbootfull}{cid}{\oracle_{mcs}}}{R_{mcs}}{\codeinmath{M}_{\codeinmath{mcslock}}}{\PLayer{L_{\mhmcslockopfull}}{cid}{\oracle^{lk}_{cid}}}$,
\end{center}
which means that ``any context program plus the implementation of MCS Lock ($\codeinmath{M}_{\codeinmath{mcslock}}$) runs on top of 
  layer $\mmcsbootfull$ with CPU ID $cid$ and the environmental context $\oracle^{mcs}_{cid}$ \textit{contextually refines}
 the same context program runs on the of  layer $\mhmcslockopfull$ with CPU ID $cid$ and the environmental context $\oracle^{lk}_{cid}$''. 
The proof, however, does not consider the program that runs with the whole CPUs in the system, thus a partial correctness statement. 
To guarantee the full correctness of the program,
providing the judgment that handles the program with the whole CPU set in it, which is
%In this purpose, 
%We add the parallel composition rules in the layer calculus of $\ccalname$ in Section~\ref{chapter:ccal:subsec:local-layer-interface}, which is 
\begin{definition}[Parallel Composition]
\label{definition:conlink:parallel-composition}
For any program $ \codeinmath{P}$, a full focused set for the system ($D$), a valid environmental context for the layer with the singleton focused set in $D$ ($\oracle^{\codeinmath{local}}_{i}$), and a layer $L_{\codeinmath{full}}$ and $L_{\codeinmath{local}}$ related with a certain 
refinement relation $R_{comp}$, we define the parallel composition as follows:
\begin{center}
$\forall \codeinmath{P}. \ \semwmachine{L_{\codeinmath{full}}[D]}{\codeinmath{P}}{\machkwd_{\codeinmath{full}}} \refines_{R_{comp}} \sum_{i \in D}\  (\semwmachine{\PLayer{L_{\codeinmath{local}}}{i}{\oracle^{\codeinmath{local}}_i}}{\codeinmath{P}}{\machkwd_{\codeinmath{local}}})$
\end{center}
when  $\codeinmath{mach}_{\codeinmath{full}}$ is a machine model that runs the layer with the full focused set (without any environmental contexts),
$\codeinmath{mach}_{\codeinmath{local}}$ is a machine model that runs the layer with a singleton focused set (such as a machine model of $\compcertx$)
\end{definition}
Also, 
providing the evidence that shows the connection between a program runs with single local machine with a proper environmental context and a program runs on top of the concurrent machine with the full focused set in the system is required
 for us to provide the evidence that
the local layers built on top of our local layer interface $\codeinmath{mach}_{\codeinmath{local}}$ is 
formally connected with the program without any environment contexts with the full machine model.
The formal definition of it is
\begin{definition}[Concurrent Linking]
\label{definition:conlink:concurrent-linking}
For any program $ \codeinmath{P}$, a full focused set for the system ($D$), a valid environmental context for the layer with the singleton focused set in $D$ ($\oracle^{\codeinmath{local}}_{i}$), and a layer $L_{\codeinmath{full}}$ and $L_{\codeinmath{local}}$ related with a certain 
refinement relation $R_{comp}$, we define the concurrent linking as follows:
\begin{center}
$\forall \codeinmath{P}. \ \semwmachine{L_{\codeinmath{full}}[D]}{\codeinmath{P}}{\codeinmath{mach}_{\codeinmath{full}}} \refines_{R_{link}} \semwmachine{\PLayer{L_{\codeinmath{local}}}{i}{\oracle^{\codeinmath{local}}_{i}}}{\codeinmath{P}}{\codeinmath{mach}_{\codeinmath{local}}}$
\end{center}
$\codeinmath{mach}_{\codeinmath{local}}$ is a machine model that runs the layer with a singleton focused set (such as a machine model of $\compcertx$)
\end{definition}
which we call it concurrent linking.
%\begin{mathpar}
%\inferrule{L[i] }{\jieung{Need to add composition rule}\\
%\jieung{the PCOMP rule in the ccal paper is not supported at all in our framework.}}
%\end{mathpar}
%\begin{mathpar}
%\inferrule{
%\ltyp{\PLayer{L_1}{A}{\oracle_A}}{R}{M}{\PLayer{L_2}{A}{\oracle_A'}} \\
%\ltyp{\PLayer{L_1}{B}{\oracle_B}}{R}{M}{\PLayer{L_2}{B}{\oracle_B'}
%}\\
%\Compose{\PLayer{L_1}{A}{\oracle_A}}{\PLayer{L_1}{B}{\oracle_B}}{\PLayer{L_1}{A \cup B}{\oracle_C}} \\
%\Compose{\PLayer{L_2}{A}{\oracle_A}}{\PLayer{L_2}{B}{\oracle_B}}{\PLayer{L_2}{A \cup B}{\oracle_C}}
%}{\ltyp{\PLayer{L_1}{A \cup B}{\oracle_C}}{R}{M}{\PLayer{L_2}{A \cup B}{\oracle_C'}}}
%\end{mathpar}
Proofs for them is based on the compositionality of multiple strategies 
of partial programs discussed in Section~\ref{chapter:ccal:subsec:concurrent-linking-and compilation-for-local-layer}.   
It looks simple in a high-level idea, but the reality is not simple at all
due to the reasons that we have discussed.  \jieung{Will add more details (by restating the previous parts a little bit.)}
To solve those issues, 
we introduce multiple configurations, auxiliary functions, as well as intermediate languages for linking. 
In the case of multicore linking (Figure~\ref{fig:chapter:conlink:concurrent-linking-structure} (a)),
our purpose is using the framework not only for one single concurrent programs run on a specific machine model, 
but also use it for other programs with other hardware models that satisfy the generic hardware setting properties. 
Based on the abstract hardware setting, 
we built multiple layers of languages to refine non-deterministic multicore machine model 
into the local layer interface that can use $\compcertx$ compiler as well as 
hide the behavior of other instances in other CPUs.
For example, 
it requires us to introduce partial machines with environmental context which can run a program with focused CPU set, 
and introduce a per-CPU machine that only runs one CPU on it (but differs from $\compcertx$'s machine). 
We also need to prove the refinement proofs between all those intermediate machine models
that can be injected to $\compcert$'s backward simulation theorems to guarantee the connection between this concurrent linking framework with $\ccalname$'s local layer's contextual refinement proofs. 
Then, that multicore linking template should be able to be used for any layers alongside with sequential machine model in $\compcertx$ when they satisfy certain properties related to the abstract hardware setting. 

\jieung{need to revise the following part. It's quite ambiguous now}
For multithreaded linking case (Figure~\ref{fig:chapter:conlink:concurrent-linking-structure} (b)), most claims in multicore linking remain almost the same. 
It, however, usually located in the middle of the system software stack, which already contains multiple primitives in the layer; thus requires handling some of software and machine dependent properties when implementing linking framework as well as proving linking theorems. 
It also requires us to handle mutual exclusiveness of 
private states, including memories, register values, and private fields in abstract data (such as page table allocations.)
In addition to that, it also requires us to assign proper initial states for all threads in the system if we want to prove that the composition of multithreaded linking has the same behavior of the multithreaded program runs on the CPU-local layer. 
To handle them, we also introduce multiple intermediate machine models that can parameterize abstract layer as well as thread configurations, and use various auxiliary functions and auxiliary properties related to the abstract layer (and the top-most layer in the CPU-local machine as well as the bottom-most layer in the thread-local machine). 
After we provide that linking framework, users need to 
fill out the layer definition, configurations, and the generic properties to link the layer for each thread and the layer for each CPU.

All in all, we provide the generic linking framework that minimizes the user's effort as much as possible.
This chapter focuses on discussing the linking framework itself.
We will discuss the applicability of this framework by adapting it to the large-scale concurrent program verification, a concurrent operating system in the next Chapter.


\jieung{Things to do; strengthen the claim by adding more sentences; compare it with CompCertTSO paper -- it's not hard; cite A formally verified compiler back-end paper}






%\ignore{ 
%\section{CCAL Review}
%\jieung{This is only for papers}
%
%CCAL, the extention of is an extension of the  Certified Abstraction Layer proposed by~\cite{deepspec}, 
%provides a state transition machine for certified concurrent program.
%With the variance of $\compcert$, that gets the layer as its parameter, 
%programs can directly run on the state transition machines and can be formaly connect to the 
%other layers 
%with layer calculus that the tool provides. 
%
%It also supports 
%compositional reasoning for a single instance of 
%It is a collection of layers, and each layer 
%is a abstract machine that can run C and assembly programs on it. 
%
%Key definitions of CCAL is defined in Fig.~\ref{fig:key-definitions-of-ccal}. 
%Each layer is is a set of 
%
%
%The definition of a  CCAL over the instance identifier $i$ (\textit{i.e.} CPU ID or thread ID)
%is a tuple with four elements, notated as $L[i,\oracle] := (\Layer, \Rely, \Guard)$.
%The first component $\Layer$ contains a partial map from
%identifiers to transition specifications
%($\Layer := \set{\primid \mapsto \primspec{\primid}}$ where $ \primspec{\primid}$ is
%the specification of the primitive $\primid$).
%The state of the layer can be interpreted as a pair
%of the private abstract state for the instance $i$ ($lst_i$), and
%a log of events ($l$) that represents the history of the atomic operations ($st_i := (lst_i, l)$).
%The local state consists of multiple machine-dependent concrete definitions such as register and memory values (,
%as well as abstract objects that correspond to
%certain regions of memory through some relation.
%For specifications of primitives that only touch local state, the transition is straightforward.
%Specifications of primitives that contain network transition primitives, on the other hand,
%must use the environment context for the instance $i$ ($\oracle_i$)
%to model the behavior of other instances.
%For example, the specification of a function that broadcasts a message from a proposer to a set of acceptors must query the environment context
%between each send to learn how the environment has changed.
%The other two components of the layer definition, $\Rely$ and $\Guard$,
%provide invariants about the network and the distributed system
%following the approach of previous work on rely/guarantee systems~\cite{RGSim, LRG}.
%The invariants in $\Rely$ and $\Guard$ are complementary to each other.
%Each layer must contain evidence that all of the local transitions satisfy the conditions in $\Rely$.
%Conversely, we can restrict the behavior of other instances by using assuming the conditions in $\Rely$ hold.
%One example of a rely/guarantee rule in Paxos concerns the relation between the round number and value in a Phase 1b message.
%It is true that the value is $\bot$ if and only if the round number is $\bot$.
%To prove that this invariant always holds it is enough to show that
%for layer $L'[i]$, every transition of instance $i$ will satisfy it.
%Having satisfied the guarantee, we can rely on the fact that the invariant will hold for all other single instances in the system.
%
%
%
%$/ccalname$ also provides a way to build a layer on top of another using a program module $M$, which consists of code written in C or assembly.
%The predicate $L'[i] \vdash_R  M : L[i]$ indicates that the layer implementation $M$, built on top of the interface $L'[i]$, rigorously implements
%the layer $L[i]$ with the two layers related by $R$.
%CCAL can compile these C modules using the CompCertX certified compiler~\cite{deepspec},
%which is a modified version of CompCert~\cite{compcert}.
%This, combined with the {\em contextual} correctness property,
%lets us define contextual refinement over abstraction layers with the ability to compile layers.
%A certified layer converts any {\em safe} client program $P$ running on top of $L'[i]$ into one that has the
%same behavior but runs on top of $L[i]$ by compiling the abstract
%primitives in $L[i]$ into their implementation in $M$.
%If we use ``$\sem{L[i]}{\cdot}$'' to denote the behavior of the layer machine based on
%$L[i]$, the correctness property of ``$\ltyp{L'[i, \oracle']}{R}{M}{L[i, \oracle]}$'' is written
%formally as ``$\forall{}P.\sem{L'[i, \oracle']}{P\oplus{}M} \refines_R \sem{L[i, \oracle]}{P}$''
%where $\oplus$ denotes a linking operator over programs $P$ and $M$ and 
%the relation ($\refines_R$) is formally defined as a forward
%simulation~\cite{Lynch95,leroy09,Milner71,Park81} with the (simulation) relation $R$.
%
%$\ccalname$ compiles these modules with the $\compcertx$ certified compiler~\cite{deepspec},
%which is a modified version of $\compcert$~\cite{deepspec, compcert}.
%The {\em implements} relation ($\refines_R$) is formally defined as a forward
%simulation~\cite{Lynch95,leroy09,Milner71,Park81} with the (simulation) relation $R$.
%This guarantees that if $L'[i] \vdash_R  M : L[i]$ holds,
%the behaviors allowed by layer $L[i]$ simulate those allowed by $L'[i]$.
%
%Certified layers enforce a {\em contextual} correctness property as well.
%A certified layer converts any {\em safe} client program $P$ running on top of $L'[i]$ into one that has the
%same behavior but runs on top of $L[i]$ by compiling the abstract
%primitives in $L[i]$ into their implementation in $M$.
%If we use ``$\sem{L[i]}{\cdot}$'' to denote the behavior of the layer machine based on
%$L[i]$, the correctness property of ``$\ltyp{L'[i]}{R}{M}{L[i]}$'' is written
%formally as ``$\forall{}P.\sem{L'[i]}{P\oplus{}M} \refines_R \sem{L[i]}{P}$''
%where $\oplus$ denotes a linking operator over programs $P$ and $M$.
%
%The implements relation also applies to the environment context and the network.
%Formally,\\
%$\begin{array}{l}
%\forall \varphi_l \in \oracle'_i, \exists \varphi_h,  \varphi_h \in \oracle \wedge R_{\oracle', \oracle}(\varphi_l , \varphi_h) \\
%\hfill (\mbox{where} \ L'[i] = (\_,  \oracle'_i, \_, \_) \ \mbox{and} \ L[i] = (\_,  \oracle, \_, \_))
%\end{array}
%$\\
%This allows us to simplify our view of the possible network behaviors by showing that certain reductions refine the interleaved pattern.
%}