\section{Multicore Linking}
\label{chapter:linking:sec:multicore-linking}

Multicore linking provides the evidence that the program execution on
our local layer (CPU local layer) is connected to the execution of the same program on our multicore machine model. 
%To do that, concurrent linking (composition) usually requires assumptions about the environment. 
We assume the environment with the following constraint:
the fixed number of CPUs, the fixed initial state for all CPUs,
and the fairness among CPUs.
With those assumptions, 
concurrent linking for multicore needs to solve multiple challenges;
(1) hide the nondeterminism of a multicore machine model (by using the strategy of a hardware scheduler);
(2) build an environmental context for each CPU:
(3) prove the compositionality of multiple per-PCU machines;
(4) provide a simple environmental context for per-CPU machines;
and (5) finally connect this multicore-linking framework with the machine for the local layer interface
The last piece of the multicore linking ((5) in Figure~\ref{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking}) 
must be manually proven, depending on the local layer interface and its underlying machine model (\ie, $\intelmachine$, ARM, or RISC-V).
In our case study in Chapter~\ref{chapter:certikos}, the machine model is the assembly machine of $\compcertx$--$\lasmmach$--
and the bottom layer of the system ($\mmcsbootfull$), which is also briefly discussed in Chapter~\ref{chapter:mcs-lock}.
%Section~\ref{chapter:ccal:sec:ccal-overview} provides the way to handle 
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth, page=1]{figs/conlink/concurrent_linking}
\end{center}
\caption{Intermediate Languages and Their Relations in Multicore Linking Framework.}
\label{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking}
\end{figure}
Tackling all those challenges in a single step is not feasible.
In that sense, 
we  introduced multiple intermediate languages 
to handle all the challenges step by step (sometimes,
resolving one challenge requires multiple intermediate languages
for simple proofs.) 
Figure~\ref{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking} shows
all the intermediate languages as well as the proof structure  we  built for concurrent linking. 
Numbers in the figure are exactly matched with the numbers for the challenges. 




%Concurrent_Linking_Lib.v 	Basic libraries for data types.
%Concurrent_Linking_Def.v 	Definitions for the multiprocessor machine model, evaluation rules, and other intermediate languages that are useful for connecting the multiprocessor machine model with LAsm. The intermediate machine models contain the concurrent layer interface and calculus.
%Concurrent_Linking_Prop.v 	Refinement proofs between machine models that are defined in Concurrent_Linking_Def.v.
%Concurrent_Linking_Additional_Prop.v 	Additional properties of machine models that are defined in Concurrent_Linking_Def.v. The proofs in this file are not used in the verification of mC2, but may be useful for other purposes.
%
%
%Concurrent_Linking_Def.v contains the abstract definition of the multiprocessor machine model, hardware_step, which is then instantiated as a concrete hardware semantics by filling in abstract definitions required by the hardware_step rule (See section 5-4 (4) in this document or ccal/mcertikos/multicore/semantics/HWStepSemImpl.v).
%
%To define the multiprocessor machine model (Section 3.1 in the submission), we first define a template for the hardware setting (HardWareSetting). The definitions in here correspond to the definitions in Figure 7 of our submission. For example, when we link all abstract machine models with LAsm, private_state can be instantiated as a tuple that contains a set of registers, a memory, and private abstract data of each CPU. Furthermore, shared_piece can be instantiated as those parts of memory which are protected by the push/pull model of our framework. The file also contains the definition of events. Among them, EYIELD and EBACK are related to scheduling transitions, EACQ and EREL are for the push/pull model, and EATOMIC is for the event that will be generated by any atomic evalution.
%
%With this hardware setting, we also provide program transition rules of the mulitprocessor machine model (see HardSemantics in Concurret_Linking_Def.v). There are four kinds of program transitions, and we define hardware_local_step using those abstract definitions. Then, the multiprocessor machine model is defined to always perform one scheduling step and one program transition step (see hardware_step). Using the same hardware configuration and semantics, the concurrent layer interface (Section 3.2 in the submission) is also defined in the same file as env_step.
%
%In this way, we define a layer interface involving only one CPU, which we call the CPU-local layer interface. In the file, single_step is already a CPU-local layer interface because it only contains a single CPU's state, abstracting away other CPUs' behavior as an environmental context. However, this single_step machine model is not suitable for building per-CPU layers because we cannot directly use our multi-layer calculus and the extended CompCert. To use the existing tools as much as possible without huge modifications, we introduce multiple intermediate languages that can be used to link single_step with LAsm, corresponding to the CPU-local layer interface in Section 3.2 of the submission. These are: single_big_step, single_big2_step, single_split_step, single_reorder_step, and single_separate_step. These languages are also defined in Concurrent_Linking_Def.v.
%
%After the lowest layer of our CPU-local layer interface is defined (mboot layer in our artifact file - see Section 5-4 (4) in this document or ccal/mcertikos/ticketlog/MBoot.v), our toolkit can connect all machine models for multicore linking by using refinement proofs provided by Concurrent_Linking_Prop.v. This is mostly straightforward, and is illustrated by our example 5-4. (4) (see the definitions and proofs in mcertikos/multicore). One exception is the refinement proof between single_separate_step layer and the LAsm layer, as this is not part of our toolkit (since this proof heavily relies on the definition of the mboot layer in our mC2 example).
