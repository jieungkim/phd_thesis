\section{Multicore Linking}
\label{chapter:linking:sec:multicore-linking}

Multicore Linking is to provide the evidence that the program execution on
our local layer (CPU local layer) is connected to the execution of the same program on our multicore machine model. 
To do that, concurrent linking (composition) usually requires assumptions about the environment. 
We assume that the environment with the following constraint:
fixed number of CPUs, the fixed initial state for all CPUs,
as well as the fairness among CPUs.
With those assumptions, 
concurrent linking for multicore need to solve multiple challenges;
(1) hide non-determinism of multicore machine model (by using the strategy of hardware scheduler);
(2) build environmental context for each CPU;
(3) prove compositionality of multiple per-PCU machines;
and (4) provide a simple environmental context for per-CPU machines. 
%Section~\ref{chapter:ccal:sec:ccal-overview} provides the way to handle 
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth, page=16]{figs/conlink/concurrent_linking}
\end{center}
\caption{Intermediate Languages and their relationships for Multicore Linking.}
\label{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking}
\end{figure}
Tackling all those challenges in a single step is not feasible at all. 
In that sense, 
we have introduced multiple intermediate languages 
to handle all challenges step by step (sometimes,
resolving one challenge requires multiple intermediate languages
for simple proofs.) 
Figure~\ref{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking} shows
all the intermediate languages as well as the proof structure that we have built for concurrent linking. 
Numbers in the figure are exactly matched with the number for the challenges. 

