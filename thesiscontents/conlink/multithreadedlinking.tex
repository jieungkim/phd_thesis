\section{Multithreaded Linking}
\label{chapter:linking:sec:multithreaded-linking}
\jieung{This section (precisely this chapter) requires multiple revisions!! I tried to fill out this part as soon as possible 
to have SOMETHING!!!!}


The purpose of building a framework for multithreaded linking is similar to 
the that of our multicore part,
provide the thread-local interface 
by hiding other threads' behavior. 
It, however, differs from multicore linking part, of which the  context and the configuration 
are simpler than those of multithreaded linking part. 
When looking at the multithreaded linking, 
systems already has to provide 
scheduling related primitives (\ie, yield, sleep, create)
as well as other system services 
that are necessary to implement those primitives. 
For example, 
thread (process) creation usually related to the 
resource management,
such as the maximum number of memories.
In addition, 
some memory areas for multiple threads should be 
mutually exclusive from others. 
In addition to that, 
several private state,
which is hidden from other threads,
has to be properly initialized 
according to other thread.
Those initialized values
 are usually determined by their parents, 
 and they are dynamically allocated.

To sum up, 
Multithreaded linking poses 
multiple challenges based on the environment for the multithreaded programs.
We assume that 
there are arbitrary active or available thread set on the CPU, 
Which does not need to be a sequence of consecutive numbers.
For example, when the maximum range of
the thread number in the system i from 0 to 1023, 
then, CPU 1 may be able to run threads associated the numbers that can be divided by 8. 
Each thread associated with the 
designated thread ID. 
It is possible for threads to use the same identifier again, but 
we avoid this re-usage of the same number because it increase complexity without a huge benefits. 
We, however, assume that the thread set is set of non-consecutive unbounded numbers,
which gives a huge freedom. 
In addition to that, 
we allow dynamic initial states for each thread. 
For example, each thread has maximum capacity of page numbers that they have get is 
assigned by its parent. 
Simpler systems may not allow this dynamic allocation for each thread,
but many systems assign appropriate initial state for each thread 
according to the information when the thread has been spawned.

Using those environment, 
our purpose multthreaded linking is listed as follows:
1) hide context switching between threads; 
2) construct the environmental context for each thread and show the relationship between the 
CPU-local machine evaluation with the each thread's evaluation based on the environmental context;
3) prove compositionalilty of multiple per-thread machines; and 
4) provide the same (almost similar) interface for per-thread layers 
for users to build layers on top of thread local machines. 
\jieung{need to explain more about those challenge}
\jieung{Expecially about context switching - page 20 of concurrent linking slide}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth, page=21]{figs/conlink/concurrent_linking}
\jieung{Need to redraw this figure to add only one env-context for thread local layers}
\caption{Multithreaded Linking Structures.}
\label{fig:chapter:linking:multithreaded-linking-structure}
\end{center}
\end{figure}
Similar to the multicore linking, 
those challenges are hard for us to solve within a single step. 
In this sense, 
we also introduce multiple intermediate languages
in Figure~\ref{fig:chapter:linking:multithreaded-linking-structure}. 


The bottom level of mulithreaded linking is 
a layer that contains scheduling primitives, thread sleep and yield.
Formally, 
when the layer $\CSched[cpuid, \oracle_{cpuid}] = (\Layer_{\CSched}, \ignorechar, \ignorechar)$, which is parameterized by the focused CPU ID ($cpuid$) and the proper environmental context ($\oracle_{cpuid}$), 
the layer should satisfies 
$(\threadyieldfunc, \ignorechar) \in \Layer_{\CSched}$ as well as 
$(\threadsleepfunc, \ignorechar) \in \Layer_{\CSched}$. 
This is the minimum requirement for the multithreaded linking proofs. 
Consequently, 
the top-most layer in the thread local machine
has to include those two primitives. 
Formally, 
when the layer $\TSched[thrd, \oracle_{thrd}] = (\Layer_{\TSched}, \ignorechar, \ignorechar)$, which is parameterized by the focused thread identifier ($thrd$) and the proper environmental context ($\oracle_{thrd}$), 
the layer should satisfies 
$(\threadyieldfunc, \ignorechar) \in \Layer_{\TSched}$ as well as 
$(\threadsleepfunc, \ignorechar) \in \Layer_{\TSched}$. 
They, however, differs from 
the same primitives 
in  $\CSched$ in terms of their behavior. 
The CPU local machine that uses $\CSched[cpuid, \oracle_{cpuid}]$  as its parameter 
uses the state which is defined as
a tuple, 
$(rs, m, a, l)$,
which represents 
a register set, a memory, an abstract state, and a log.
Among them, a register set, a memory, and an abstract state are private datum for CPU local machines. 
In this sense, scheduling primitives, including $\threadyieldfunc$ and $\threadsleepfunc$,
modifies them during their transitions. 
Especially, they requires the change in the register values,  context switching,
which stores the current thread's register value 
and restore the register values for the next scheduled thread. 

To introduce a thread local interface while keeping a capability of 
using the same compiler with the CPU local interface ($\compcertx$, 
thread local layers also has to use the same state definition and the machine model 
with the CPU local interface, which is $(rs, m, a, l)$.
The private state of it, however, 
is only related to the thread. 
In this sense, 
behaviors of scheduling primitives remain those thread local states as they are in their machines. 
The only element that can be changed  in the thread local machine during the scheduling primitives 
is the shared log $l$. 

To hide them, 
we introduced multiple intermediate languages 
that has a transition rules of those primitives explicitly, and the 
the layer that are used as an argument of 
intermediate languages ($\TLink$) is introduced which does not contain those scheduling primitives in it. 

These differences are also applied to 
other primitives in $\CSched$ and $\TSched$.
Some primitives in $\CSched$ accesses CPU-local data, but some of them 
are not always easy to divide them clearly for each thread. 
Pages in the memory, for example, 
can be dynamicaly allocated, thus 
each thread does not know exactly 
which pages are associated with the thread statically
(\ie, it is possible for us to assume that each thread statically 
reserve the number of pages as well as 
the actual page number, but this is far from usual design principal.)
With the given concrete layer definitions for 
all $\CSched$, $\TLink$, as well as $\TSched$,
providing the detailed 
way to divide the CPU-local private states into multiple thread local private states 
may be possible. 
We, however, divide this process 
as two parts, the connection between machine models based on the configurations and abstract relations, 
and introduce the instances of them to link the concrete CPU local machine with 
the thread local machine. 
To make it general as much as possible, 
we have defined two abstract relations, 
which is $AbsRelC$ and $AbsRelT$ in the figure with will work 
with the arbitrary layers for each machines as well as the thread configuration $C$. 



\subsubsection{Idea} 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{figs/conlink/thread-linking}
\end{center}
\jieung{I will redraw this figure later (better drawing is necessary)}
\caption{Thread Linking Structure}
\label{fig:chapter:conlink:threadlinking}
\end{figure}

Using them, the basic idea is similar to it for multicore linking. 
The basic structure of multithreaded linking is described in Figure~\ref{fig:chapter:conlink:threadlinking}.
To introduced the per-thread layer machine, 
the first thing is dividing a single CPU machine into multithreaded machine models,
which implies that the state of the machine is 
a set of private states a single shared log. 
A set of private states is a partial map from a thread id to its private state designed as a tuple that contains 
a register set, a memory, as well as an abstract state. 

In the figure, the bottom layer interface (\cf Figure~\ref{fig:chapter:conlink:threadlinking} (1)) is still a CPU-local layer,
and the layer contains only one register set and one private abstract data in its state.
The layer definitely captures the execution of the whole thread set of CPU $c$ 
and does not support thread-local reasoning.
As a first step of building thread-local layer interface, 
we divide our CPU-local private data (a private register set, a memory, and a private abstract data) into multiple thread-local
private datum (Figure~\ref{fig:chapter:conlink:threadlinking}). 
Since the layer contains multiple private datum, we also add the flag for currently-running thread $curid$ in the state. 
By doing this, we can also resolve one challenge in our thread-local machine, which is to replace an assembly style 
context switch with no-op like operation. 
The layer contains per-thread register sets and, thus, the register values do not need to update along the change of the currently-running thread id. By changing the thread id alone, the layer knows which thread-local private data should be 
used during the current evaluation.
Now each thread can use its own private data for its evaluation, but that is not sufficient at all. 
In fact, scheduling switches in this layer has a similar meaning with the ones in the lower layer, 
$\CSched$ (\ie, the blue $\yield$) but with differentcontext switching styles.
Ideally, we would like to reason about each thread execution 
independently, and later formally combine the reasoning to obtain a global
property for the full set of threads on the same CPU.
So, we need a machine model that gives semantics to
a partially-composed set of threads to support this.

Therefore,  a new layer (\cf Figure~\ref{fig:chapter:conlink:threadlinking} (3)) has to be introduced such that other 
threads' operations can be modeled as input strategies to the layer interface. 
Here, we introduced a new kind of environment context, $\oracle^{t}$, which contains the strategy the environmental threads and is the key to support  thread-local reasoning.
Formally, let $T_c$ be the whole thread set running over CPU $c$.
From a CPU-local layer  $\PLayer{L}{c}{}$,  we construct a 
 \emph{multithreaded} layer $\TLink{L}{c}{\threadset_a} := (\PLayer{L}{c}{},
 \Rely^t, \Guard^t)$,
which is 
parameterized over an active thread set $\threadset_a \subseteq \fullthreadset$.
The rely condition $\Rely^t$ defines a set of acceptable thread contexts
$\oracle^t$ and the guarantee condition $\Guard^t$ specifies the events generated by active threads. 
Since our machine model does not allow
preemption, $\oracle^t$ will only be queried during the execution of scheduling primitives, 
which have two kinds
of behaviors  depending on whether the \emph{target
thread} is active or not.

Considering an execution in Fig.~\ref{fig:chapter:conlink:threadlinking} (3) with active thread set
$\threadset = \{0\}$, whenever an execution switches (by $\yield$ or $\sleep$) 
to a thread outside of $\threadset_a$ (\ie, the yellow $\yield$),
it takes environmental steps (\ie, notated as arrows), repeatedly appending the 
events returned by the environment context $\oracle$ and the thread
context $\oracle^t$ to the log until a $\yield$
event indicates that control switches back to an active thread.


This layer is already a thread local because it only captures the behavior of one thread.
However, the strategy query in this layer follows small-step style, and this is insufficient to build thread-local layer interface because we do not want to query multiple times for a single yield call. 
Therefore, we introduce another  layer to merge those multiple strategy queries into a single big-query (\cf Figure~\ref{fig:chapter:conlink:threadlinking} (4)). 
Finally, the last thing to do is to connect the machine state of thread-local layers to our general concurrent layer interface, which has the form of $(\regs, m, a, l)$.
Therefore, we introduced the last layer (Figure~\ref{fig:chapter:conlink:threadlinking} (5)) that will become a base to build our multithreaded layers.

\subsection{Single core machine model}
\label{chapter:linking:subsec:cpu-local-layer-interface}

The bottom level of multithreaded linking, a cpu local layer has a similar state definition with $\compcert$. 
They follows the definition of $\compcertx$, 
which is an extension of $\compcert$ and is defined as
\begin{lstlisting}[language=Caml]
Inductive state `{memory_model_ops: Mem.MemoryModelOps mem}: Type :=
  | State: regset -> mem -> state.
\end{lstlisting}
where the memory, $mem$, contains a memory itself (a partial map from a identifier to the value), an abstract data (which is a collection of abstract data representations), as well as
a global log.
In other words, 
$mem$ in the state is precisely a tuple consists of those three elements.
With those definitions, the evaluation transition relation has a type
\begin{lstlisting}[language=Caml]
  Inductive step (ge: genv): state -> trace -> state -> Prop :=
\end{lstlisting}
which change the state by the transition with recording $\compcert$ style trace. 

The step relation contains five rules, 
but we explain only three rules in this section, which are the rules 
that are sufficient for us to explain our thread-linking framework.

\begin{lstlisting}[language=Caml]
    | exec_step_internal:
        forall b ofs f i rs m rs' m',
        rs PC = Vptr b ofs ->
        Genv.find_funct_ptr ge b = Some (Internal f) ->
        find_instr (Int.unsigned ofs) f.(fn_code) = Some i ->
        exec_instr ge f i rs m = Next rs' m' ->
        step ge (State rs m) E0 (State rs' m')
\end{lstlisting}
The first rule is for internal instruction revaluation rules, 
that defines the rules for bunch of possible instructions including 
memory load and stores. 
\begin{lstlisting}[language=Caml]
    | exec_step_external:
        forall b ef args res rs m t rs' m',
        rs PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        extcall_arguments rs m (ef_sig ef) args ->
        external_call' (fun _ => True) ef ge args m t res m' ->
      rs' = (set_regs (loc_external_result (ef_sig ef)) res (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil) (undef_regs (map preg_of destroyed_at_call) rs))) #PC <- (rs RA) #RA <- Vundef ->
        forall STACK:
        forall b o, rs ESP = Vptr b o ->
                    (Ple (Genv.genv_next ge) b /\ Plt b (Mem.nextblock m)),
        forall SP_NOT_VUNDEF: rs ESP <> Vundef,
        forall RA_NOT_VUNDEF: rs RA <> Vundef,
        step ge (State rs m) t (State rs' m')
\end{lstlisting}
the next one is for external call transition rules, which is
the evaluation rules for external function calls.
\begin{lstlisting}[language=Caml]
    | exec_step_prim_call:
        forall b ef rs m t rs' m',
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          primitive_call ef ge rs m t rs' m' ->
          step ge (State rs m) t (State rs' m').
\end{lstlisting}
The third is a primitive call that is also similar to the external calls,
but all information is hidden in the specifications. 
\jieung{1. Do we actually need to explain it? I think we do not  need to do}
\jieung{If we explain it, we need to explain primitive calls more} 
\begin{lstlisting}
  Inductive initial_state {F V} (p: AST.program F V): state -> Prop :=
    | initial_state_intro m0:
        Genv.init_mem p = Some m0 ->
        let rs0 :=
          (Pregmap.init Vundef)
          # PC <- (symbol_offset (Genv.globalenv p) (prog_main p) Int.zero)
          # ESP <- Vzero in
        initial_state p (State rs0 m0).
\end{lstlisting}
The initial state of this semantics is define 
set the initial stack pointer as the initial value, which is zero,
and set the program counter as a function pointer for the main function in the program. 

As we have discussed,
the first step is introducing scheduling primitives in our CPU local layers..
In terms of artifacts, 
The language model that we have used in CPU-local layers is $\compcertx$\ propposed by \cite{deepspec}, and 
The machine state of it is
\begin{center}
$st_{\AsmLM} = (\regs, (m, adt))$
\end{center}
where $\regs$ is a register set, $m$ is a memory, and $adt$ is an abstract data.
To use this existing tool as much as possible, we encapsulate the idea of 
our concurrent machine mode in this machine state, 
mostly in the abstract data ($adt$) among the components.
For instance, when looking at the state of the first example (1) in Fig.~\ref{fig:chapter:conlink:threadlinking}, the state is defined as $st = (\rho, m, a, l)$, but both $a$ and $l$ are actually two components of $adt$ in our implementation level.
By successfully integrating our framework with $\compcertx$, we do not need to modify the language semantics and machine model
to build CPU local layers.
For example, the external call rule in $\compcertx$\ $\AsmLM$ machine, 
which is also used for $\yield$ and $\sleep$ functions,  
is defined as follows:
\begin{center}
$c, \oracle \vdash_{\AsmLM} \sstepr{\spec_{_{id}}}{args}{\regs, m, adt}{\textit{res}\cup \{\}}{\regs',  m', adt'}$
\end{center}

\subsection{Multithreaded Environment Configuration}
\label{chapter:linking:subsec:multithreaded-env-configuration}

Similar to the multicore machine model, we provide configurations 
for mutlithreaded linking. 
We have defined the abstract type of 
shared and private states, 
definitions for the global log, 
auxiliary functions,
and properties for those auxiliary definitions. 

\subsubsection{Data Type} 
The abstract data types for the multithreaded machine is defined as follows:
\begin{lstlisting}[language=Caml]
Class SingleData :=
  {
    dshare: Type;
    init_dshare: dshare;
    processor_id : dshare -> Z;
    proc_id: dshare -> Z;
    dproc: Type;
    main_init_dproc: dproc;
    nomain_init_dproc: dproc
  }.
\end{lstlisting} 
there are two abstract data types, $\codeinmath{dshare}$ and $\codeinmath{dproc}$, 
which represent shared data and private data, respectively. 
There are not many restrictions for those types in this definiton, 
but shared data has the information about the CPU id as well as the currently running process ID (thread ID) in it. 
In addition to that, 
the private data has two different kinds of initial states. 
The first is for the main thread, which starts at the beginning, 
and initialize the whole data structures for the whole  threads (for example, the main and idle process 
in operating systems)
On the other hand, the second is for the other threads, 
who are usually children of main process. 

\subsubsection{Thread Machine Memory Model}

% algebraic memory model

\jieung{When writing paper, need to mention that it is in CCAL instead of mentioning it in the paper}
\jieung{Please take a loop at the CCAL paper for better explanation} 
\jieung{Please add drawings}
Multithreaded linking also requires the composition and the decompoisiton of the memory,
which divides a single memory into multiple set of memroy. 
Our system does not allow ownership transfers for the bare memories, 
we could safety assume that the memory can be divided into 
multiple disjoint memories that are owned by the designated threads in the system. 
Based on the assumption, 
we have built algebraic memory model, the extended version of memory model by adding two key relations from $\compcertx$'s memory model.
Those two key relations are 
\begin{lstlisting}[language=Caml]
      mem_disjoint_union : mem -> mem -> mem -> Prop;
      mem_lift_nextblock : mem -> nat -> mem;
\end{lstlisting}
The memory in $\compcertx$ is 
distinguished by its block identifier and a offset for each block. 
The type of block identifier is a natural number,
and we restricts that each thread has distinguished blcok  
The first \lstinline$mem_disjoint_union m1 m2 m3$  shows that 
the $m3$ is the union of $m1$ and $m2$ when $m1$ and $m2$ 
are disjoint from each other. 

The second, \lstinline$mem_lift_nextblock$ 
provides the operation that makes 
the adjustment on the memory possible. 
\jieung{need figure!! Let's first write something and clean up and revise later}


\subsubsection{Thread Configuration}
\begin{lstlisting}[language=Caml]
Class ThreadsConfigurationOps := {      
    current_CPU_ID: Z; // The ID for the CPU we're looking at. (necessary?) 
    current_thread: Z; // The thread we're looking at in high-level machines
    dev_handling_cid : Z; // specific thread for handling device drivers 
    vm_handling_cid : Z; // specific thread for handling this CPU's virtual machine 
    non_current_thread_list: list Z;  // The other threads on this CPU 
    full_thread_list := current_thread :: non_current_thread_list; // The full list
    main_thread: Z; // The main thread on this CPU 
    limit: nat // A log look-back limit used in TAsm  }.
\end{lstlisting}

Thread linking also requires multiple configurations about 
the environment of the system. 
For example, \lstinline$current_CPU_ID$ is the CPU ID that is 
associated with the current local layer.
Layer $\CSched$ is associated with \lstinline$current_CPU_ID$, 
and all threads associated with $\TLink$ and $\TSched$ layers 
are also run with  \lstinline$current_CPU_ID$.
The \lstinline$current_thread$ 
is a variable for the focused thread ID For the thread local layer. 
The layer above $\TSched$ is parameterized by the thread id (\lstinline$current_thread$). 
The full thread list is a set of thread identifiers 
which run on top of the current CPU ID. 
It is a union of the current thread identifier, a singleton set, 
and a non current threads. 
There are no restrictions on the size of the full thread set in here,
differently with the full CPU set in multicore linking configuration.
the main thread is a main thread (which initializes the system) of the CPU. 
This may differs from the current thread identifier or same with the current thread identifier.
the limit is for the fairness assumptions. 
It is necessary for the composition in our systems, 
because of all queries to extract the other threas' behavior via the associated environmental context 
should return in a finite number of events generated by the environmental context. 

Similar to the multicore linking case, 
shared resources are represented as a log, \lstinline$Definition Log := list LogEvent.$,  a list of event.
The event definition is 
\begin{lstlisting}[language=Caml]
// encode the argument in the log event
Inductive LogEventUnit :=
| LogYield (n: positive)
| LogSleep (i: Z) (n: positive) (syncch : option AuxStateDataType.SyncChanPool)
| LogPrim (id: ident) (args: list lval) (choice : Z) (dprocSnap : privDataSnap) 
| LogYieldBack.

Inductive LogEvent :=| LEvent : Z -> LogEventUnit -> LogEvent.
\end{lstlisting}
Our framework allows 
two scheduling primitives, 
yield and sleep. 
Those two primitives use their designated events to keep the information in the global log. 
Yield event does not need to contain many information in it, it just needs to give the control
to an another thread (among the therad in the same CPU). 
The sleep event, however, is usually related to the conditional variable and a shared resource among CPUs..
In this sense, we have to memorize the conditional variable that the sleep call uses ($i$),
and the snapshot of the shared resource, $AuxStateDataType.SyncChanPool)$.  \jieung{need to change the definition for general representation}
Other primitives that access the shared resources trigger the primitive event. 
They memories the primitive name, the argument for the primitive name. 
% The choice check is - it does not need to be.... 
The private data snapshot is a snapshot for the private data when the primitive has been invoked. 
They are not always necessary, but some primitives may be required to be memorized. 
For example, the acquire lock and the release lock primitives 
has to memorize the snapshot of the (abstract) private data when they have been invoked. 
The last event, \lstinline$LogYieldBack$ is the memorize the 
moment to figure out when each thread re-achieve the evaluation control. 
\jieung{Need to explain it more}

\begin{lstlisting}[language=Caml]
Class SingleOracleOps := {
  init_log: Log;
  Single_Oracle : Log -> LogEvent;
  init_nb : positive  }.
\end{lstlisting}
The environmental context \lstinline$Single_Oracle$ 
then can be defined as a function that gets the current log and returns the event. 
In addition to that, 
each thread has to have its initial log 
for the evaluation. 
For example,
when the thread 2 starts its evaluation after 
thread 1 and 3 has been spawned and scheduled. 
the thread 2 has to cotain all those information in its initial log.

\subsubsection{Auxiliary Functions}

Based on the configurations, we provide multiple auxiliary functions 
for thread local machines to calculate necessary information. 
\begin{lstlisting}[language=Caml]
  Class SingleOracle  `{single_data: SingleData} `{single_oracle_ops : SingleOracleOps}  
        `{threads_conf_ops : ThreadsConfigurationOps} := {
      update : dshare -> Log -> dshare;
      has_event: ident -> bool;      
      uRData (l: Log) : dshare := update (init_dshare) l;      
      choice_check: ident -> list lval -> dshare -> dproc -> Z;
      sync_chpool_check: ident -> list lval -> dshare -> dproc -> option SyncChanPool;
      snap_func : dproc -> privDataSnap;
      snap_rev_func : privDataSnap -> dproc; 
      thread_init_dproc : Z-> dproc;
      state_checks (name : ident) (largs: list lval) (l : Log) 
        (pdp: ZMap.t (option dproc)) :=
        match ZMap.get (proc_id (uRData l)) pdp with 
          | Some pd => state_check name largs l pd
          | _ => True
        end;
      PHThread2TCompose : option KContext -> dshare -> dproc -> RData;      
      thread_init_rdata (tid: Z) :=
        PHThread2TCompose
          None
          (uRData init_log)
          (thread_init_dproc tid);
      prim_thread_init_pc {F V} (ge: Genv.t F V): ident -> list lval -> option val }.
\end{lstlisting}
update and uRData functions are  declarations of a replay function for the global log. 
The has event function is for check whether the primitive calls has to trigger the event or not. 
we also requires the snapshot functions for the events as we have seen in the above.
And two important abstract function declarations 
are \lstinline$thread_init_dproc$ and \lstinline$prim_thread_init_pc$ functions 
that calculate the initial abstract data for the thread as well as the initial program counter value 
for the thread. 
\jieung{Need to remove some of them}
Later, when we want to link the concrete layer definitions using our multithreaded linking library, users need to define them.

\subsubsection{Auxiliary Properties}

\begin{lstlisting}[language=Caml]
Class ThreadsConfiguration `{s_oracle : SingleOracle}: Prop := {
  CPU_ID_valid: forall l, processor_id (uRData l) = current_CPU_ID;
  main_valid: In main_thread full_thread_list;
  null_log_proc_id: proc_id (uRData nil) = main_thread;
  main_thread_val: main_thread = current_CPU_ID + 1;
  current_CPU_ID_range: 0 <= current_CPU_ID < Constant.TOTAL_CPU;
  dev_handling_cid_constraint: dev_handling_cid = main_thread;
  init_log_proc_id: proc_id (uRData init_log) = current_thread;
  valid_thread_list: forall i, In i full_thread_list -> 
    Constant.TOTAL_CPU < i < Constant.num_proc \/ i = main_thread;
  all_cid_in_full_thread_list: forall l, In (proc_id (uRData l)) full_thread_list;
  full_thread_list_prop: NoDup full_thread_list }. 
\end{lstlisting}

Those are the property about the auxiliary functions. 
They are usually for the minimum conditions of 
thread configurations. 
For example, 
the \lstinline$CPU_ID_valid$ tells that all the scheduling result of this CPU 
will not change the CPU ID. 
in addition, 
the main thread always have to be a member of a thread set. 
Those properties also have to be instantiated later with the concrete definitions.

%\begin{lstlisting}
%Record high_level_invariant (abd: RData) := 
%\end{lstlisting}
%
%\begin{lstlisting}
%
%  Class SingleOracleProp `{thread_conf_prf: ThreadsConfiguration}:=
%    {
%
%      (* assumptions about update functions - proc_id and processor_id preserve property *)
%      update_proc_id:
%        forall d d' d'' l a,
%          update d l =  d' ->
%          getLogEventType a = LogOtherTy ->
%          update d (a :: l) =  d'' ->
%          proc_id d'' = proc_id d';
%
%      update_processor_id:
%        forall d d' d'' l a,
%          update d l = d' ->
%          update d (a::l) = d'' ->
%          processor_id d'' = processor_id d';
%
%    (** This checks whether the given primitive call initializes any
%        thread. If so, returns the thread's id and initial register state. *)
%
%      init_data_low_level_invariant n:
%        low_level_invariant n (thread_init_rdata current_thread);
%
%      init_data_phthread_high_level_invariant:
%        PHThreadInvariant.high_level_invariant (thread_init_rdata current_thread);
%       
%      prim_thread_init_pc_global:
%        forall {F V} (ge: Genv.t F V) f vargs v,
%          prim_thread_init_pc ge f vargs = Some v ->
%          (exists id ofs, symbol_offset ge id ofs = v);
%
%      prim_thread_init_pc_symbols_preserved:
%        forall {F V} (ge1 ge2: Genv.t F V) f vargs v,
%          (forall i, Genv.find_symbol ge1 i = Genv.find_symbol ge2 i) ->
%          prim_thread_init_pc ge1 f vargs = Some v ->
%          prim_thread_init_pc ge2 f vargs = Some v
%    }.
%\end{lstlisting}
\begin{lstlisting}
Class SingleOracleProp `{thread_conf_prf: ThreadsConfiguration}:= {
  update_proc_id:
    forall d d' d'' l a, update d l =  d' ->
      getLogEventType a = LogOtherTy ->
      update d (a :: l) =  d'' -> proc_id d'' = proc_id d';
  update_processor_id:
    forall d d' d'' l a, update d l = d' -> 
      update d (a::l) = d'' -> processor_id d'' = processor_id d';
       
  prim_thread_init_pc_global:
    forall {F V} (ge: Genv.t F V) f vargs v,
      prim_thread_init_pc ge f vargs = Some v ->
      (exists id ofs, symbol_offset ge id ofs = v);

  prim_thread_init_pc_symbols_preserved:
    forall {F V} (ge1 ge2: Genv.t F V) f vargs v,
      (forall i, Genv.find_symbol ge1 i = Genv.find_symbol ge2 i) ->
      prim_thread_init_pc ge1 f vargs = Some v ->
      prim_thread_init_pc ge2 f vargs = Some v }.

Class SingleOracleLinkProp `{thread_conf_prf: ThreadsConfiguration}:= {
  Oracle_le_nb: 
  forall l, (last_nb l <= last_nb (Single_Oracle l :: l)) % positive;

  oracle_event_yield_back:
    forall l, lastEvType l = Some LogYieldTy ->
      exists i, Single_Oracle l = LEvent i LogYieldBack;

  oracle_init_log:
    forall (l': Log) (e: LogEvent) (l: Log),
      init_log = l' ++ e :: l -> Single_Oracle l = e;
      
  init_log_structure:
    init_log = nil \/
    exists l e, init_log = LEvent (proc_id (uRData l)) LogYieldBack :: l /\
      proc_id (uRData l) <> proc_id (uRData nil) /\ last_op l = Some e /\
      getLogEventNB e <> None /\
      forall e l1 l2, l = l1 ++ e :: l2 ->
        proc_id (uRData l2) <> 
        proc_id (uRData init_log) }.
\end{lstlisting}
We also defined multiple properties related to 
update functions as well as initial log. 
\lstinline$SingleOracleProp$ contains properties about auxiliary functions, 
and \lstinline$SingleOracleLinkProp$  contains the constraints
the properties about the log that 
the log has to  satisfy them. 

\jieung{I think exposing all those functions in here is not a good idea. I need to rearrange them.} 

\section{Multithreaded Machine Model}
\label{chapter:linking:subsec:multithreaded-machine-model}

Based on those definitions, we have formally defined 
the multithreaded machine model that we have briefly 
mentioned in Figure~\ref{fig:chapter:linking:multithreaded-linking-structure}.
\begin{lstlisting}[language=Caml]
Inductive ThreadState := | Environment | Available | Running (rs: regset).
Fixpoint initial_map {A} (z: A) (i: Z -> A) (tids: list Z): ZMap.t A :=
  match tids with
    | nil => ZMap.init z
    | tid::tids' => ZMap.set tid (i tid) (initial_map z i tids')
  end.
Definition init_regset {F V} (ge: Genv.t F V) i :=
  if decide (i = main_thread) then
    let pc := symbol_offset ge 1%positive Int.zero in
    Running ((Pregmap.init Vundef) # PC <- pc # ESP <- Vzero)
  else Available.
Definition init_dproc (i : Z)  :=
  if zeq main_thread i then main_init_dproc else nomain_init_dproc.
\end{lstlisting}



\begin{lstlisting}[language=Caml]
  Inductive estate: Type :=
    | EState: Z -> ZMap.t ThreadState -> mem -> EData -> Log -> estate.
\end{lstlisting}


\begin{lstlisting}[language=Caml]
  Inductive estep (ge: genv) : estate -> trace -> estate -> Prop :=
\end{lstlisting}


\begin{lstlisting}[language=Caml]
    | eexec_step_internal:
        forall b ofs f i (rs: regset) m m' dp d d' ds' rs' curid rsm l,
          ZMap.get curid rsm = Running rs ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b ofs ->
          Genv.find_funct_ptr ge b = Some (Internal f) ->
          find_instr (Int.unsigned ofs) f.(fn_code) = Some i ->
          lastEvType l <> Some LogYieldTy ->
          exec_instr ge f i rs (m, (uRData l,d)) = Next rs' (m', (ds',d')) ->
          forall (Hget_dp: ZMap.get curid dp = Some d),
            estep ge (EState curid rsm m dp l) E0
                  (EState curid (ZMap.set curid (Running rs') rsm) m' (ZMap.set curid (Some d') dp) l)
\end{lstlisting}


\begin{lstlisting}[language=Caml]

  | eexec_step_external:
      forall b ef args res (rs: regset) m m' dp d d' ds' t rs' curid rsm l l',
        ZMap.get curid rsm = Running rs ->
        proc_id (uRData l) = curid ->
        rs PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        extcall_arguments rs m (ef_sig ef) args ->
        lastEvType l <> Some LogYieldTy ->
        external_call' (mem:= mwd (cdata PData)) (fun _ => True) ef ge args (m, (uRData l, d)) t res (m', (ds',d')) ->
        rs' = (set_regs (loc_external_result (ef_sig ef)) res 
                        (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                                    (undef_regs (map preg_of destroyed_at_call) rs))) 
                #PC <- (rs RA) #RA <- Vundef ->
        (* forall largs_valid: val2Lval_list args largs, *)
        forall NON_YIELD: match ef with
                            | EF_external id _ => 
                              if peq id thread_yield then False
                              else if peq id thread_sleep then False
                                   else
                                     if has_event id then
                                       (* exists largs choice optSyncPool, *)
                                       exists largs choice,
                                         val2Lval_list args largs  /\
                                         choice_check id largs (uRData l) d = choice /\ 
                                         (* sync_chpool_check id largs (uRData l) d = optSyncPool /\  
                                         l' = (LEvent curid (LogPrim id largs choice optSyncPool) :: l) *)
                                         l' = (LEvent curid (LogPrim id largs choice (snap_func d)) :: l) 
                                     else
                                       l' = l
                            | _ => l' = l
                          end,
                          forall STACK:
                          forall b o, rs ESP = Vptr b o ->
                                      (Ple (Genv.genv_next ge) b /\ Plt b (Mem.nextblock m)),
                          forall SP_NOT_VUNDEF: rs ESP <> Vundef,
                          forall RA_NOT_VUNDEF: rs RA <> Vundef,
                          forall (Hget_dp: ZMap.get curid dp = Some d),
                            estep ge (EState curid rsm m dp l) t 
                                  (EState curid (ZMap.set curid (Running rs') rsm) m' (ZMap.set curid (Some d') dp) l')
\end{lstlisting}


\begin{lstlisting}[language=Caml]
    | eexec_step_prim_call:
        forall b ef (rs: regset) m m' dp d d' ds' t rs' curid rsm l l',
          ZMap.get curid rsm = Running rs ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          lastEvType l <> Some LogYieldTy ->
          primitive_call (mem:= mwd (cdata PData)) ef ge rs (m, (uRData l, d)) t rs' (m', (ds', d')) ->
          forall NON_YIELD: match ef with
                              | EF_external id _ => 
                                if peq id thread_yield then False
                                else if peq id thread_sleep then False
                                     else
                                       if has_event id then
                                         l' = (LEvent curid (LogPrim id nil 0 (snap_func d)) :: l)
                                       else
                                         l' = l
                              | _ => l' = l
                            end,
                            forall (Hget_dp: ZMap.get curid dp = Some d),
          estep ge (EState curid rsm m dp l) t 
                (EState curid (ZMap.set curid (Running rs') rsm) m' (ZMap.set curid (Some d') dp) l')
\end{lstlisting}

\begin{lstlisting}[language=Caml]

    | eexec_step_external_yield:
        forall b ef (rs: regset) (m: mem) curid curid' rsm s l l' dp d,
          ZMap.get curid rsm = Running rs ->
          ZMap.get curid dp = Some d ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          stencil_matches s ge ->
          l' = (LEvent curid (LogYield (Mem.nextblock m))::l) ->
          lastEvType l <> Some LogYieldTy ->
          (* event_check (LEvent curid (LogYield (Mem.nextblock m))) -> *)
          state_checks thread_yield nil l dp ->
          curid' = proc_id (uRData l') ->
          forall (NON_YIELD: match ef with
                               | EF_external id _ => 
                                 if peq id thread_yield then True
                                 else False
                               | _ => False
                             end),
            estep ge (EState curid rsm m dp l) E0
                  (EState curid' rsm m dp l')
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | eexec_step_external_sleep:
        forall b ef (rs: regset) (m: mem) curid curid' rsm s l l' dp d i,
          ZMap.get curid rsm = Running rs ->
          ZMap.get curid dp = Some d ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          stencil_matches s ge ->
          l' = (LEvent curid (LogSleep (Int.unsigned i) (Mem.nextblock m)
                                       (sync_chpool_check thread_sleep ((Lint i)::nil) (uRData l) d))::l) ->
          lastEvType l <> Some LogYieldTy ->
          state_checks thread_sleep (Lint i::nil) l dp ->
          curid' = proc_id (uRData l') ->
          forall
            (Hargs: extcall_arguments rs m (mksignature (Tint:: nil) None cc_default) (Vint i:: nil))
            (NON_YIELD: match ef with
                               | EF_external id _ => 
                                 if peq id thread_sleep then True
                                 else False
                               | _ => False
                             end),
            estep ge (EState curid rsm m dp l) E0
                  (EState curid' rsm m dp l')
\end{lstlisting}


\begin{lstlisting}[language=Caml]
    | eexec_step_external_empty:
        forall m curid curid' rsm dp l l',
          ZMap.get curid rsm = Environment ->
          ZMap.get curid dp = None ->
          proc_id (uRData l) = curid ->
          (*
          init_check (uRData l) ->
          flag_checks curid dp ->
          *)
          l' = (Single_Oracle l::l) ->
          curid' = proc_id (uRData l') ->
          estep ge (EState curid rsm m dp l) E0
                (EState curid' rsm m dp l')
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | eexec_step_external_yield_back:
        forall (rs' rs0: regset) (m m': mem) curid rsm l l' nb dp d e,
          (ZMap.get curid rsm = Available /\ initial_thread_kctxt ge curid l = Some rs0) \/
          ZMap.get curid rsm = Running rs0 ->
          ZMap.get curid dp = Some d ->
          proc_id (uRData l) = curid ->
          last_op l = Some e ->
          l' = (LEvent curid LogYieldBack::l) ->
          rs' = (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                            (undef_regs (map preg_of destroyed_at_call) rs0)) 
                  # EAX <- Vundef #PC <- (rs0 RA) #RA <- Vundef ->
          forall
            (Hnextblock: getLogEventNB (e) = Some nb)
            (LIFT_NEXTBLOCK: mem_lift_nextblock m (Pos.to_nat (nb) - Pos.to_nat (Mem.nextblock m) % nat) = m'),
            estep ge (EState curid rsm m dp l) E0
                  (EState curid (ZMap.set curid (Running rs') rsm) m' dp l').
\end{lstlisting}


\begin{lstlisting}[language=Caml]

  Context (active_threads : list Z).

  (** An active main thread is initialized as usual, other active
    threads start out in the [Available] state, and non-active threads
    are assigned to be [Environment] threads. *)

  Inductive einitial_state {F V} (p: AST.program F V): estate -> Prop :=
  | einitial_state_intro: 
      forall m0,
        Genv.init_mem p = Some m0 ->
        let rsm := initial_map Environment (init_regset (Genv.globalenv p)) active_threads in
        let dm := initial_map None (fun i => Some (thread_init_dproc i)) active_threads in
        einitial_state p (EState main_thread rsm m0 dm nil).
\end{lstlisting}

Using them, we are able to provide the generic multithreaded machine mode, $\easm$


\subsubsection{Refinement between EAsm and LAsm}


\begin{lstlisting}[language=Caml]
  Definition total_machine_regset (i : Z) rsm :=
    exists rs, ZMap.get i rsm = Running rs \/ ZMap.get i rsm = Available.

  Definition match_estate_regset (ge: genv) (i: Z) rsm (l : Log) (rs: regset) :=
    (ZMap.get i rsm = Available /\ initial_thread_kctxt ge i l = Some rs) \/
    (ZMap.get i rsm = Running rs).
  
  Definition match_estate_kctxt (rs: regset) (kctxt: regset) :=
    forall r n, PregtoZ r = Some n -> rs r = kctxt r.

  (** We need to maintain the following invariant: any running thread
    has already been initialized. *)

  Definition thread_init_invariant (ge: genv) rsm l :=
    forall i rs,
      ZMap.get i rsm = Running rs ->
      initial_thread_kctxt ge i l <> None.
\end{lstlisting}


\begin{lstlisting}[language=Caml]

  Definition do_init (ge: genv) (e : option LogEvent) l (kctxt: KContextPool) :=
    match e with
      | None => kctxt
      | Some e =>
        match thread_init_pc ge e with
          | Some (i, pc) =>
            match initial_thread_kctxt ge i l with
              | Some _ => kctxt
              | None => ZMap.set i (initial_regset_kctxt pc) kctxt
            end
          | None => kctxt
        end
    end.
\end{lstlisting}


\begin{lstlisting}[language=Caml]
      Class AbstractRel :=
        {
          match_EData_RData: EData -> Log -> RData -> Prop;

          match_init:
            match_EData_RData
              (initial_map None (fun i => Some (thread_init_dproc i)) full_thread_list)
              nil
              (init_adt multi_oracle_init7);
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]          
          match_gss:
            forall l dp d a
                   (Hget_dp : ZMap.get (proc_id (uRData l)) dp = Some d)
                   (Hdata : match_EData_RData dp l a),
              match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d) dp) l a;
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]          
          acc_exec_load_match:
            forall (ge: genv) a rs rd rs' TY (m m': mem) ds' l dp d' d addr,
              (acc_exec_load (cl_oplus (cdata PData) LH L64)) 
                fundef unit ge TY ((m, (uRData l, d)) : mwd (cdata PData)) addr rs rd 
              = Next rs' ((m', (ds', d')) : mwd (cdata PData)) ->
              lastEvType l <> Some LogYieldTy ->
              match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d) dp) l a ->
              ZMap.get (proc_id (uRData l)) dp = Some d ->
              exists a',
                PBThread.exec_loadex ge TY ((m, a) : mwd (cdata RData)) addr rs rd 
                = Next rs' ((m', a') : mwd (cdata RData)) /\
                ds' = uRData l /\
                match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d') dp) l a' /\
                kctxt a' = kctxt a;
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]     
          acc_exec_store_match:
            forall (ge: genv) a rs rd rs' TY ST (m m': mem) ds' l dp d' d addr,
              (acc_exec_store (cl_oplus (cdata PData) LH L64)) 
                fundef unit ge TY ((m, (uRData l, d)) : mwd (cdata PData)) addr rs rd ST =
              Next rs' ((m', (ds', d')) : mwd (cdata PData)) -> 
              lastEvType l <> Some LogYieldTy ->
              match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d) dp) l a ->
              ZMap.get (proc_id (uRData l)) dp = Some d ->
              exists a',
                PBThread.exec_storeex ge TY ((m, a) : mwd (cdata RData)) addr rs rd ST 
                = Next rs' ((m', a') : mwd (cdata RData))/\
                ds' = uRData l /\
                match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d') dp) l a' /\
                kctxt a' = kctxt a;
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]     
          log_yield_call_match:
            forall (ge: genv) (s : stencil) (b : block) (sg : signature) 
                   (m m' : mem)  rsm rs des_rs' rs' l l' l'' d d' dp (a: cdata RData) nb yield_ev,
              (forall i : Z,
                  In i full_thread_list -> total_machine_regset i rsm) ->
              (forall i : Z,
                  i <> proc_id (uRData l) ->
                  forall rs0 : regset,
                    match_estate_regset ge i rsm l rs0 ->
                    match_estate_kctxt rs0 (ZMap.get i (kctxt a))) ->

              stencil_matches s ge ->
              Genv.find_funct_ptr ge b =  Some (External (EF_external thread_yield sg)) ->
              find_symbol s thread_yield = Some b ->
              
              match_EData_RData dp l a ->
              
              ZMap.get (proc_id (uRData l)) dp = Some d ->
              ZMap.get (proc_id (uRData l)) rsm = Running rs ->
              ZMap.get (proc_id (uRData l')) rsm = Available /\
              initial_thread_kctxt ge (proc_id (uRData l')) l' = Some des_rs' \/
              ZMap.get (proc_id (uRData l')) rsm = Running des_rs' ->
              ZMap.get (proc_id (uRData l')) dp = Some d' ->


              thread_init_invariant ge rsm l ->
              lastEvType l <> Some LogYieldTy ->
              state_checks thread_yield nil l dp ->

              yield_ev = LEvent (proc_id (uRData l)) (LogYield (Mem.nextblock m)) ->
              l' = yield_ev :: l ->
              l'' = LEvent (proc_id (uRData l')) LogYieldBack :: l' ->
              getLogEventNB yield_ev = Some nb ->
              rs PC = Vptr b Int.zero ->
              m' =  (mem_lift_nextblock m (Pos.to_nat (nb) - Pos.to_nat (Mem.nextblock m) % nat)) ->
              rs' = (((undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                                  (undef_regs (map preg_of destroyed_at_call) des_rs'))
                        # EAX <- Vundef) # PC <- (des_rs' RA)) # RA <- Vundef ->
              exists (a': cdata RData),
                primcall_thread_schedule_sem (prim_ident := thread_yield) big_thread_yield_spec s rs (m, a) rs' (m', a') /\
                (forall i' : Z,
                    i' <> proc_id (uRData l'') ->
                    forall rs'' : regset,
                      match_estate_regset ge i'
                                          (ZMap.set (proc_id (uRData l'')) (Running rs') rsm) l'' rs'' ->
                      match_estate_kctxt rs'' (ZMap.get i' (kctxt a'))) /\
                thread_init_invariant ge (ZMap.set (proc_id (uRData l'')) (Running rs') rsm) l'' /\
                match_EData_RData dp l'' a';
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]     
          log_sleep_call_match:
            forall (ge: genv) (s : stencil) (b : block) (sg : signature) 
                   (m m' : mem)  rsm rs des_rs' rs' l l' l'' d d' dp (a: cdata RData) nb sleep_ev i0,
              (forall i : Z,
                  In i full_thread_list -> total_machine_regset i rsm) ->
              (forall i : Z,
                  i <> proc_id (uRData l) ->
                  forall rs0 : regset,
                    match_estate_regset ge i rsm l rs0 ->
                    match_estate_kctxt rs0 (ZMap.get i (kctxt a))) ->
              stencil_matches s ge ->
              Genv.find_funct_ptr ge b =  Some (External (EF_external thread_sleep sg)) ->
              find_symbol s thread_sleep = Some b ->
              extcall_arguments rs m {| sig_args := Tint :: nil;
                                        sig_res := None;
                                        sig_cc := cc_default |} (Vint i0 :: nil) ->
              match_EData_RData dp l a ->
              
              ZMap.get (proc_id (uRData l)) dp = Some d ->
              ZMap.get (proc_id (uRData l)) rsm = Running rs ->
              ZMap.get (proc_id (uRData l')) rsm = Available /\
              initial_thread_kctxt ge (proc_id (uRData l')) l' = Some des_rs' \/
              ZMap.get (proc_id (uRData l')) rsm = Running des_rs' ->
              ZMap.get (proc_id (uRData l')) dp = Some d' ->


              thread_init_invariant ge rsm l ->
              lastEvType l <> Some LogYieldTy ->
              state_checks thread_sleep (Lint i0 :: nil) l dp ->

              sleep_ev = LEvent (proc_id (uRData l)) (LogSleep (Int.unsigned i0) (Mem.nextblock m)
                                                               (sync_chpool_check thread_sleep  (Lint i0 :: nil) (uRData l) d)) ->
              l' = sleep_ev :: l ->
              l'' = LEvent (proc_id (uRData l')) LogYieldBack :: l' ->
              getLogEventNB sleep_ev = Some nb ->
              rs PC = Vptr b Int.zero ->
              m' =  (mem_lift_nextblock m (Pos.to_nat (nb) - Pos.to_nat (Mem.nextblock m) % nat)) ->
              rs' = (((undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                                  (undef_regs (map preg_of destroyed_at_call) des_rs'))
                        # EAX <- Vundef) # PC <- (des_rs' RA)) # RA <- Vundef ->
              exists (a': cdata RData),
                primcall_thread_transfer_sem big_thread_sleep_spec s rs (m, a) rs' (m', a') /\
                (forall i' : Z,
                    i' <> proc_id (uRData l'') ->
                    forall rs'' : regset,
                      match_estate_regset ge i'
                                          (ZMap.set (proc_id (uRData l'')) (Running rs') rsm) l'' rs'' ->
                      match_estate_kctxt rs'' (ZMap.get i' (kctxt a'))) /\
                thread_init_invariant ge (ZMap.set (proc_id (uRData l'')) (Running rs') rsm) l'' /\
                match_EData_RData dp l'' a';
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]     
          external_call_match_no_event:
            forall (ge: genv) WB ef (args: list val) t res (m m' : mem) l d d' ds' (dp : EData) (a: RData),
              external_call' (mem := mwd (cdata PData)) 
                             (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (LH <@$\oplus$@> L64))
                             WB ef ge args (m, (uRData l, d)) t res (m', (ds', d')) ->
              lastEvType l <> Some LogYieldTy ->
              match_EData_RData dp l a ->
              ZMap.get (proc_id (uRData l)) dp = Some d ->
              forall (BUILTIN_ENABLED : match ef with
                                        | EF_external id _ => 
                                          if peq id thread_yield then False
                                          else if peq id thread_sleep then False
                                               else if has_event id then False else True
                                        | _ => True
                                        end),
              exists (a': RData),
                external_call' (mem := mwd (cdata RData)) 
                               (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (pbthread  <@$\oplus$@>  L64))
                                WB ef ge args (m, a) t res (m', a') /\
                ds' = uRData l /\
                match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d') dp) l a' /\
                kctxt a' = do_init ge None l (kctxt a);
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]     
          external_call_match_has_event:
            forall (ge: genv) WB ef (args: list val) (largs : list lval) t res (m m' : mem) l l' d d' ds' 
                   (dp : EData) (a: RData) (choice : Z) (* (optSync : option SyncChanPool) *),
              external_call' (mem := mwd (cdata PData)) 
                             (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (LH  <@$\oplus$@>  L64))
                             WB ef ge args (m, (uRData l, d)) t res (m', (ds', d')) ->
              lastEvType l <> Some LogYieldTy ->
              match_EData_RData dp l a ->
              ZMap.get (proc_id (uRData l)) dp = Some d ->
              val2Lval_list args largs  ->
              forall (BUILTIN_ENABLED : match ef with
                                        | EF_external id _ => 
                                          if peq id thread_yield then False
                                          else if peq id thread_sleep then False
                                               else if has_event id 
                                                    then
                                                      choice_check id largs (uRData l) d = choice /\
                                                      l' = LEvent (proc_id (uRData l)) (LogPrim id largs choice (snap_func d)) :: l 
                                                    else False 
                                        | _ => False
                                        end),
              exists (a': RData),
                external_call' (mem := mwd (cdata RData)) 
                               (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (pbthread  <@$\oplus$@>  L64))
                               WB ef ge args (m, a) t res (m', a') /\
                ds' = uRData l' /\
                match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d') dp) l' a' /\
                kctxt a' = do_init ge (external_function_event ef largs l choice (snap_func d)) l (kctxt a);
\end{lstlisting}
         
\begin{lstlisting}[language=Caml]     
          primitive_call_match:
            forall (ge: genv) ef t rs rs' (m m' : mem) l l' d d' ds' dp (a: cdata RData),
              primitive_call  (LayerConfigurationOps := LC (LH  <@$\oplus$@>  L64))  
                              (mem := mwd (cdata PData)) ef ge rs (m, (uRData l, d)) t rs' (m', (ds', d')) ->
              lastEvType l <> Some LogYieldTy ->
              match_EData_RData dp l a ->
              ZMap.get (proc_id (uRData l)) dp = Some d ->
              forall (BUILTIN_ENABLED : match ef with
                                        | EF_external id _ => 
                                          if peq id thread_yield then False
                                          else if peq id thread_sleep then False
                                               else
                                                 if has_event id
                                                 then
                                                   l' =
                                                   LEvent (proc_id (uRData l)) (LogPrim id nil 0 (snap_func d)) :: l
                                                 else l' = l
                                        | _ => l' = l
                                        end),
              exists (a': cdata RData),
                primitive_call  (LayerConfigurationOps := LC (pbthread  <@$\oplus$@>  L64)) 
                                (mem := mwd (cdata RData)) ef ge rs (m, a) t rs' (m', a') /\
                ds' = uRData l' /\
                match_EData_RData (ZMap.set (proc_id (uRData l)) (Some d') dp) l' a' /\
                kctxt a' = do_init ge (external_function_event ef nil l 0 (snap_func d)) l (kctxt a)
        }.
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    Inductive match_estate_state ge: (estate (mem := mem)) -> 
                                  (state (mem:= mwd (cdata RData))) -> Prop :=
    | MATCH_ESTATE_STATE_NORMAL:
        forall (rs: regset) (m: mem) a ae (l : Log) rsm
               (Hlst_ev_type: lastEvType l <> Some LogYieldTy)
               (Htotal : forall i, In i full_thread_list -> total_machine_regset i rsm)
               (Hrs: match_estate_regset ge (proc_id (uRData l)) rsm l rs) (* my regset *)
               (Hrsm: forall i,
                        i <> (proc_id (uRData l)) ->
                        forall rs0,
                          match_estate_regset ge i rsm l rs0 ->
                          match_estate_kctxt rs0 (ZMap.get i (kctxt a))) (* others' regset will be remained as same *)
               (Hinit_inv: thread_init_invariant ge rsm l)
               (Hdata: match_EData_RData ae l a), 
          match_estate_state ge (EState (proc_id (uRData l)) rsm m ae l) (State rs (m, a))
    | MATCH_ESTATE_STATE_SCHED:
        forall (rs: regset) (m: mem) a ae (l : Log) rsm
               (Hlst_ev_type: lastEvType l = Some LogYieldTy)
               (Htotal : forall i, In i full_thread_list -> total_machine_regset i rsm)
               (Hrs: match_estate_regset ge (proc_id (uRData (remove_hd l))) rsm (remove_hd l) rs) (* my regset *)
               (Hrsm: forall i,
                        i <> (proc_id (uRData (remove_hd l))) ->
                        forall rs0,
                          match_estate_regset ge i rsm (remove_hd l) rs0 ->
                          match_estate_kctxt rs0 (ZMap.get i (kctxt a))) (* others' regset will be remained as same *)
               (Hinit_inv: thread_init_invariant ge rsm (remove_hd l))
               (Hdata: match_EData_RData ae (remove_hd l) a)
               (pre_step: EAsm.estep ge (EState (proc_id (uRData (remove_hd l))) rsm m ae (remove_hd l)) E0
                                     (EState (proc_id (uRData l)) rsm m ae l)),
          match_estate_state ge (EState (proc_id (uRData l)) rsm m ae l) (State rs (m, a)).
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    Theorem EAsm_refine_LAsm:
      forall ge t cst cst' rs m, 
        genv_wf ge ->
        EAsm.estep  ge cst t cst' -> 
        match_estate_state ge cst (State rs m) ->
        (exists st',
          LAsm.step (lcfg_ops := LC (pbthread <@$\oplus$@> L64)) ge (State rs m) t st'
          /\ match_estate_state ge cst' st') \/
        ((measure_estate cst' < measure_estate cst)%nat /\
         t = E0 /\
         match_estate_state ge cst' (State rs m)).
\end{lstlisting}
%\section{Concurrent Multithreaded Machine Model}
%\label{chapter:linking:subsec:concurrent-multithreaded-machine-model}
%
%Our multithreaded machine model relies not on the fixed thread set, but on 
%the dynamic thread set specified by our configuration variables.
%In this sense, the machine model $\easm$ is already a machine model that can run 
%any kind of thread sets on it. 
%Only one rule in $\easm$ need to be added to handle environment threads. 
%
%
%One another level is introducing one more level of multithreaded machine model,
%which only has two memories (memory for self thread and memory for othres).
%This is required due to the current limitaiton of our algebraic memory model. 
%The current algebraic memory model does not support 
%1) n-ary relations; 2) commutativity very well. 
%Thus, providing the refinement theorem is a little bit tricky. 

%%%% FULL EASM %%%%%%%%
%\subsection{Multithreaded Machine Model}\label{subsec:fulleasm}
%
%When it comes with the multithreaded concurrency, however, 
%encapsulating our ideas only in the abstract data 
%and thus in the state of their $\compcertx$\ is insufficient
%due to multiple challenges. 
%First, we have to replace the actual context switching semantics in Assembly source code with no-op 
%like operations in thread-local layers. 
%This simplification of yield and sleep behaviors is unclear when we try to enable it 
%without touching any definitions in the machine model. 
%In addition, thread-local layers should be purely local even for the process create primitive, 
%which establishes the initial user context, kernel context, and other dynamic information for its child. 
%This implies that our thread-local layer interface should have a method to dynamically 
%build its initial state depending on the behavior of its parent. 
%Third, each thread can build its stack in its memory, and it will change the next available block in the memory
%after it calls  $\yield$  or  $\sleep$ .
%Therefore, calling  scheduling primitives can arbitrarily update 
%the memory block based on other threads' behavior, and our thread-local machine need to capture this behavior properly. 
%We also want to use all benefits of $\compcertx$, which are not only layered approach 
%but also behavior preserving between $C$ and complied $Assembly$ programs.
%Lastly, we want a generic and scalable thread-local layer interface as much as possible.
%Even if we add or remove multiple primitives in the layer that we want to link multiple 
%thread-local layers together to refine it into a single CPU-local layer, 
%we want to use the same machine model and reuse mostproofs that we have already done before. 
%To fulfill all the above challenges, we have introduced a concurrent machine model, $\EAsmM{}$.
%\begin{figure}
%\begin{small}
%\[
%\begin{array}{llll llll}
%(\textit{SharedData}) & \dshare & \in & Type &
%(\textit{PrivateData}) &  \dproc & \in & Type\\
%(\textit{InitSharedData}) & \dshare_{init} & \in & \dshare &
%(\textit{ProcessorID}) & \cpuid & \in & \dshare \rightarrow Z\\
%(\textit{ThreadID}) & \procid & \in & \dshare \rightarrow Z&
%(\textit{BlockNum}) & \blocknum & \in & \mathbb{N} \\
%(\textit{Mem}) & m & \in & loc \rightarrow val &
%(\textit{NextBlock}) & \nextblockfun & \in & m \rightarrow  \mathbb{N} \\
%\end{array}
%\]
%\begin{center}
%(1) Data Types and Auxiliary Functions Related to Data Types
%\end{center}
%\vspace{-1em}
%
%\[
%\begin{array}{llllllll}
%(\textit{Lval}) & \lval & \in & Int \cup Ptr  &
%(\textit{Largs}) & \largs & \in & list \ \lval  \\
%(\textit{Ident}) & \threadfunid & \in & \{\yield,\ \sleep,\ \cdots\}&
%(\textit{SnapShot}) & \dsnap & \in & Type  \\
%(\textit{SnapShotFun}) & \snapfun & \in &  \dproc \rightarrow \dsnap &
%(\textit{SleepEventUnit}) & \primevunit{sleep} & \in & Int \times \blocknum \times \dsnap \\
%(\textit{YieldEventUnit}) & \primevunit{yield} & \in & \blocknum \times \dsnap &
%(\textit{PrimEventUnit}) & \primevunit{\threadfunid} & \in & \threadfunid \times \largs \times \dsnap \\
%(\textit{EventUnit}) &  \primevunit{} & \in &
%\multicolumn{5}{l}{
% \{\primevunit{sleep},\ \primevunit{sleep},\  \primevunit{ident},\  \yieldbackunit \} 
% }
% \\
%(\textit{Event}) &  \Sevent & \in & tid \times \primevunit{} &
%(\textit{Log}) &  \SLog & \in & list\ \Sevent \\
%\end{array}
%\]
%\begin{center}
%(2) Event and Log
%\end{center}
%\vspace{-1em}
%
%\[
%\begin{array}{llll llll}
%(\textit{ThreadSet}) & \threadset & \in & \{Z\} &
%(\textit{FullThreadSet}) & \fullthreadset & \in & \threadset \\
%(\textit{InitLog}) & \SLog_{init} & \in & \SLog &
%(\textit{InitNb}) & \blocknum_{init} & \in & \blocknum \\
%(\textit{EnvContext}) & \oracle^{t} & \in & \threadset \rightarrow \varphi^{\threadset} &
%(\textit{Strategy}) & \varphi^{\threadset} & \in & \SLog \rightarrow \Sevent \\
%\end{array}
%\]
%\begin{center}
%(3) Environmental Context
%\end{center}
%\vspace{-1em}
%
%\[
%\begin{array}{llllllll}
%(\textit{Update}) & \updatefun & \in & \dshare \rightarrow \SLog \rightarrow \dshare &
%(\textit{Construct}) & \updatefun_{init} \ l& := & \updatefun\ \dshare_{init} \ l  \ \ \ \ (l \in \SLog) \\
%(\textit{StateCheck}) & \statecheck & \in &
%\multicolumn{5}{l}{
% \threadfunid \rightarrow \largs \rightarrow \dshare \rightarrow \dsnap \rightarrow \mathrm{Prop}
% }
% \\
% (\textit{EventCheck}) & \haseventfun & \in & \threadfunid \rightarrow bool  &
%(\textit{Reg})  &\regs & ::= & \mathsf{EIP} \ | \ \mathsf{EAX} \ | \  \cdots \\
%(\textit{ThreadState}) & \threadstate & \in &
%\multicolumn{5}{l}{
% \{\mathrm{Environment}, \ \mathrm{Available}, \ \mathrm{Running}\ \regs \} 
%  }
%\end{array}
%\]
%\begin{center}
%(4) Auxiliary Definitions for $\EAsmM{}$
%\end{center}
%\vspace{-1em}
%
%\end{small}
%\caption{Additional Definitions for Concurrent Machine Model}
%\label{fig:mach:thread-syntax}
%\vspace{-17pt}
%\end{figure}
%Figure~\ref{fig:mach:thread-syntax} shows multiple definitions for $\EAsmM{}$ in addition to the several 
%shared definitions with our CPU-local layer interface in Fig.~\ref{fig:mach:syntax}, and
%with the given definitions, the machine state of $\EAsmM{}$ is defined as
%\[
%st_{EAsm} = (Z, f_{\threadstate}, m, \SLog, f_{\dproc})
%\] 
%where the first element implies the currently-running thread that performs the evaluation, 
%$f_{\threadstate}$ is a partial map from a thread id to a thread state, 
%$m$ ($loc \rightarrow val$) is a memory, $\SLog$ is a single log that is shared by the whole thread, 
%$f_{\dproc}$ is a partial map from a thread id to a private state.
%
%The first step to facilitate this concurrent machine model is defining semantics with the full thread set on CPU $c$,
%which is notated as $\EAsmM{[c, \fullthreadset]}$ when $\fullthreadset$ is a set of all active threads on CPU $c$.
%At this step, key differences between this machine model and the machine model 
%(Sec.~\ref{subsec:lowlevelasm}) for CPU-local layers are
%1) the machine state contains an explicit set of registers;
%2) the machine state has  information of currently-running thread in it; and 
%3) the machine state has a log explicity rather than only having it in the abstract data. 
%Those concepts works as vital roles when we replace a context switch as a no-op like operation as well as
%when will show the thread isolation property.
%
%For example, the first one is replacing our context switch 
%in CPU-local layers as a no-op like operation in thread-local layers.
%The last one, having an explicit log in the machine itself, gives us 
%a generality of our framework that handle multithreaded concurrency. 
%When modeling this framework and machine models for multithreaded concurrency, 
%we do not need to consider which primitives 
%generate the event during their evaluation.
%In terms of machine model level, 
%we only need to consider a general and abstract method to raise an event and update 
%a shared state using that event.
%Concrete layers, of course, should be instantiated when we want to link those layers together, but 
%this one is an another phase of our thread linking because we want to divide the whole process as 
%a machine model level and a concrete layer refinement level. 
%
%Using those definitions, the evaluation rule for the external call of $\EAsmM{}$ will be defined as:
%\begin{small}
%\begin{mathpar}
%\inferrule{
%\updatefun_{init}(l) = ds \\
%\procid(ds) = curid \\ 
%f_{\threadstate}(curid) = \mathrm{Running}\ \regs\\
%f_{\dproc}(curid) = Some\ d \\ 
%id \neq sleep  \\
%id \neq yield \\ 
%\spec^{_{def}}_{_{id}}: (largs, \regs, m, ds, d) \ni (\textit{res} \cup \{\}, \regs', m', ds', d') \\
%if\ \haseventfun(id)\ then\ l' = (curid, (id, largs, \snapfun(d)))::l  \ else\ l' = l \\
%\updatefun_{init}(l') = ds' \\
%f_{\threadstate}' = f_{\threadstate}[\mathrm{Running}\ \regs'/curid]\\
%f_{\dproc}' = f_{\dproc}[Some\ d'/curid] \\
%%\oracle, c\vdash \sstepr{\spec_{id}}{[largs]}{\regs, m, ds, d}{\textit{res}\cup \{\}}{\regs',  m', ds', d'}
%}{
%\fullthreadset, \oracle^t, c, \oracle\vdash_\codeinmath{EAsm} \sstep{\spec_{id}}{largs}{curid, f_{\threadstate}, m, l, f_{\dproc}}
% {res \cup \{ \}, curid,f_{\threadstate}' , m', l', f_{\dproc}'}
%}
%\end{mathpar}
%\end{small}
%When evaluating external calls, 
%we first construct the current shared data ($ds$) by replaying the log ($l$), 
%and gets the information of the register values and the private abstract data that are mapped with the current 
%running thread id.
%Then, it evaluates the function, and update the state 
%including the log when the external call function generates an event.
%
%Note that the current environmental context is same with that of CPU local layers. 
%Since the lowest level $\EAsmM{[c, \fullthreadset]}$, which is just above the $\AsmLM$ for CPU local layers
%contains the full thread in the state, 
%its environmental context will be identical to the environmental context in 
%the highest CPU local layers.
%Looking at the external call evaluation rule, however, $\EAsmM{[c, \fullthreadset]}$
%filters out the case when the current call is 
%$\yield$ or $\sleep$ calls. 
%Instead of using one common external call evaluation rule, the machine has introduced the 
%specific rule for those scheduling primitives 
%which change the current running thread id in the state.
%\begin{small}
%\begin{mathpar}
%\inferrule{
%\updatefun_{init}(l) = ds \\
%\procid(ds) = curid \\ 
%f_{\threadstate}(curid) = \mathrm{Running}\ \regs\\
%\statecheck(\yield, [],ds,\snapfun(d)) \\ 
%f_{\dproc}(curid) = Some\ d \\ 
%\nextblockfun(m) = nb \\ 
%l' = (curid, (nb, \snapfun(d)))::l \\
%\updatefun_{init}(l') = ds' \\
%\procid(ds') = curid' \\ 
%%\oracle, c\vdash \sstepr{\spec_{id}}{[largs]}{\regs, m, ds, d}{\textit{res}\cup \{\}}{\regs',  m', ds', d'}
%}{
%\fullthreadset, \oracle^t, c, \oracle \vdash_\codeinmath{EAsm} \sstep{\yield}{[]}{curid, f_{\threadstate}, m, l, f_{\dproc}}
% {\{ \}, curid', f_{\threadstate}, m', l', f_{\threadstate}}
%}
%\end{mathpar}
%\end{small}
%In the yield evaluation rule, the machine does not use any user defined specifications at all. 
%Instead of that, the rule contains what $\yield$ should do explicitly. 
%It appends a yield event into the current log, and change the currently-running thread id by evaluating the updated log.
%In addition to that, it memorizes next block information when the thread calls yield to enable thread-local machines to
%find the proper information for its thread-local stack building. 
%The rule also contains the condition that checks the current state. 
%This check guarantees that the current status of the thread (both shared and private data status) are valid to call $\yield$. 
%We can use the whole private data for this status check, but the reason why we use a snapshot is getting a generality in the design. 
%For the simplest case, our snapshot function can be defined as an identity function 
%that gets a private data and returns the exact same private data as a result.
%
%After that, if the new currently-running thread id is available and it is in the set of our available thread set,
%$\EAsmM{}$ needs to resume the evaluation with the newly scheduled thread id. 
%Since we are considering $\EAsmM{[c, \fullthreadset]}$, the next running thread will always be 
%available and $yieldBack$ rule in $\EAsmM{}$ sets correct register values and memory for the thread as follows:
%\begin{small}
%\begin{mathpar}
%\inferrule{
%\updatefun_{init}(l) = ds \\
%\procid(ds) = curid \\ 
%(f_{\threadstate}(curid) = \mathrm{Running}\ \regs) \vee
%(f_{\threadstate}(curid) = \mathrm{Available} \wedge \initregs(curid, l) = Some \ \regs)\\
%f_{\dproc}(curid) = Some\ d \\ 
%last\_event(l) = ev \\
%ev = (\_, (nb, \_)) \vee ev = (\_, (\_, nb, \_))  \\
%\liftnextblock{m}{nb - \nextblock{m}} = m' \\
%l' = (curid, \yieldbackunit)::l\\
%%\oracle, c\vdash \sstepr{\spec_{id}}{[largs]}{\regs, m, ds, d}{\textit{res}\cup \{\}}{\regs',  m', ds', d'}
%}{
%\fullthreadset, \oracle^t, c, \oracle\vdash_\codeinmath{EAsm} \sstep{yieldBack}{[]}{curid, f_{\threadstate}, m, l, f_{\dproc}}
% {\{ \}, curid, f_{\threadstate}[Running\ \regs/curid], m', l', f_{\dproc}}
%}
%\end{mathpar}
%\end{small}
%This rule has two cases. 
%The first case is when the thread is already running, and we just need to use the thread state for the newly scheduled thread as it is.
%However, if the thread is created recently and have never scheduled yet, 
%Our machine checks whether the thread is actually available or not as well as establishes its register values by replaying the current shared log. 
%Our abstract definition, 
%$\begin{small}(\initregs \in Z \rightarrow \SLog \rightarrow \mathrm{option}\ \regs) \end{small}$ 
%is used to check the validity of the thread creation and to build the 
%correct register values (including kernel context values) for the initial move of the thread. 
%In terms of concrete implementation, the machine always choose either the running thread id or the thread id that is ready to run
%because we have already proven the correctness of process creation.
%This $yieldBack$ rule also 
%adjust the memory by using our \textit{algebraic memory model} discussed in Sec.~\ref{sec:multi-threaded-partial}
%to shift the next 
%available block to the proper position for the thread. 
%Note that this lifting will return the identical memory as a result when all threads are available.
%
%
%\para{Building initial state}
%In this stage, all threads in the CPU ($c$) are in the set of our full thread set ($\fullthreadset$), and this implies that all threads will return a valid private data with $f_{\dproc}$.
%However, this private abstract data is purely local, and threads cannot touch 
%others' local values, even if other threads are its children.
%This implies that each thread has its own responsibility to build its initial state. 
%To handle this initial state building, we introduce an abstract definition,
%${\small  \initdproc \in Z \rightarrow \mathrm{option}\ \dproc }$,
% that gets a thread id and an initial shared log 
%for the thread and returns proper initial values by searching the information inside its initial shared log. 
%Definitely, this initial shared log should contain sufficient information to build an initial private state for each thread.
%However, like other definitions in our $\EAsmM{}$ machine model, 
%we do not have to concretely define this abstract definition at all
%at this step. 
%We leave them as an abstract one in our language level for us to design a general multithreaded machine model as much as possible.
%Then, an initial abstract state ($f_\dproc$) of $\EAsmM{[c, \fullthreadset]}$ will be defined as 
%\begin{small}
%\[
%\mathsf{map}\ (\mathsf{fun}\ i \Rightarrow (\mathsf{Some}\ \initdproc(i))) \ \fullthreadset
%\]
%\end{small}
%, and we show the correctness of this mechanism while proving refinement theorems, 
%both in the language level refinement 
%and the concrete layer refinement.
%Finally, with the whole thread set on CPU $c$, we are able to show the refinement theorem between two different machine models.
%\begin{theorem}[$\EAsmM{}$ refines $\AsmLM$]
%\label{theorem:easm_refine_lasm}
%\begin{small}
%Assume that the simulation relation between $\AsmLM$ and $\EAsmM{}$ is $\simrel(st_{\EAsmM{}}, st_{\AsmLM})$.
%In addition, suppose that there exists a layer definition, $\mathrm{PH}$, that satisfies an abstract relation, $\absrel(\simrel(st_{\EAsmM{}}, st_{\AsmLM}), \mathrm{PH}, \CSched)$. Then,
%$$\ltyp{(c, \oracle\vdash_{\AsmLM} L_\codeinmath{bthread})}{\absrel(\simrel(st_{\EAsmM{}}, st_{\AsmLM}), \mathrm{PH}, \CSched)}
%{\varnothing}{(\fullthreadset, \oracle^t,  c, \oracle  \vdash_{\EAsmM{}} \mathrm{PH})}$$
%\end{small}
%\end{theorem}
%
% $\proofcase{initial\_state}$ We show that there exists a valid initial state of $\AsmLM$ which satisfies the simulation relation
%$\simrel$ with the initial machine state of $\EAsmM{}$, which is stated as follows:
%$$\simrel(init\_st_{\EAsmM{}}, init\_st_{\AsmLM})$$
%This proof is based on the induction on our full thread set, $\fullthreadset$. 
%The base case is trivial because a thread set in this case is an empty set.
%For the inductive case, our proof relies on the abstract relation, $\absrel(\simrel(st_{\EAsmM{}}, st_{\AsmLM}), \mathrm{PH}, \CSched)$, which states the fact that
% all thread in the set also satisfies the simulation relation. 
%This is because we do not have concrete data type definitions, a concrete layer definition, and other concrete definitions yet. 
%Showing the fact that our concrete implementation satisfies  $\absrel(\simrel(st_{\EAsmM{}}, st_{\AsmLM}), \mathrm{PH}, \CSched)$ can be done when we introduce actual implementations for all abstract definitions.
%
%$\proofcase{one\_step\_refinement}$
%Next step is showing the fact that when $\simrel(st_{\EAsmM{}}, st_{\AsmLM})$ and when we have one step evaluation on $\EAsmM{}$, which is $\fullthreadset, \oracle^t, c, \oracle  \vdash_{\EAsmM{}} st_{\EAsmM{}} \ni st'_{\EAsmM{}} $, 
%then there exists a $st'_{\AsmLM}$ that satisfies 
%$$c, \oracle, \vdash_{\AsmLM{}} st_{\AsmLM} \ni st'_{\AsmLM} \wedge \simrel(st'_{\EAsmM{}}, st'_{\AsmLM})$$
%or when the current evaluation of $\EAsmM{}$ is either $\yield$ or $\sleep$ case, 
%$$\vert st_{\EAsmM{}} \vert > \vert st'_{\EAsmM{}} \vert \wedge \simrel(st'_{\EAsmM{}}, st_{\AsmLM})$$
%when $\vert st_{\EAsmM{}} \vert$ is defined as $1$ if the type of the last event in the shared log of $st_{\EAsmM{}}$ 
%is neither $\primevunit{\yield}$ nor $\primevunit{\sleep}$ and $0$ otherwise.
%
%Proving this property requires case analysis on $\EAsmM{}$ evaluation rules, and it  
%also heavily relies on the abstract definition,  $\absrel(\simrel(st_{\EAsmM{}}, st_{\AsmLM}), \mathrm{PH}, \CSched)$.
%For most cases except $\yield$ and $\sleep$, one step in $\EAsmM{}$ with $\fullthreadset$ 
%is exactly matched with one step in $\AsmLM$, and we can show the existence of $st'_{\AsmLM}$ that satisfies 
%$c, \oracle\vdash_{\AsmLM{}} st_{\AsmLM} \ni st'_{\AsmLM} \wedge \simrel(st'_{\EAsmM{}}, st'_{\AsmLM})$.
%
%In the $\yield$ case, we delay the evaluation of $\AsmLM$ because there is no evaluation rule in $\AsmLM$
%which is exactly matched with this $\yield$ evaluation rule in $\EAsmM{}$. 
%This is because we define the context switching behavior 
%as two steps in our multithreaded concurrent machine model.
%Therefore, instead of providing the next state of $\AsmLM$ and showing the existence of corresponding 
%evaluation in $\AsmLM$, 
%we show that this 
%case satisfies $\vert st_{\EAsmM{}} \vert > \vert st'_{\EAsmM{}} \vert \wedge \simrel(st'_{\EAsmM{}}, st_{\AsmLM})$, 
%which delays the evaluation in $\AsmLM$. 
%Similar to the $\yield$ case, we show that the $\sleep$ case also 
%satisfies $\vert st_{\EAsmM{}} \vert > \vert st'_{\EAsmM{}} \vert \wedge \simrel(st'_{\EAsmM{}}, st_{\AsmLM})$.
%
%In the $yieldBack$ case, the rule guarantees that the previous evaluation rule in $\EAsmM{}$ was either $\yield$ or $\sleep$ 
%by its condition (\textit{\ie} $last\_event(l) = ev \wedge (ev = (\_, (nb, \_)) \vee ev = (\_, (\_, nb, \_)))$).
%If the previous evaluation rule was the $\yield$ evaluation rule,
%then the $yieldBack$ evaluation combined with the previous $\yield$ evaluation in $\EAsmM{}$
%will be matched with the $\yield$ primitive evaluation in $\AsmLM$. 
%Therefore, we can provide a valid next state of $\AsmLM$, which satisfies the simulation relation with the next state of 
%$\EAsmM{}$. If the previous evaluation on $\EAsmM{}$ was $\sleep$, then the proof will be quite similar.

%%%% PARTIAL EASM %%%%%%%%
%\subsection{Partial Multithreaded Machine Model and Linking}\label{subsec:singleeasm}
%
%The next step in defining thread-local layer interface
%is replacing other threads' evaluation using the strategy as we have already seen in Fig.~\ref{fig:chapter:conlink:threadlinking}. 
%In this step, our machine does not guarantee that the scheduled thread id is always a member 
%unning or available threads because the machine is not a total machine on CPU $c$. 
%If the thread is not in both cases, we categorize it as a thread with an $\mathrm{Environment}$ state.
%To handle the case,
%$\EAsmM{}$ has a $\mathrm{Environment}$ rule
%\begin{small}
%\begin{mathpar}
%\inferrule{
%\updatefun_{init}(l) = ds \\
%\procid(ds) = curid \\ 
%f_{\threadstate}(curid) = \mathrm{Environment} \\
%f_{\dproc}(curid) = None \\ 
%\oracle^{t}(T_a) = \varphi^{T_a}\\
%\varphi^{T_a}(l) = ev\\
%l' = ev::l\\
%\updatefun_{init}(l') = ds' \\
%\procid(ds') = curid' \\ 
%}{
%\threadset_a, \oracle^t, c, \oracle\vdash_\codeinmath{EAsm} \sstep{\empty}{[]}{curid, f_{\threadstate}, m, l, f_{\dproc}}
% {\{ \}, curid', f_{\threadstate}, m, l', f_{\threadstate}}
%}
%\end{mathpar}
%\end{small}
%, when $\threadset_a$ is a set of thread that is currently available. 
%With a partial thread set, if the current thread $curid$ is in a set of $\fullthreadset - \threadset_a$ 
%(\textit{\ie} $curid \in (\fullthreadset - \threadset_a)$),
%we query our strategy using the current log and append the event that are performed by other threads to the current log.
%For example, if the current full thread set is $\fullthreadset$ is $\{0, \ 1 \}$,
%and we define a partial machine that only has $\{0\}$ as a currently available thread set, 
%the environmental context for thread-local machine will be parameterized by $\{0\}$.
%After that, the machine becomes a single threaded machine model, 
%which contains $\{0\}$ as an only available or a running thread in the set.  
%Even for the case with more than 2 threads, applying this step iteratively until the currently available thread set $\threadset_a$ become a singleton set is a key idea of our framework to build a thread-local machine. 
%
%\para{Thread Linking}
%To link multiple thread-local machines as one multithreaded concurrent machine,  
%we perform the above iteration of building a single-threaded concurrent machine model in a reversed way.
%Let us first focus on two single-threaded concurrent machine models, 
%$\EAsmM{[c, \{0\}]}$ and $\EAsmM{[c, \{1\}]}$.
%Then, partial maps for thread private data ($f_\dproc$) of $\EAsmM{[c, \{0\}]}$ 
%and of $\EAsmM{[c, \{1\}]}$ will be defined as\newline
%\noindent
%\begin{minipage}[t]{.5\textwidth}
%\begin{small}
%\[
%f_{\dproc}(i):=
%\begin{cases}
% \codeinmath{Some \ d} & \codeinmath{when} \ i = 0\\
%\codeinmath{None} & \text{otherwise}
%\end{cases}
%\]
%\end{small}
%\end{minipage}
%\begin{minipage}[t]{.5\textwidth}
%\begin{small}
%\[
%f_{\dproc}(i):=
%\begin{cases}
% \codeinmath{Some \ d} & \codeinmath{when} \ i = 1\\
%\codeinmath{None} & \text{otherwise}
%\end{cases}
%\]
%\end{small}
%\end{minipage}
%respectively.
%Then, merging those two partial maps will be 
%\begin{small}
%\[
%f_{\dproc}(i):=
%\begin{cases}
% \codeinmath{Some \ d} & \codeinmath{when} \ i = 0 \vee i = 1\\
%\codeinmath{None} & \text{otherwise}
%\end{cases}
%\]
%\end{small}
%, which simply merge two maps together. 
%For the partial map of the private register set, we can do the similar merging.
%In terms of environmental context, both machines have the same environmental context, which is 
%$\oracle^{t}$ even though they have different strategies from each other ($\oracle^{t}(\{0\})$ and $\oracle^{t}(\{1\})$).
%With those environmental contexts, 
%building $\oracle^{t}(\{0, 1\})$ is straightforward. 
%We need to either  exclude the event generated by thread 1 from $\oracle^{t}(\{0\})$ or 
%exclude the event generated by thread 0 from $\oracle^{t}(\{1\})$.
%Then, having those two single-threaded local machines, we can merge their private states, registers, and a environmental context, 
%and thus build a two-threaded concurrent machine model, $\EAsmM{[c, \{0, 1\}]}$.
%If $\fullthreadset = \{0, 1\}$, then we do not need further merging, 
%and the machine directly turns into a total concurrent machine 
%model $\EAsmM{[c, \fullthreadset]}$. 
%If not, we pick one thread $i$ (\textit{\ie} $i \in (\fullthreadset - \{0, 1\})$), 
%and merge the thread again with the exactly 
%same process that we have done for thread $0$ and thread $1$.
%Generalizing this method makes our framework link two multithreaded machine models 
%when two machines contain disjoint thread sets as their available (or running) thread sets.
%When we define the operator for the above merging process as $\join$, which performs the above 
%process for merging,
%we can show when $\EAsmM{[c, \threadset_{left}]}$ and $\EAsmM{[c, \threadset_{right}]}$,
%there always exists a valid composed concurrent machine.
%\begin{small}
%\[
%\EAsmM{[c, \threadset_{left} \cup \threadset_{right}]} = \EAsmM{[c, \threadset_{left}]}\ \join\ \EAsmM{[c, \threadset_{right}]}
% \]
% \end{small}
%when $\threadset_{\mathrm{left}}$ and $\threadset_{\mathrm{right}}$ are disjoint with each other.
%We have also proved the refinement for this linking too.
%
%\begin{lemma}
%\begin{small}
%$$\ltyp{(\{\mathrm{left}, \mathrm{right}\}, \oracle^t, c, \oracle  \vdash_{\EAsmM{}} \mathrm{PH})}{}{\varnothing}
%{(\{\mathrm{left}\}, \oracle^t, c, \oracle \vdash_{\EAsmM{}} \mathrm{PH}
% \join \{\mathrm{right}\}, \oracle^t, c, \oracle  \vdash_{\EAsmM{}} \mathrm{PH})}
%$$
%\end{small}
%\label{lemma:thread-single-compose}
%\end{lemma}%
%This lemma requires a lot of auxiliary lemmas and definitions.
%Honestly, the proof is one of the most complex one among our whole proofs.
%However, the basic idea is simple and really intuitive.
%
%
%$\proofcase{initial\_state}$ 
%Initial states of both machines in the right-hand side of the lemma, 
%which are $\EAsmM{[c, \mathrm{\{left\}}]}$ and $\EAsmM{[c, \mathrm{\{right\}}]}$
%will have the same shared log ($nil$) and the memory (the clean state). 
%Therefore, we can easily  get those fields in the initial state 
%of the left hand side machine, $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%For private abstract data and thread state pools of $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$, 
%we apply our join operation on initial states of $\EAsmM{[c, \mathrm{\{left\}}]}$ and $\EAsmM{[c, \mathrm{\{right\}}]}$. 
%By doing that, we can successfully construct an initial state of $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%
%$\proofcase{one\_step\_refinement}$
%Assuming that either $\EAsmM{[c, \mathrm{\{left\}}]}$ or  $\EAsmM{[c, \mathrm{\{right\}}]}$  performs one step
%evaluation. 
%And, the other one of them performs more than zero step evaluation. 
%For the simplicity in this proof, we assume that $\EAsmM{[c, \mathrm{\{left\}}]}$ do one step evaluation and $\EAsmM{[c, \mathrm{\{right\}}]}$ do  star step (more than zero step) evaluations.
%In this case, we can find at least more than one step evaluation on $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$
%that can be matched with both evaluations on the right-hand side. 
%Intuitively, this is simply replacing some environment steps in either $\EAsmM{[c, \mathrm{\{left\}}]}$ or $\EAsmM{[c, \mathrm{\{right\}}]}$ into other evaluation steps 
%(\textit{\ie} external, primitive, $\yield$, $\sleep$, and $yieldBack$ steps) in $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%To prove this one, we need to do case analysis on the single step evaluation rules in $\EAsmM{[c, \mathrm{\{left\}}]}$.
%All cases except the one, an environmental step, we can directly find out the matched state and one step evaluation in
%$\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ because the current running thread is ``$\mathrm{left}$''. 
%In the environmental step, $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ either performs one environmental step or 
%replaces the step into other evaluation rules (possibly multiple steps) that are performed by ``$\mathrm{right}$'' 
%by additional case analysis on the event generated by the environmental step.
%When the event generated by environmental step is not by $\mathrm{right}$, 
%then $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ will also do the single environmental step. 
%However, if the event in the environmental step is raised by $\mathrm{right}$, we will replace the environmental step 
%with star step evaluations on $\EAsmM{[c, \mathrm{\{right\}}]}$.
%This star step may contain multiple silent steps that only affects the private data of $\mathrm{right}$.
%In this case, we can update the corresponding private data in $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ by apply the 
%same star steps in $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%Therefore, we are always able to provide the matched state and evaluation rules for $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%
%\ignore{
%\noindent This theorem guarantees that,
%once the multithreaded machine $\TAsm$ consists of
%the whole thread set,
% the properties of  threads running on top
%can be propagated down to the layer that has concrete
%scheduling implementations.
%}
%By generalizing this lemma, we can prove the general linking theorem. 
%\begin{theorem}[Multithreaded Machine Model Linking]
%\begin{small}
%$$\ltyp{(\fullthreadset, \oracle^t, c, \oracle  \vdash_{\EAsmM{}} \mathrm{PH})}{}
%{\varnothing}{\join_{tid \in T_{\mathrm{full}}} ( \{tid\}, \oracle^t, c, \oracle\vdash_{\EAsmM{}} \mathrm{PH})}$$
%\end{small}
%\label{theorem:thread-full-compose}
%\end{theorem}
%
%Proving this theorem is generalization of the previous Lemma (Lemma~\ref{lemma:thread-single-compose}). 
%One limitation in our merging operator is one of two partial $\EAsmM{}$ machines that we want to merge should have a singleton set as its available thread set. 
%By restricting this aspect, we can 
%prove this theorem by doing case analysis on the evaluation rules with singleton $\EAsmM{}$.
%The proof is quite similar to the proof for Lemma~\ref{lemma:thread-single-compose}.
%
%
%\ignore{One more additional theorem that we can easily achieve with this approach is also important for us to build out thread-local layer interface.
%
%\begin{theorem}[Single Threaded $\EAsmM{}$ Refines Full Threaded $\EAsmM{}$]
%\begin{small}
%$$\forall\ tid,\ tid\ \in\ \fullthreadset,\ (\ltyp{ \fullthreadset, \oracle^{t}, c, \oracle \vdash_{\EAsmM{}} \mathrm{PH})}{}
%{\varnothing}{(\{tid\}, \oracle^{t}, c, \oracle \vdash_{\EAsmM{}} \mathrm{PH})})$$
%\end{small}
%\label{theorem:full-easm-refines-single-easm}
%\end{theorem}}
%
%\ignore{
%$\proofcase{initial\_state}$ 
%The initial shared log and the initial memory will be same in both side. 
%And,  the private data pool of $\EAsmM{[c, \fullthreadset]}$ will contain the proper initial private data 
%for 
%
%$\proofcase{one\_step\_refinement}$
%Assuming that either $\EAsmM{[c, \mathrm{\{left\}}]}$ or  $\EAsmM{[c, \mathrm{\{right\}}]}$  performs one step
%evaluation. 
%And, the other one of them performs more than zero step evaluation. 
%For the simplicity in this proof, we assume that $\EAsmM{[c, \mathrm{\{left\}}]}$ do the one step evaluation and $\EAsmM{[c, \mathrm{\{right\}}]}$ do the star step (more than zero step) evaluation.
%In this case, we can find at least more than one step evaluation on $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$
%that can be matched with both evaluations on the right-hand side. 
%Intuitively, this is simply replacing some environmental steps in either $\EAsmM{[c, \mathrm{\{left\}}]}$ or $\EAsmM{[c, \mathrm{\{right\}}]}$ with other evaluation steps 
%(\textit{\ie} external, primitive, $\yield$, $\sleep$, and $yieldBack$ steps) in $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%To prove this one, we need to do the case analysis on the single step evaluation in $\EAsmM{[c, \mathrm{\{left\}}]}$.
%All cases except the one, an environmental step, we can directly find out the matched state and one step evaluation in
%$\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ because the current running thread is ``$\mathrm{left}$''. 
%In the environmental step, $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ either performs one environmental step or 
%replaces the step with other evaluation rules (possibly multiple steps) that are performed by ``$\mathrm{right}$'' 
%by an additional case analysis on the event generated by the environmental step.
%When the event generated by environmental step is not by $\mathrm{right}$, 
%then $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ will also do the single environmental step. 
%However, if the event in the environmental step is by $\mathrm{right}$, we will replace the environmental step 
%with star step evaluations on $\EAsmM{[c, \mathrm{\{right\}}]}$.
%This star step may contain multiple silent steps that only affects the private data of $\EAsmM{[c, \mathrm{\{right\}}]}$.
%In this case, we can update the corresponding private data in $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$ by apply the 
%same star steps in $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%Therefore, we are always able to provide the matched state and evaluation rules for $\EAsmM{[c, \mathrm{\{left, rihgt\}}]}$.
%}


\section{Single Thread EAsm refines Full Thread EAsm}

\subsubsection{IIEAsm}
\begin{lstlisting}[language=Caml]
  (* fst mem : mine / snd mem : others *)
  Inductive iestate: Type :=
    | IEState: Z -> ZMap.t ThreadState -> (mem * mem) -> EData -> Log -> iestate.
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Inductive iestep (ge: genv) : iestate -> trace -> iestate -> Prop :=
\end{lstlisting}


\begin{lstlisting}[language=Caml]
    | ieexec_step_internal:
        forall b ofs f i (rs: regset) mset mset' m m' dp d d' ds' rs' curid rsm l
               (MOrigin: if (decide (curid = current_thread)) then m = fst mset else m = snd mset),
          ZMap.get curid rsm = Running rs ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b ofs ->
          Genv.find_funct_ptr ge b = Some (Internal f) ->
          find_instr (Int.unsigned ofs) f.(fn_code) = Some i ->
          lastEvType l <> Some LogYieldTy ->
          exec_instr ge f i rs (m, (uRData l,d)) = Next rs' (m', (ds',d')) ->
          forall (MUpdate: if (decide (curid = current_thread)) then mset' = (m', snd mset)
                           else mset' = (fst mset, m'))
                 (Hget_dp: ZMap.get curid dp = Some d),
            iestep ge (IEState curid rsm mset dp l) E0
                   (IEState curid (ZMap.set curid (Running rs') rsm) mset' 
                            (ZMap.set curid (Some d') dp) l)
\end{lstlisting}


\begin{lstlisting}[language=Caml]
                          
  | ieexec_step_external:
      forall b ef args res (rs: regset) mset mset' m m' dp d d' ds' t rs' curid rsm l l'
             (MOrigin: if (decide (curid = current_thread)) then m = fst mset else m = snd mset),
        ZMap.get curid rsm = Running rs ->
        proc_id (uRData l) = curid ->
        rs PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        extcall_arguments rs m (ef_sig ef) args ->
        lastEvType l <> Some LogYieldTy ->
        external_call' (mem:= mwd (cdata PData)) (fun _ => True) ef ge args (m, (uRData l, d)) t res (m', (ds',d')) ->
        rs' = (set_regs (loc_external_result (ef_sig ef)) res 
                        (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                                    (undef_regs (map preg_of destroyed_at_call) rs))) 
                #PC <- (rs RA) #RA <- Vundef ->
        forall NON_YIELD: 
                 match ef with
                 | EF_external id _ => 
                   if peq id thread_yield then False
                   else if peq id thread_sleep then False
                        else
                          if has_event id then
                            exists largs choice,
                              val2Lval_list args largs  /\
                              choice_check id largs (uRData l) d = choice /\ 
                              l' = (LEvent curid (LogPrim id largs choice (snap_func d)) :: l) 
                          else
                            l' = l
                 | _ => l' = l
                 end,
                 forall STACK:
                 forall b o, rs ESP = Vptr b o ->
                             (Ple (Genv.genv_next ge) b /\ Plt b (Mem.nextblock m)),
                 forall SP_NOT_VUNDEF: rs ESP <> Vundef,
                 forall RA_NOT_VUNDEF: rs RA <> Vundef,
                 forall (Hget_dp: ZMap.get curid dp = Some d),
                 forall (MUpdate: if (decide (curid = current_thread)) then mset' = (m', snd mset)
                                  else mset' = (fst mset, m')),
                   iestep ge (IEState curid rsm mset dp l) t 
                          (IEState curid (ZMap.set curid (Running rs') rsm) 
                                   mset' (ZMap.set curid (Some d') dp) l')

\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | ieexec_step_prim_call:
        forall b ef (rs: regset) mset mset' m m' dp d d' ds' t rs' curid rsm l l'
               (MOrigin: if (decide (curid = current_thread)) then m = fst mset else m = snd mset),
          ZMap.get curid rsm = Running rs ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          lastEvType l <> Some LogYieldTy ->
          primitive_call (mem:= mwd (cdata PData)) ef ge rs (m, (uRData l, d)) t rs' (m', (ds', d')) ->
          forall NON_YIELD: 
                   match ef with
                   | EF_external id _ => 
                     if peq id thread_yield then False
                     else if peq id thread_sleep then False
                          else
                            if has_event id then
                              l' = (LEvent curid (LogPrim id nil 0 (snap_func d)) :: l)
                            else
                              l' = l
                   | _ => l' = l
                   end,
                   forall (Hget_dp: ZMap.get curid dp = Some d),
                   forall (MUpdate: if (decide (curid = current_thread)) then mset' = (m', snd mset)
                                    else mset' = (fst mset, m')),
                     iestep ge (IEState curid rsm mset dp l) t 
                            (IEState curid (ZMap.set curid (Running rs') rsm) mset' 
                                     (ZMap.set curid (Some d') dp) l')
                            
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | ieexec_step_external_yield:
        forall b ef (rs: regset) (mset : (mem * mem)) (m: mem) curid curid' rsm s l l' dp d
               (MOrigin: if (decide (curid = current_thread)) then m = fst mset else m = snd mset),
          ZMap.get curid rsm = Running rs ->
          ZMap.get curid dp = Some d ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          stencil_matches s ge ->
          l' = (LEvent curid (LogYield (Mem.nextblock m))::l) ->
          lastEvType l <> Some LogYieldTy ->
          (* event_check (LEvent curid (LogYield (Mem.nextblock m))) -> *)
          state_checks thread_yield nil l dp ->
          curid' = proc_id (uRData l') ->
          forall (NON_YIELD: match ef with
                               | EF_external id _ => 
                                 if peq id thread_yield then True
                                 else False
                               | _ => False
                             end),
            iestep ge (IEState curid rsm mset dp l) E0
                  (IEState curid' rsm mset dp l')

\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | ieexec_step_external_sleep:
        forall b ef (rs: regset) (mset : (mem * mem)) (m: mem) curid curid' rsm s l l' dp d i
               (MOrigin: if (decide (curid = current_thread)) then m = fst mset else m = snd mset),
          ZMap.get curid rsm = Running rs ->
          ZMap.get curid dp = Some d ->
          proc_id (uRData l) = curid ->
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          stencil_matches s ge ->
          l' = (LEvent curid (LogSleep (Int.unsigned i) (Mem.nextblock m)
                                       (sync_chpool_check thread_sleep ((Lint i)::nil) (uRData l) d))::l) ->
          lastEvType l <> Some LogYieldTy ->
          state_checks thread_sleep (Lint i::nil) l dp ->
          curid' = proc_id (uRData l') ->
          forall
            (Hargs: extcall_arguments rs m (mksignature (Tint:: nil) None cc_default) (Vint i:: nil))
            (NON_YIELD: match ef with
                               | EF_external id _ => 
                                 if peq id thread_sleep then True
                                 else False
                               | _ => False
                             end),
            iestep ge (IEState curid rsm mset dp l) E0
                  (IEState curid' rsm mset dp l')
\end{lstlisting}

\begin{lstlisting}[language=Caml]

    | ieexec_step_external_empty:
        forall (mset:  (mem * mem)) curid curid' rsm dp l l',
          ZMap.get curid rsm = Environment ->
          ZMap.get curid dp = None ->
          proc_id (uRData l) = curid ->
          l' = (Single_Oracle l::l) ->
          curid' = proc_id (uRData l') ->
          iestep ge (IEState curid rsm mset dp l) E0
                (IEState curid' rsm mset dp l')
\end{lstlisting}


\begin{lstlisting}[language=Caml]
    | ieexec_step_external_yield_back:
        forall (rs' rs0: regset) (mset mset' : (mem * mem)) (m m': mem) curid rsm l l' nb dp d e
               (MOrigin: if (decide (curid = current_thread)) then m = fst mset else m = snd mset),
          (ZMap.get curid rsm = Available /\ initial_thread_kctxt ge curid l = Some rs0) \/
          ZMap.get curid rsm = Running rs0 ->
          ZMap.get curid dp = Some d ->
          proc_id (uRData l) = curid ->
          last_op l = Some e ->
          l' = (LEvent curid LogYieldBack::l) ->
          rs' = (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                            (undef_regs (map preg_of destroyed_at_call) rs0)) 
                  # EAX <- Vundef #PC <- (rs0 RA) #RA <- Vundef ->
          forall
            (Hnextblock: getLogEventNB (e) = Some nb)
            (LIFT_NEXTBLOCK: mem_lift_nextblock m (Pos.to_nat (nb) - Pos.to_nat (Mem.nextblock m) % nat) = m')
            (MUpdate: if (decide (curid = current_thread)) then mset' = (m', snd mset) 
                      else mset' = (fst mset, m')),
            iestep ge (IEState curid rsm mset dp l) E0
                   (IEState curid (ZMap.set curid (Running rs') rsm) mset' dp l').

\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Inductive ieinitial_state {F V} (p: AST.program F V): iestate -> Prop :=
  | ieinitial_state_intro: 
      forall m0,
        Genv.init_mem p = Some m0 ->
        let rsm := initial_map Environment (init_regset (Genv.globalenv p)) active_threads in
        let dm := initial_map None (fun i => Some (thread_init_dproc i)) active_threads in
        let dmem := (m0, m0) in
        ieinitial_state p (IEState main_thread rsm dmem dm nil).
\end{lstlisting}

\subsubsection{Refinement between IIEAsm and EAsm}
\begin{lstlisting}[language=Caml]
  Definition yield_condition (tid: Z) (l: Log):=
    (exists a l', l = a :: l'
                  /\ proc_id (uRData l') = tid
                  /\ getLogEventType a = LogYieldTy).

  Definition active_condition (tid: Z) (l: Log):=
    (proc_id (uRData l) = tid /\ lastEvType l <> Some LogYieldTy)
    \/ yield_condition tid l.

  Definition inyield_condition (l: Log) rsm :=
    (exists a l', l = a :: l' 
                  /\ ZMap.get (proc_id (uRData l')) rsm <> Environment
                  /\ getLogEventType a = LogYieldTy).

  Definition inactive_condition (l: Log) rsm :=
    (ZMap.get (proc_id (uRData l)) rsm <> Environment /\
     lastEvType l <> Some LogYieldTy)
    \/ inyield_condition l rsm.
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Definition mem_block_conditions (mp_h: (mem * mem)) (m_l : mem) (l : Log) : Prop :=
    (mem_disjoint_union (fst mp_h) (snd mp_h) m_l) /\
    (active_condition current_thread l -> 
        (Mem.nextblock (snd mp_h) <= Mem.nextblock (fst mp_h)) % positive) /\
    (forall i, i <> current_thread -> active_condition i l -> 
               (Mem.nextblock (fst mp_h) <= Mem.nextblock (snd mp_h)) % positive) /\
    (forall i, yield_condition i l -> Mem.nextblock m_l = last_nb l).
  
  Definition total_machine_regset (i : Z) rsm :=
    exists rs, ZMap.get i rsm = Running rs \/ ZMap.get i rsm = Available.

  Inductive match_iestate_estate (ge : genv) : (iestate (mem := mem)) -> 
                                 (estate (mem := mem))  -> Prop :=  
  | MATCH_IESTATE_ESTATE:
      forall curid rsm_h rsm_l (dp_h dp_l : ZMap.t (option dproc)) (mp_h: (mem * mem)) m_l l
             // current thread id 
             (HCurID : proc_id (uRData l) = curid)

             // for registers 
             (HRsmDom3 : forall i, In i full_thread_list -> total_machine_regset i rsm_h)
             (HRsmDom3 : forall i, In i full_thread_list -> total_machine_regset i rsm_l)
             
             (HRsmRel: forall i, In i full_thread_list ->
                                 ts_lessdef (ZMap.get i rsm_h) (ZMap.get i rsm_l))
             
             // for private data 
             (HDprocDom3: forall i, In i full_thread_list -> ZMap.get i dp_h <> None)
             (HDprocDom3: forall i, In i full_thread_list -> ZMap.get i dp_l <> None)
             (HDprocRel: forall i, In i full_thread_list -> ZMap.get i dp_h = ZMap.get i dp_l)

             // for memory existence 
             (HMemRel: mem_block_conditions mp_h m_l l),
        
        match_iestate_estate ge (IEState curid rsm_h mp_h dp_h l) (EState curid rsm_l m_l dp_l l).
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Theorem one_step_Asm_E2E:
    forall ge curid curid'  mp_h mp_h' m_l rsm_h rsm_l rsm_h' l l' (dp_h dp_l dp_h' : ZMap.t (option dproc)) t
           (HEStep: IIEAsm.iestep ge (IEState curid rsm_h mp_h dp_h l) t (IEState curid' rsm_h' mp_h' dp_h' l'))
           (HMatch: match_iestate_estate ge (IEState curid rsm_h mp_h dp_h l) (EState curid rsm_l m_l dp_l l)),
    exists rsm_l' m_l' dp_l',
      (plus EAsm.estep) ge (EState curid rsm_l m_l dp_l l) t (EState curid' rsm_l' m_l' dp_l' l')
      /\ match_iestate_estate ge (IEState curid' rsm_h' mp_h' dp_h' l') (EState curid' rsm_l' m_l' dp_l' l').
\end{lstlisting}

\subsubsection{IIEAM refines IIEAsm}

\begin{lstlisting}[language=Caml]
  Definition total_machine_regset (i : Z) rsm :=
    exists rs, ZMap.get i rsm = Running rs \/ ZMap.get i rsm = Available.  
\end{lstlisting}


\begin{lstlisting}[language=Caml]

  Inductive match_iestate_state (ge : genv) : (iestate (mem := mem)) -> 
                                              (iestate (mem := mem)) -> Prop :=  
  | MATCH_IESTATE_STATE:
      forall curid rsm_h rsm_l (dp_h dp_l : ZMap.t (option dproc)) mp_h mp_l l
             // current thread id
             (HCurID : proc_id (uRData l) = curid)

             // for registers 
             (HRsmDom1: forall i, In i full_thread_list -> i <> current_thread ->
                                  ZMap.get i rsm_h = Environment)
             (HRsmDom2: ZMap.get current_thread rsm_h <> Environment)
             (HRsmDom3 : forall i, In i full_thread_list -> total_machine_regset i rsm_l)
             
             (HRsmRel: (ZMap.get current_thread rsm_h) = (ZMap.get current_thread rsm_l))
             
             // for private data 
             (HDprocDom1: forall i, In i full_thread_list -> i <> current_thread ->
                                    ZMap.get i dp_h = None)
             (HDprocDom2: ZMap.get current_thread dp_h <> None)
             (HDprocDom3: forall i, In i full_thread_list -> ZMap.get i dp_l <> None)
             (HDprocRel: ZMap.get current_thread dp_h = ZMap.get current_thread dp_l)

             // for memory 
             (HMemRel: fst mp_h = fst mp_l),
        match_iestate_state ge (IEState curid rsm_h mp_h dp_h l) (IEState curid rsm_l mp_l dp_l l).

  Class IE2IERel :=
    {

      // liveness constraint for other threads. Other threads should gaurantee this property -
      // within finite time, they should generate one event 
      env_step_match:
        forall (ge: genv) (mp_h mp_l: (mem * mem)) (curid curid': Z)
               (rsm_h rsm_l : ZMap.t EAsmCommon.ThreadState) dp_h dp_l (l l' : Log)
               (Hrsm: ZMap.get curid rsm_h = Environment)
               (Hdproc: ZMap.get curid dp_h = None)
               (Hcurid1: proc_id (uRData l) = curid)
               (Hquery: l' = (Single_Oracle l)::l)
               (Hcurid2: proc_id (uRData l') = curid')
               (HMatch: match_iestate_state ge (IEState curid rsm_h mp_h dp_h l) 
                                            (IEState curid rsm_l mp_l dp_l l)),
        exists rsm_l' mp_l' dp_l' t,
          (star IIEAsm.iestep) ge (IEState curid rsm_l mp_l dp_l l) t (IEState curid' rsm_l' mp_l' dp_l' l');


      // for function call in Context. To make our framework work, Context on our layers should not 
      //  use some functions (vload, vstore, annot) 
      function_call_cond:
        forall ef, match ef with
              | EF_vload _ => False
              | EF_vstore _ => False
              | EF_vload_global _ _ _ => False
              | EF_vstore_global _ _ _ => False
              | EF_annot _ _ => False
              | EF_annot_val _ _ => False
              | _ => True
              end
    }.
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Theorem one_step_Asm_E2E:
    forall ge curid curid' mp_h mp_h' mp_l rsm_h rsm_l rsm_h' l l' (dp_h dp_l dp_h' : ZMap.t (option dproc)) t
      (HEStep: IIEAsm.iestep ge (IEState curid rsm_h mp_h dp_h l) t (IEState curid' rsm_h' mp_h' dp_h' l'))
      (HMatch: match_iestate_state ge (IEState curid rsm_h mp_h dp_h l) (IEState curid rsm_l mp_l dp_l l)),
    exists rsm_l' mp_l' dp_l',
      (plus IIEAsm.iestep) ge (IEState curid rsm_l mp_l dp_l l) t (IEState curid' rsm_l' mp_l' dp_l' l')
      /\ match_iestate_state ge (IEState curid' rsm_h' mp_h' dp_h' l') (IEState curid' rsm_l' mp_l' dp_l' l').
\end{lstlisting}

\section{Single-threaded Machine Model}
\label{chapter:linking:subsec:single-threaded-machine-model}
When the focused thread set in $\easm$ is a single thread, then the machien itself is 
already a single threaded machine model. 
It, however, has a huge differences between the model that we want to introduce ($\compcertx$ like model).

\begin{lstlisting}[language=Caml]
  Fixpoint get_env_log (n: nat) (curid: Z) (l: Log) :=
    match n with
      | O => None
      | S n =>
        if zeq (proc_id (uRData l)) curid then
          Some l
        else
          get_env_log n curid (Single_Oracle l:: l)
    end.
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Inductive tstate: Type := | TState: Z -> regset -> mem -> dproc -> Log -> tstate.
\end{lstlisting}


\begin{lstlisting}[language=Caml]
  Inductive tstep (ge: genv) : tstate -> trace -> tstate -> Prop :=
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | texec_step_internal:
        forall b ofs f i (rs: regset) m m' d d' ds' rs' curid l,
          proc_id (uRData l) = curid ->
          rs PC = Vptr b ofs ->
          Genv.find_funct_ptr ge b = Some (Internal f) ->
          find_instr (Int.unsigned ofs) f.(fn_code) = Some i ->
          lastEvType l <> Some LogYieldTy ->
          exec_instr ge f i rs (m, (uRData l,d)) = Next rs' (m', (ds',d')) ->
          tstep ge (TState curid rs m d l) E0
                  (TState curid rs' m' d' l)
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  | texec_step_external:
      forall b ef args res (rs: regset) m m' d d' ds' t rs' curid  l l',
        proc_id (uRData l) = curid ->
        rs PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        extcall_arguments rs m (ef_sig ef) args ->
        lastEvType l <> Some LogYieldTy ->
        external_call' (mem:= mwd (cdata PData)) (fun _ => True) ef ge args (m, (uRData l, d)) t res (m', (ds',d')) ->
        rs' = (set_regs (loc_external_result (ef_sig ef)) res 
                        (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                                    (undef_regs (map preg_of destroyed_at_call) rs))) 
                #PC <- (rs RA) #RA <- Vundef ->
        forall NON_YIELD: match ef with
                            | EF_external id _ => 
                              if peq id thread_yield then False
                              else if peq id thread_sleep then False
                                   else
                                     if has_event id then
                                       exists largs choice,
                                         val2Lval_list args largs  /\
                                         choice_check id largs (uRData l) d = choice /\ 
                                         l' = (LEvent curid (LogPrim id largs choice (snap_func d)) :: l) 
                                     else
                                       l' = l
                            | _ => l' = l
                          end,
                          forall STACK:
                          forall b o, rs ESP = Vptr b o ->
                                      (Ple (Genv.genv_next ge) b /\ Plt b (Mem.nextblock m)),
                          forall SP_NOT_VUNDEF: rs ESP <> Vundef,
                          forall RA_NOT_VUNDEF: rs RA <> Vundef,
                            tstep ge (TState curid rs m d l) t 
                                  (TState curid rs' m' d' l')
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | texec_step_prim_call:
        forall b ef (rs: regset) m m' d d' ds' t rs' curid l l',
          proc_id (uRData l) = curid ->
          rs PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          lastEvType l <> Some LogYieldTy ->
          primitive_call (mem:= mwd (cdata PData)) ef ge rs (m, (uRData l, d)) t rs' (m', (ds', d')) ->
          forall NON_YIELD: match ef with
                              | EF_external id _ => 
                                if peq id thread_yield then False
                                else if peq id thread_sleep then False
                                     else
                                       if has_event id then
                                         l' = (LEvent curid (LogPrim id nil 0 (snap_func d)) :: l)
                                       else
                                         l' = l
                              | _ => l' = l
                            end,
          tstep ge (TState curid rs m d l) t 
                (TState curid rs' m' d' l')
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | texec_step_external_yield:
        forall b ef (rs0 rs': regset) (m m': mem) curid s l l' l'' l''' nb d e,
          proc_id (uRData l) = curid ->
          rs0 PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          stencil_matches s ge ->
          l' = LEvent curid (LogYield (Mem.nextblock m))::l ->
          lastEvType l <> Some LogYieldTy ->
          get_env_log limit curid l' = Some l'' ->
          last_op l'' = Some e ->
          state_check thread_yield nil l d ->
          l''' = LEvent curid LogYieldBack::l'' ->
          rs' = (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                            (undef_regs (map preg_of destroyed_at_call) rs0)) 
                  # EAX <- Vundef #PC <- (rs0 RA) #RA <- Vundef ->
          forall
            (Hnextblock: getLogEventNB (e) = Some nb)
            (NON_YIELD: match ef with
                               | EF_external id _ => 
                                 if peq id thread_yield then True
                                else False
                               | _ => False
                             end)
                 (LIFT_NEXTBLOCK: mem_lift_nextblock m (Pos.to_nat (nb) - Pos.to_nat(Mem.nextblock m) % nat) = m'),
            tstep ge (TState curid rs0 m d l) E0
                  (TState curid rs' m' d l''')
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    | texec_step_external_sleep:
        forall b ef (rs0 rs': regset) (m m': mem) curid s l l' l'' l''' nb d e i,
          proc_id (uRData l) = curid ->
          rs0 PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          stencil_matches s ge ->
          l' = LEvent curid (LogSleep (Int.unsigned i) (Mem.nextblock m)
                                      (sync_chpool_check thread_sleep ((Lint i)::nil) (uRData l) d))::l ->
          lastEvType l <> Some LogYieldTy ->
          get_env_log limit curid l' = Some l'' ->
          last_op l'' = Some e ->
          state_check thread_sleep (Lint i::nil) l d ->
          l''' = LEvent curid LogYieldBack::l'' ->
          rs' = (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil)
                            (undef_regs (map preg_of destroyed_at_call) rs0)) 
                  # EAX <- Vundef #PC <- (rs0 RA) #RA <- Vundef ->
          forall
            (Hnextblock: getLogEventNB (e) = Some nb)
            (Hargs: extcall_arguments rs0 m (mksignature (Tint:: nil) None cc_default) (Vint i:: nil))
            (NON_YIELD: match ef with
                          | EF_external id _ => 
                            if peq id thread_sleep then True
                            else False
                          | _ => False
                        end)
            (LIFT_NEXTBLOCK: mem_lift_nextblock m (Pos.to_nat (nb) - Pos.to_nat (Mem.nextblock m) % nat) = m'),
            tstep ge (TState curid rs0 m d l) E0
                  (TState curid rs' m' d l''').
\end{lstlisting}

\begin{lstlisting}[language=Caml]
   Definition tfinal_state : tstate -> int -> Prop :=
     fun _ _ => False.
   
   Definition init_dproc  :=
     if zeq main_thread current_thread then main_init_dproc else nomain_init_dproc.

   Inductive tinitial_state {F V} (p: AST.program F V): tstate -> Prop :=
   | tinitial_state_intro: 
       forall m0 m1 rs0,
         Genv.init_mem p = Some m0 ->
         init_mem_lift_nextblock m0 = m1 ->
         initial_thread_state (Genv.globalenv p) current_thread init_log = Some rs0 ->
         tinitial_state p (TState current_thread rs0 m1 (thread_init_dproc current_thread) init_log).
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Lemma star_step_get_env_log:
    forall ge rs d m curid l l',
      get_env_log limit curid l = Some l' ->
      star iestep ge
           (IEState (proc_id (uRData l))
                    (ZMap.set curid (Running rs) (ZMap.init Environment))
                    m
                    (ZMap.set curid (Some d) (ZMap.init None)) l) E0
           (IEState curid
                    (ZMap.set curid (Running rs) (ZMap.init Environment))
                    m
                    (ZMap.set curid (Some d) (ZMap.init None)) l').
  Proof.
\end{lstlisting}

\begin{lstlisting}[language=Caml]
  Inductive match_tstate_iestate: (ZMap.t ThreadState) -> (mem * mem) -> (ZMap.t (option dproc)) ->
                                 regset -> mem -> dproc -> Log -> Z -> Prop :=
  | MATCH_TSTATE_IESTATE:
      forall (rs: regset) rsm (m: mem) (mp : mem * mem) (d: dproc) (dp : ZMap.t (option dproc)) curid l
             (RSM: rsm = ZMap.set curid (Running rs) (ZMap.init Environment))
             (Hcurid: proc_id (uRData l) = current_thread)
             (MP: m = fst mp)
             (DP: dp = ZMap.set curid (Some d) (ZMap.init None)),        
        match_tstate_iestate rsm mp dp rs m d l curid.

  Theorem one_step_Asm_T2E:
    forall ge mp m m' curid curid' rsm rs rs' l l' dp d d' t
           (TStep: TAsm.tstep ge (TState curid rs m d l) t (TState curid' rs' m' d' l'))
           (Match: match_tstate_iestate rsm mp dp rs m d l curid),
    exists rsm' mp' dp',
      plus IIEAsm.iestep ge (IEState curid rsm mp dp l) t
           (IEState curid' rsm' mp' dp' l')
      /\ match_tstate_iestate rsm' mp' dp' rs' m' d' l' curid'.
\end{lstlisting}

%\subsection{Intermediate Thread-Local Machine Model}\label{subsec:tasm}
%
%Now, we have already gotten a single threaded machine model, which gives us a full isolation.
%However, $\EAsmM{}$ itself is quite different with $\AsmLM$ in terms of its state definition and evaluation rules,
%so it is hard for us to show the refinement relation between this $\EAsmM{}$ and $\AsmLM$ directly. 
%Especially, yield back and environmental steps in $\EAsmM{}$ does not match well with our $\AsmLM$ rules. 
%If we keep those operational style strategy query evaluation, it is hard for us to define a single step behavior of 
%scheduling primitives in our thread-local layer interface.
%To bridge the gap between $\EAsmM{}$ and $\AsmLM$,
%we have introduced one more intermediate machine model, $\TAsmM{[c, \curthread]}$. 
%In here, the machine is always parameterized by a fixed thread id, which we will always notate as $\curthread$. 
%And using this variable, we define this machine's state as
%\begin{small}
%\[
%st_{TAsm} = (\curthread, \ \regs_{\curthread}, \dproc_{\curthread}, \SLog) 
%\]
%\end{small}
%, which has a shared log and only one private data for the thread.
%In this machine, all other threads' steps should be replaced by environmental steps
%as our single-threaded concurrent machine model, $\EAsmM{[c, \{current\_thread\}]}$, does.
%In addition to that, to define a single step behavior of scheduling primitives in our thread-local machine, a big-step style strategy query function has 
%been introduced as
%\begin{small}
%\[{\small
%\begin{array}{l}
%\oracle^{t} \vdash \getenvlog\ (limit :\mathbb{N})\ (l: \SLog ):  \SLog  \\
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :=
%\begin{cases}
%\ \ \mathrm{None}\hfill (\mathrm{when} \ limit = 0) \\
%\ \ \mathrm{Some} \ l \hfill (\mathrm{when} \ \procid{\updatefun_{init}(l)} = \curthread) \\
%\ \ \oracle^{t} \vdash \getenvlog((limit - 1), ((\oracle^{t}(\{\curthread\})(l))::l))\ \ \ \ \  \ \ \ \ \ 
%\hfill (\mathrm{Otherwise})\\
%\end{cases} 
%\end{array}
%}\]
%\end{small}
%, which queries the strategy iteratively until the current thread gets the evaluation control again.
%
%Using the definition, $\TAsmM{[c, current\_thraed]}$ can merge multiple strategy queries during yield call as a single one, 
%and the yield evaluation rule for $\TAsmM{[c, current\_thraed]}$ is defined as
%\begin{small}
%\begin{mathpar}
%\inferrule{
%\updatefun_{init}(l) = ds \\
%\procid(ds) = \curthread \\ 
%\statecheck(\yield, [],ds,\snapfun(d)) \\ 
%f_{\dproc}(curid) = Some\ d \\ 
%\nextblockfun(m) = nb \\ 
%l' = (\curthread , ([], nb, \snapfun(d)))::l \\
%\oracle^{t} \vdash \getenvlog(limit, l') = l'' \\
%last\_event(l) = ev \\
%ev = (\_, (nb, \_)) \vee ev = (\_, (\_, nb, \_))  \\
%\liftnextblock{m}{nb - \nextblock{m}} = m' \\
%l''' = (\curthread , \yieldbackunit)::l''\\
%%\oracle, c\vdash \sstepr{\spec_{id}}{[largs]}{\regs, m, ds, d}{\textit{res}\cup \{\}}{\regs',  m', ds', d'}
%}{
%\curthread, \oracle^{t}, c, \oracle \vdash_\codeinmath{TAsm} \sstep{\yield}{[]}{\curthread, \regs, m', l, d}
% {\{ \}, \curthread, \regs', m', l', d}
%}
%\end{mathpar}
%%\vspace{-5px}
%\end{small}%
%Intuitively, this rule first updates the current shared log by adding one yield event 
%and perform the strategy query using the log.
%If the current strategy returns a log as its result,
%this yield rule updates the machine state using
%the information that the machine has gotten from the querying. 
%Note that the currently-running thread information and a private abstract data do not change at all 
%during this yield call. 
%From $\TAsmM{}$, all machines are thread-local, 
%and scheduling primitives will not perform any context switching at all. 
%Since the differences between $\TAsmM{}$ and $\EAsmM{}$ are only in the state definition 
%and the way to handle yield and sleep evaluations, 
%we can easily prove the following theorem by doing case analysis:
%
%\begin{theorem}[$\TAsmM{}$ refines $\EAsmM{}$]
%\begin{small}
%$$\ltyp{(\{\curthread\}, \oracle^{t}, c, \oracle  \vdash_{\EAsmM{}} \mathrm{PH})}{}{\varnothing}
%{(\curthread, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} \mathrm{PH})}$$
%\end{small}
%\label{theorem:tasm-refines-easm}
%\end{theorem}
%
%With the given simulation relation, $\simrel(st_{\TAsmM{}}, st_{\EAsmM{}})$, we also need to show the following two cases.
%
%$\proofcase{initial\_state}$ 
%The proof for this case requires additional lemmas.
%This is because in $\TAsmM{}$, a shared log of the initial state is already $\SLog_{init}$ of the current thread.
%In the case of $\EAsmM{}$, however, a shared log of the initial state is always $nil$. 
%Therefore, we need to prove the statement, which is when we have a $init\_st_\TAsmM{}$ and a $init\_st_\EAsmM{}$, there always exist valid more than zero steps in $\EAsmM{}$ and the state $st_{\EAsmM{}}$ which satisfies
%$$ \{\curthread\}, \oracle^{t}, c, \oracle\vdash_{\TAsmM{}} init\_st_{\EAsmM{}} \ni^{*} st_{\EAsmM{}} \wedge \simrel(init\_st_{\TAsmM{}}, st_{\EAsmM{}})$$
%Intuitively, the lemma implies that we need to apply $\EAsmM{}$'s evaluation rules to its initial state for environment threads until we get $\SLog_{init}$ as a shared log of the state.
%
%Proofs for this lemma requires us to work with the induction on $\SLog_{init}$ for the current thread.
%If the initial log is $nil$, the initial state of $\EAsmM{}$ will be directly matched with the initial state of $\TAsmM{}$, which is $\simrel(init\_st_{\TAsmM{}}, init\_st_{\EAsmM{}})$.
%In the inductive case, we use the well-formedness condition of our $\SLog_{init}$. 
%This enforces that the initial log should be 
%either $nil$ or only contain events generated by other threads except the last one $yieldBack$ event as well as 
%the log should have a valid event that creates the current thread at some point.
%This well-formedness condition is not a magic in our proof because it can be removed when we link all threads together 
%(we already show the way to link multiple threads in the previous section).
%Then, we know that all events except the last $yieldBack$ are
% generated by other threads in our environment, and cannot contain
%any events raised by the current thread. 
%Since the current $\EAsmM{}$ that we are considering is a single threaded machine parameterized by
%a singleton set, $\{\curthread\}$, we know that all evaluation to generate the exactly same log with the initial log (for $\curthread$) on $\EAsmM{}$ should be on environment step of $\EAsmM{}$ except the last one $yieldBack$ rule after the current 
%thread get a control for its evaluation. 
%Therefore, we can provide the $st_{\EAsmM{}}$ which satisfies
%$$\{\curthread\}, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} init\_st_{\EAsmM{}} \ni^{*} st_{\EAsmM{}} \wedge \simrel(init\_st_{\TAsmM{}}, st_{\EAsmM{}})$$
%
%
%$\proofcase{one\_step\_refinement}$
%Next step is showing the fact that when $\simrel(st_{\TAsmM{}}, st_{\EAsmM{}})$ and 
%when we have one step evaluation on $\TAsmM{}$, 
%which is $\curthread, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} st_{\TAsmM{}} \ni st'_{\TAsmM{}} $, 
%then there exists a $st'_{\EAsmM{}}$ that satisfies 
%$$\{\curthread\}, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} st_{\EAsmM{}} \ni^{+} st'_{\EAsmM{}} \wedge \simrel(st'_{\TAsmM{}}, st'_{\EAsmM{}})$$
%
%Proving this property requires case analysis on $\TAsmM{}$ evaluation rules.
%
%For all cases except scheduling rules in $\TAsmM{}$ (\textit{\ie} $\yield$ and $\sleep$ rules), 
%we can provide a next state in $\EAsmM{}$ ($st'_{\EAsmM{}}$) directly, which satisfies $\{\curthread\}, \oracle^{t}, c,\oracle \vdash_{\EAsmM{}} st_{\EAsmM{}} \ni st'_{\EAsmM{}} \wedge \simrel(st'_{\TAsmM{}}, st'_{\EAsmM{}})$.
%
%In case of the $\yield$ evaluation rule in $\TAsmM{}$, let's assume that 
%a shared log in $st_{\TAsmM{}}$ is $l$, and $\oracle^{t} \vdash \getenvlog{}$ returns a shared log $l''$ with an arbitrary big number $limit$ and the 
%given argument $l'$ (\textit{\ie} $l' = (\curthread , ([], nb, \snapfun(d)))::l$) when $d$ is a 
%private state of $st_{\TAsmM{}}$ and $nb$ is a next available block of the memory in $st_{\TAsmM{}}$). 
%With this result, a shared log in $st'_{\TAsmM{}}$ will be $(\curthread , \yieldbackunit)::l''$.
%Then, by its definition, there always exists a valid $l_{added}$ which satisfies $l'' = l_{added} {+\!\!+} l'$.
%Therefore, we can prove this case by doing an induction on $l_{added}$. 
%If the log ($l_{added}$) is $nil$, then, we simply match this one $\yield$ evaluation rule 
%(that updates the log as $l'''$) with one step $yield$ and one step $yieldBack$ rules in $\EAsmM{}$.
%Therefore, we can provide a valid $st'_{\EAsmM{}}$ 
%which satisfies $\{\curthread\}, \oracle^{t}, c,\oracle \vdash_{\EAsmM{}} st_{\EAsmM{}} \ni^{+} st'_{\EAsmM{}} \wedge \simrel(st'_{\TAsmM{}}, st'_{\EAsmM{}})$.
%In the inductive case, $\EAsmM{}$ needs to perform an evaluation with its environment rule which will add one event 
%into its shared log at every time. 
%Other rules will not be applied to generate the next $\EAsmM{}$ state because all threads except
%$\curthread$ are in the state of $\mathrm{Environment}$ now. 
%Therefore, we also can provide a valid new state, $st'_{\EAsmM{}}$ that satisfies 
%$\{\curthread\}, \oracle^{t}, c,\oracle \vdash_{\EAsmM{}} st_{\EAsmM{}} \ni^{+} st'_{\EAsmM{}} \wedge \simrel(st'_{\TAsmM{}}, st'_{\EAsmM{}})$ and which is doing its evaluation by applying one $\yield$ rule, multiple environment 
%rules, and one $yieldBack$ rule of $\EAsmM{}$ on $st_{\EAsmM{}}$.
%
%In the case of the $\sleep$ evaluation rule in $\TAsmM{}$, we also can provide a valid $st'_{\EAsmM{}}$ that satisfies 
%$\{\curthread\}, \oracle^{t}, c, \oracle\vdash_{\EAsmM{}} st_{\EAsmM{}} \ni^{+} st'_{\EAsmM{}} \wedge \simrel(st'_{\TAsmM{}}, st'_{\EAsmM{}})$ by using the similar approach with the $\yield$ case.
%
%
%\subsection{Thread-Local Machine Model}\label{subsec:hasm}
%By applying the whole process on $\CSched$ that we have mentioned,
%we finally can define thread-local layer interface  discussed in Sec.~\ref{subsec:phthreadlayer}.
%The machine model for thread-local layer interface is almost same with the machine model of CPU-local layer interface, which is $\AsmLM$.
%Therefore, we are able to 
%utilize the whole power of $\compcertx$\ and build thread-local layers both written in C and in Assembly with the guarantee that those layers preserve the same behavior in our CPU-local machine.
%This machine model, however, has two differences with  $\AsmLM$.
%First, as mentioned in Sec.~\ref{subsec:phthreadlayer}, the evaluation semantics
%for $\yield$ and $\sleep$ is totally changed as no-op like evaluations.
%This difference is already dealt with multiple steps of refinement with several different machine models. 
%In this sense, no additional steps are required to handle this issue.
%Second, the machine allows a dynamic initial state for each thread, and this dynamically assigned 
%initial state should be satisfied by our system invariant.
%To resolve this challenge, 
%Our thread-local layer interface provides one abstract definition that will be
%instantiated with a concrete layer and a data structure implementation later.
%
%The abstract function, $\composedata$, has a type of
%\begin{small}
%\[
%\composedata : \mathbb{Z} \rightarrow \dshare \rightarrow \dproc \rightarrow adt
%\]
%\end{small}
%which gets the current thread id, a shared data, and a private data as its arguments 
%and returns a \textit{abstract data} for $\AsmHM$ with the current thread id.
%With this function, an initial state of a thread-local layer interface with the current thread id ($\curthread$) will be 
%as
%\begin{small}
%\[
%\composedata(\curthread, \ \updatefun_{init}(\SLog_{init}), init\_dproc(\curthread))
%\]
%\end{small}
%This definition also gives consistency between our multithreaded concurrent machine model 
%and this thread-local machine model.
%When looking at the initial state definition for $\EAsmM{}$ in Sec.~\ref{subsec:fulleasm},
%finding the similarity between both definitions is straightforward.
%For the guarantee about preserving our system invariant in the initial state, we only need to prove that 
%the calculated initial state satisfies our invariant.
%
%With the all stated ingredients during multiple previous sections, we can prove the following refinement theorem:
%\begin{theorem}[$\AsmHM$ Refines $\TAsmM{}$]
%\begin{small}
%Assume that the simulation relation between $\TAsmM{}$ and $\AsmHM$ is $\simrel(st_{\AsmHM}, st_{\TAsmM{}})$.
%In addition, suppose that there exists a layer definition, $\mathrm{PH}$, that satisfies an abstract relation, 
%$\absrelt(\simrel(st_{\AsmHM}, st_{\TAsmM{}}), \TSched, \mathrm{PH})$. Then,
%$$\ltyp{(\curthread, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} \mathrm{PH})}
%{\absrelt(\simrel(st_{\AsmHM}, st_{\TAsmM{}}), \TSched, \mathrm{PH})}
%{\varnothing}{(\curthread, \oracle^{t}, c, \oracle \vdash_{\AsmHM} \TSched)}$$
%\end{small}
%\label{theorem:hasm-refines_tasm}
%\end{theorem}%
%
%$\proofcase{initial\_state}$ We show that there exists a valid initial state of $\TAsmM{}$ which satisfies our simulation relation
%$\simrel$ with an initial machine state of $\AsmHM$, which is stated as follows:
%$$\simrel(init\_st_{\AsmHM}, init\_st_{\TAsmM{}})$$
%This proof relies on the abstract relation $\absrelt(\simrel(st_{\AsmHM}, st_{\TAsmM{}}), \TSched, \mathrm{PH})$,
%but this case is quite trivial in its essence
%because we construct $init\_st_{\AsmHM}$ using a $init\_st_{\TAsmM{}})$ and 
%the $\composedata$ function.
%
%$\proofcase{one\_step\_refinement}$
%Next step is showing the fact that when $\simrel(st_{\AsmHM}, st_{\TAsmM{}})$ and when we have one step evaluation on $\AsmHM$, which is $\oracle, \ c, \oracle^{t}, \curthread \vdash_{\AsmHM} st_{\AsmHM} \ni st'_{\AsmHM} $, 
%then there exists a $st'_{\TAsmM{}}$ that satisfies 
%$$\curthread, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} st_{\TAsmM{}} \ni st'_{\TAsmM{}} \wedge \simrel(st'_{\AsmHM}, st'_{\TAsmM{}})$$
%
%Proving this property requires case analysis on $\AsmHM$ evaluation rules, and it  
%also heavily relies on the abstract definition,  $\absrelt(\simrel(st_{\AsmHM}, st_{\TAsmM{}}), \TSched, \mathrm{PH})$.
%
%For all cases except the external call evaluation rule in $\AsmHM$, 
%we can provide a valid $st'_{\TAsmM{}}$ directly, which satisfies $\curthread, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} st_{\TAsmM{}} \ni st'_{\TAsmM{}} \wedge \simrel(st'_{\AsmHM}, st'_{\TAsmM{}})$.
%
%For the external call case, we need additional case analysis.
%When the primitive is neither $\yield$ nor $\sleep$, then the matched
%evaluation rule in $\TAsmM{}$ will also be the external evaluation rule. 
%Then, we can provide a next state, $st'_{\TAsmM{}}$, that satisfies $\curthread, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} st_{\TAsmM{}} \ni st'_{\TAsmM{}} \wedge \simrel(st'_{\AsmHM}, st'_{\TAsmM{}})$.
%
%If the primitive is one of $\yield$ and $\sleep$, we match the evaluation with the $\yield$ evaluation rule in $\TAsmM{}$ or 
%the $\sleep$ evaluation rule in $\TAsmM{}$, respectively.
%Then, we can also provide a valid $st'_{\TAsmM{}}$ that satisfies $\curthread, \oracle^{t}, c, \oracle \vdash_{\TAsmM{}} st_{\TAsmM{}} \ni st'_{\TAsmM{}} \wedge \simrel(st'_{\AsmHM}, st'_{\TAsmM{}})$.
%
%Now, we can finally prove that our thread-local machine refines our CPU-local machine and our fully linked thread-local machine refines our 
%CPU-local machine. 
%The first property gives us a source to build thread-local layers and the second one guarantee our thread-local machine behavior is consistent with 
%
%\ignore{
%\begin{theorem}[$\AsmHM$ refines $\AsmLM$]
%\begin{small}
%Assuming two machines, $\AsmHM$ and $\AsmLM$. Then we can show that
%$$\ltyp{(c, \oracle \vdash_{\AsmLM} \CSched)}
%{}
%{\varnothing}{(\curthread, \oracle^{t}, c, \oracle \vdash_{\AsmHM} \TSched)}$$
%when $\curthread$ is a member of threads on CPU $c$, and when we have valid abstract relations
%$\absrel$ and $\absrelt$ with the abstract intermediate layer $\mathrm{PH}$ on $\EAsmM{}$ and $\TAsmM{}$.
%\end{small}
%\label{theorem:tasm_refines_lasm}
%\end{theorem}%
%
%By using Theorem~\ref{theorem:easm_refine_lasm},~\ref{theorem:full-easm-refines-single-easm},~\ref{theorem:tasm-refines-easm}~\ref{theorem:hasm-refines_tasm}, we can show that the theorem is correct.
%}
%The second theorem in here is more detailed version of Theorem~\ref{theorem:thread-full-compose} by exposing several hidden definitions to simplify the theorem. 
%
%\begin{theorem}[Merged $\AsmHM$ refines $\AsmLM$]
%\begin{small}
%Assuming two machines, $\AsmHM$ and $\AsmLM$ and $\fullthreadset$ contains all available threads on CPU $c$.
%. Then we can show that
%$$\ltyp{(c, \oracle \vdash_{\AsmLM} \CSched)}
%{}
%{\varnothing}{\join_{tid \in \fullthreadset} (\curthread, \oracle^{t}, c, \oracle \vdash_{\AsmHM} \TSched)}$$
%when we have valid abstract relations $\absrel$ and $\absrelt$ with the abstract intermediate 
%layer $\mathrm{PH}$ on $\EAsmM{}$ and $\TAsmM{}$.
%\end{small}
%\label{theorem:tasm_refines_lasm}
%\end{theorem}%
%
%By using Theorem~\ref{theorem:easm_refine_lasm},~\ref{theorem:thread-full-compose},~\ref{theorem:tasm-refines-easm}~\ref{theorem:hasm-refines_tasm}, we can show that the theorem is correct.
%
%

\section{Connecting with Thread Local Machine Model}
\label{chapter:linking:subsec:connecting-with-thread-local-machine-model}

The thread local machine is same with 
the cpu local machine that is described in Section~\ref{chapter:linking:subsec:cpu-local-layer-interface}
except one thing. 
The thread local machine has a thread-specific initial state 
based on the initial log for the thread. 
\begin{lstlisting}[language=Caml]
  Inductive initial_state {F V} p: state (mem := mwd (cdata RData)) -> Prop :=
    | initial_state_intro m0 m1 d pc:
        Genv.init_mem (F:=F) (V:=V) p = Some (m0, d) ->
        init_mem_lift_nextblock m0 = m1 ->
        let ge := Genv.globalenv p in
        initial_thread_pc ge current_thread init_log = Some pc ->
        let rs0 := (Pregmap.init Vundef) # PC <- pc # ESP <- Vzero in
        initial_state p (State rs0 (m1, d)).
\end{lstlisting}
To model it, 
we need a connection between the definition of states for intermediate languages 
as well as a state definition for this thread local machine. 
The biggest benefit of having this thread local machine is 
the reusability of compiler. 


\subsection{Refinement Between HAsm and TAsm}

\begin{lstlisting}[language=Caml]
      Class AbstractRelT:=
        {
          match_dproc_RData: dproc -> Log -> RData -> Prop;

          match_curid: current_thread = current_curid;

          match_init:
            match_dproc_RData
              (thread_init_dproc current_thread)
              init_log
              (thread_init_rdata current_thread);
\end{lstlisting}

\begin{lstlisting}[language=Caml]
          get_env_log_exist: 
            forall e l l' curid, 
              proc_id (uRData l) = curid ->
              lastEvType l <> Some LogYieldTy ->
              l' = e::l ->
              lastEvType l' = Some LogYieldTy ->
              match last_op l' with
              | Some e => match e with 
                          | LEvent curid' _ => curid = curid'
                          end
              | _ => False
              end ->
              exists l'', get_env_log limit curid l' = Some l'' /\ lastEvType l'' = Some LogYieldTy;
\end{lstlisting}

\begin{lstlisting}[language=Caml]
          yield_nextstate_match:
            forall curid  ae (m m' : mem) (a a': RData) (l l' l'' l''': Log) e nb WB ef (ge : genv) args m t res,
              lastEvType l <> Some LogYieldTy ->
              proc_id (uRData l) = curid ->
              match_dproc_RData ae l a ->
              l' = LEvent curid (LogYield (Mem.nextblock m)) :: l ->
              get_env_log limit curid l' = Some l'' ->
              last_op l'' = Some e ->
              getLogEventNB e = Some nb -> 
              l''' = LEvent current_curid LogYieldBack::l'' ->
              match ef with 
              | EF_external id _ =>
                if peq id thread_yield then True else False 
              | _ => False
              end ->
              external_call' (mem := mwd (cdata RData)) 
                             (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (phthread <@$\oplus$@>  L64))
                             WB ef ge args (m, a) t res (m', a') ->
              (mem_lift_nextblock m (Pos.to_nat nb - Pos.to_nat (Mem.nextblock m)) = m') /\
              match_dproc_RData ae l''' a' /\
              state_check thread_yield nil l ae /\
              proc_id (uRData l''') = curid;
\end{lstlisting}

\begin{lstlisting}[language=Caml]
          sleep_nextstate_match:
            forall curid  ae (m m' : mem) (a a': RData) (l l' l'' l''': Log) e nb WB ef (ge : genv) args m t res i,
              lastEvType l <> Some LogYieldTy ->
              proc_id (uRData l) = curid ->
              match_dproc_RData ae l a ->
              l' = LEvent curid (LogSleep (Int.unsigned i) (Mem.nextblock m)
                                          (sync_chpool_check thread_sleep (Lint i::nil) (uRData l) ae))::l ->
              get_env_log limit curid l' = Some l'' ->
              last_op l'' = Some e ->
              getLogEventNB e = Some nb -> 
              l''' = LEvent current_curid LogYieldBack::l'' ->
              match ef with 
              | EF_external id _ =>
                if peq id thread_sleep then True else False 
              | _ => False
              end ->
              external_call' (mem := mwd (cdata RData)) 
                             (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (phthread <@$\oplus$@>  L64))
                             WB ef ge args (m, a) t res (m', a') ->
              args = Vint i :: nil ->
              (mem_lift_nextblock m (Pos.to_nat nb - Pos.to_nat (Mem.nextblock m)) = m') /\
              match_dproc_RData ae l''' a' /\
              state_check thread_sleep (Lint i::nil) l ae /\
              proc_id (uRData l''') = curid;
\end{lstlisting}

\begin{lstlisting}[language=Caml]
          acc_exec_load_match:
            forall (ge: genv) a a' rs rd rs' TY (m m': mem) l d addr,
              exec_loadex ge TY (m, a) addr rs rd = Next rs' (m', a') ->
              match_dproc_RData d l a ->
              exists d',
                (acc_exec_load (cl_oplus (cdata PData) LH L64)) 
                  fundef unit ge TY (m, (uRData l, d)) addr rs rd = Next rs' (m', (uRData l, d')) /\
                match_dproc_RData d' l a';

          acc_exec_store_match:
            forall (ge: genv) a a' rs rd rs' TY ST (m m': mem) l  d addr,           
              exec_storeex ge TY (m, a) addr rs rd ST = Next rs' (m', a') ->
              match_dproc_RData d l a ->
              exists d' : dproc,
                (acc_exec_store (cl_oplus (cdata PData) LH L64)) 
                  fundef unit ge TY (m, (uRData l, d)) addr rs rd ST =
                Next rs' (m', (uRData l, d')) /\ match_dproc_RData d' l a';
\end{lstlisting}

\begin{lstlisting}[language=Caml]
          external_call_match_no_event:
            forall (ge: genv) WB ef (args: list val) t res (m m' : mem) (a a': RData) ae l,
              external_call' (mem := mwd (cdata RData)) 
                             (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (phthread <@$\oplus$@>  L64))
                             WB ef ge args (m, a) t res (m', a') ->
              match_dproc_RData ae l a ->
              proc_id (uRData l) = current_curid ->
              lastEvType l <> Some LogYieldTy ->
              match ef with
              | EF_external id _ => 
                if peq id thread_yield then False
                else if peq id thread_sleep then False
                     else if has_event id then False else True
              | _ => True
              end -> 
              exists ae',
                external_call' (mem := mwd (cdata PData)) 
                               (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (LH <@$\oplus$@>  L64))
                               WB ef ge args (m, (uRData l, ae)) t res (m', (uRData l, ae')) /\
                match_dproc_RData ae' l a' /\
                proc_id (uRData l) = current_curid;
\end{lstlisting}

\begin{lstlisting}[language=Caml]
          external_call_match_has_event:
            forall (ge: genv) WB ef (args: list val) t res (m m' : mem) (a a': RData) ae l,
              external_call' (mem := mwd (cdata RData)) 
                             (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (phthread <@$\oplus$@>  L64))
                             WB ef ge args (m, a) t res (m', a') ->
              match_dproc_RData ae l a ->
              proc_id (uRData l) = current_curid ->
              lastEvType l <> Some LogYieldTy ->
              match ef with
              | EF_external id _ => 
                if peq id thread_yield then False
                else if peq id thread_sleep then False
                     else if has_event id then True else False
              | _ => False
              end -> 
              exists (largs : list lval) ae' (l' : Log),
                external_call' (mem := mwd (cdata PData)) 
                               (external_calls_ops :=  CompatExternalCalls.compatlayer_extcall_ops (LH <@$\oplus$@>  L64))
                               WB ef ge args (m, (uRData l, ae)) t res (m', (uRData l', ae')) /\
                match_dproc_RData ae' l' a' /\
                val2Lval_list args largs /\
                
                proc_id (uRData l') = current_curid /\
                match ef with 
                | EF_external id _ =>
                  exists choice,
                  choice_check id largs (uRData l) ae = choice /\
                  l' = LEvent (proc_id (uRData l)) (LogPrim id largs choice (snap_func ae)) :: l
                | _ =>  l' = l
                end;
\end{lstlisting}

\begin{lstlisting}[language=Caml]
          primitive_call_match:
            forall (ge: genv) ef t rs rs' (m m' : mem) l a a' ae,
              primitive_call  (LayerConfigurationOps := compatlayer_configuration_ops (phthread <@$\oplus$@> L64))
                              (mem := mwd (cdata RData)) ef ge rs (m, a) t rs' (m', a') ->
              match_dproc_RData ae l a ->
              proc_id (uRData l) = current_curid ->
              match ef with
              | EF_external id _ => 
                if peq id thread_yield then False
                else if peq id thread_sleep then False
                     else True
              | _ => True
              end -> 
              exists l' ae',
                primitive_call  (LayerConfigurationOps := lcfg_ops) 
                                (mem := mwd (cdata PData)) ef ge rs (m, (uRData l, ae)) t rs' (m', (uRData l', ae')) /\
                match_dproc_RData ae' l' a' /\
                proc_id (uRData l') = current_curid /\
                match ef with
                | EF_external id _ => 
                  if has_event id
                  then l' = LEvent (proc_id (uRData l)) (LogPrim id nil 0 (snap_func ae)) :: l
                  else l' = l
                | _ => l' = l
                end
        }.
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    Inductive match_tstate: (state (mem:= mwd (cdata RData))) -> 
                                  (tstate (mem := mem)) -> Prop :=
    | MATCH_TSTATE:
        forall (rs: regset) (m: mem) a ae (l : Log)
               (Hdata: match_dproc_RData ae l a)
               (Hcurid: proc_id (uRData l) = current_curid)
               (Hlast: lastEvType l <> Some LogYieldTy),
          match_tstate (State rs (m, a)) (TState current_curid rs m ae l).
\end{lstlisting}

\begin{lstlisting}[language=Caml]
    Theorem LAsm_refine_TAsm :
      forall ge t rs m rs' m' st, 
        LAsm.step (lcfg_ops := compatlayer_configuration_ops (phthread <@$\oplus$@> L64)) ge (State rs m) t (State rs' m') ->
        match_tstate (State rs m) st ->
        exists st',        
          TAsm.tstep ge st t st'
          /\ match_tstate (State rs' m') st'.
\end{lstlisting}

