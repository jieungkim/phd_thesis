\section{Multithreaded Linking}
\label{chapter:linking:sec:multithreaded-linking}


The purpose of building a framework for multithreaded linking is similar to 
the that of our multicore part,
provide the thread-local interface 
by hiding other threads' behavior. 
It, however, differs from multicore linking part, of which the  context and the configuration 
are simpler than those of multithreaded linking part. 
When looking at the multithreaded linking, 
systems already has to provide 
scheduling related primitives (\ie, yield, sleep, create)
as well as other system services 
that are necessary to implement those primitives. 
For example, 
thread (process) creation usually related to the 
resource management,
such as the maximum number of memories.
In addition, 
some memory areas for multiple threads should be 
mutually exclusive from others. 
In addition to that, 
several private state,
which is hidden from other threads,
has to be properly initialized 
according to other thread.
Those initialized values
 are usually determined by their parents, 
 and they are dynamically allocated.

To sum up, 
Multithreaded linking poses 
multiple challenges based on the environment for the multithreaded programs.
We assume that 
there are arbitrary active or available thread set on the CPU, 
Which does not need to be a sequence of consecutive numbers.
For example, when the maximum range of
the thread number in the system i from 0 to 1023, 
then, CPU 1 may be able to run threads associated the numbers that can be divided by 8. 
Each thread associated with the 
designated thread ID. 
It is possible for threads to use the same identifier again, but 
we avoid this re-usage of the same number because it increase complexity without a huge benefits. 
We, however, assume that the thread set is set of non-consecutive unbounded numbers,
which gives a huge freedom. 
In addition to that, 
we allow dynamic initial states for each thread. 
For example, each thread has maximum capacity of page numbers that they have get is 
assigned by its parent. 
Simpler systems may not allow this dynamic allocation for each thread,
but many systems assign appropriate initial state for each thread 
according to the information when the thread has been spawned.

Using those environment, 
our purpose multthreaded linking is listed as follows:
1) hide context switching between threads; 
2) construct the environmental context for each thread and show the relationship between the 
CPU-local machine evaluation with the each thread's evaluation based on the environmental context;
3) prove compositionalilty of multiple per-thread machines; and 
4) provide the same (almost similar) interface for per-thread layers 
for users to build layers on top of thread local machines. 
\jieung{need to explain more about those challenge}
\jieung{Expecially about context switching - page 20 of concurrent linking slide}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth, page=2]{figs/conlink/concurrent_linking}
\jieung{Need to redraw this figure to add only one env-context for thread local layers}
\caption{Multithreaded Linking Structures.}
\label{fig:chapter:linking:multithreaded-linking-structure}
\end{center}
\end{figure}
Similar to the multicore linking, 
those challenges are hard for us to solve within a single step. 
In this sense, 
we also introduce multiple intermediate languages
in Figure~\ref{fig:chapter:linking:multithreaded-linking-structure}. 


The bottom level of mulithreaded linking is 
a layer that contains scheduling primitives, thread sleep and yield.
Formally, 
when the layer $\CSched[cpuid, \oracle_{cpuid}] = (\Layer_{\CSched}, \ignorechar, \ignorechar)$, which is parameterized by the focused CPU ID ($cpuid$) and the proper environmental context ($\oracle_{cpuid}$), 
the layer should satisfies 
$(\threadyieldfunc, \ignorechar) \in \Layer_{\CSched}$ as well as 
$(\threadsleepfunc, \ignorechar) \in \Layer_{\CSched}$. 
This is the minimum requirement for the multithreaded linking proofs. 
Consequently, 
the top-most layer in the thread local machine
has to include those two primitives. 
Formally, 
when the layer $\TSched[thrd, \oracle_{thrd}] = (\Layer_{\TSched}, \ignorechar, \ignorechar)$, which is parameterized by the focused thread identifier ($thrd$) and the proper environmental context ($\oracle_{thrd}$), 
the layer should satisfies 
$(\threadyieldfunc, \ignorechar) \in \Layer_{\TSched}$ as well as 
$(\threadsleepfunc, \ignorechar) \in \Layer_{\TSched}$. 
They, however, differs from 
the same primitives 
in  $\CSched$ in terms of their behavior. 
The CPU local machine that uses $\CSched[cpuid, \oracle_{cpuid}]$  as its parameter 
uses the state which is defined as
a tuple, 
$(rs, m, a, l)$,
which represents 
a register set, a memory, an abstract state, and a log.
Among them, a register set, a memory, and an abstract state are private datum for CPU local machines. 
In this sense, scheduling primitives, including $\threadyieldfunc$ and $\threadsleepfunc$,
modifies them during their transitions. 
Especially, they requires the change in the register values,  context switching,
which stores the current thread's register value 
and restore the register values for the next scheduled thread. 

To introduce a thread local interface while keeping a capability of 
using the same compiler with the CPU local interface ($\compcertx$, 
thread local layers also has to use the same state definition and the machine model 
with the CPU local interface, which is $(rs, m, a, l)$.
The private state of it, however, 
is only related to the thread. 
In this sense, 
behaviors of scheduling primitives remain those thread local states as they are in their machines. 
The only element that can be changed  in the thread local machine during the scheduling primitives 
is the shared log $l$. 

To hide them, 
we introduced multiple intermediate languages 
that has a transition rules of those primitives explicitly, and the 
the layer that are used as an argument of 
intermediate languages ($\TLink$) is introduced which does not contain those scheduling primitives in it. 

These differences are also applied to 
other primitives in $\CSched$ and $\TSched$.
Some primitives in $\CSched$ accesses CPU-local data, but some of them 
are not always easy to divide them clearly for each thread. 
Pages in the memory, for example, 
can be dynamicaly allocated, thus 
each thread does not know exactly 
which pages are associated with the thread statically
(\ie, it is possible for us to assume that each thread statically 
reserve the number of pages as well as 
the actual page number, but this is far from usual design principal.)
With the given concrete layer definitions for 
all $\CSched$, $\TLink$, as well as $\TSched$,
providing the detailed 
way to divide the CPU-local private states into multiple thread local private states 
may be possible. 
We, however, divide this process 
as two parts, the connection between machine models based on the configurations and abstract relations, 
and introduce the instances of them to link the concrete CPU local machine with 
the thread local machine. 
To make it general as much as possible, 
we have defined two abstract relations, 
which is $AbsRelC$ and $AbsRelT$ in the figure with will work 
with the arbitrary layers for each machines as well as the thread configuration $C$. 


%
%The multithreaded-layer-building files are located in the ccal/ccalmtlib/ directory. They contain: multiple machine models used to build a per-thread layer interface; abstract definitions to build the proper context necessary for the per-thread layer interface; the memory model for per-thread layers; proofs (including refinement) connecting those machine models; and proofs of compositionality of our machine models. The directory contains three intermediate machine models and the per-thread machine model, described as follows:

%EAsmCommon.v 	Common definitions for EAsm and IIEAsm in the below.
%EAsm.v 	Multithreaded machine model with environmental context and a single global memory for all threads (Section 5.2 in the submission). This is the lowest-level machine model in our multi-threaded linking library. This machine model in the view of multithreaded linking is related to env_step in Concurrent_Linking_Def.v in the multicore linking.
%IIEAsm.v 	Multithreaded machine model with environmental context and divided memories (related to Section 5.2 in the submission), separating the current thread from other threads. This machine model makes it easy to prove the refinement between the single threaded machine model (TAsm) and the multithreaded machine model with a single global memory (EAsm).
%TAsm.v 	Single threaded machine model with an explicit environment step in its evaluation rule (related to Section 5.3 in the submission). This machine model is already a thread-local machine model, but we cannot use our thread-safe CompCertX with this model due to the difference between the underlying machine model of CompCert (and its extensions) and this TAsm. Therefore, we add one more machine model, HAsm, to fully facilitate the power of CompCert.
%HAsm.v 	Single threaded machine model for thread-safe CompCertX. This one is quite similar to LAsm (the machine model of CompCertX), but it can dynamically allocate the initial state for each thread (related to Section 5.3 in the submission).
%HAsmLinkTemplate.v 	Vertical and horizontal linking template for per-thread layers.
%
%Building certified multithreaded layers also requires us to define the proper memory model, as described in Section 5.5 of our submission. There are three files in our artifact that are related to this memory extension.
%File 	Description
%AlgebraicMem.v 	Algebraic memory model for multithreaded layer interface.
%AlgebraicMemImpl.v 	Algebraic memory model implementation.
%LAsmAbsDataProperty.v 	LAsm properties for Algebraic memory model.
%
%Building the thread local layer interface also requires providing the proper context for the interface. For this purpose, we provide multiple abstract definitions and functions, as well as properties of those definitions/functions, that must be instantiated when one uses our toolkit to verify an actual program. The following table shows the files that are related to those abstract definitions. We also provide an example illustrating how to use them in our example section (see Section 5-4 (3) in this document).
%File 	Description
%SingleAbstractDataType.v 	Abstract data definitions for intermediate machine models (EAsm, IIEAsm, and TAsm) in multithreaded linking library.
%RegsetLessdef.v 	Properties related to register values.
%SingleOracleDef.v 	Event definitions for multithreaded program linking.
%SingleOracle.v 	Properties of the global log, an environmental context, and other definitions that are required to build the proper context for the per-thread layer interface as well as for multithreaded linking.
%SingleConfiguration.v 	Top-level configuration definitions for multithreaded linking. This includes the definitions in SingleOracle.v and other definitions that are related to building the per-thread layer interface and multithreaded linking (e.g., variables for current thread id, main thread of the CPU, active thread set in the CPU, etc).
%
%Similar to the multicore library in our CCAL, the multithreaded library also provides several proofs that can be generically applied to programs; these proofs can be used with any layer definitions and programs as long as they can fulfill the requirements of our toolkit. There are six files relating to these proofs:
%
%EAsmPropLib.v 	Basic properties related to EAsm, used in the refinement theorems for those machine models as well as in the proofs of compositionality of EAsm.
%AsmIIE2E.v 	Refinement theorem between IIEAsm and EAsm. Both are multithreaded layers with a full active thread set, but their memory models are slightly different.
%AsmIIE2IIE.v 	Refinement theorem between IIEAsm with one single thread and IIEAsm with a full active thread set on the CPU.
%AsmT2IIE.v 	Refinement theorem between TAsm (single threaded machine) and IIEAsm with one single thread.
%{EAsmCompose.v, EAsmComposeRefinement.v} 	Compositionality of EAsm (not used in mC2 example).