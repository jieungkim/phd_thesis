\section{Multithreaded Linking}
\label{chapter:linking:sec:multithreaded-linking}
\jieung{This section (precisely this chapter) requires multiple revisions!! I tried to fill out this part as soon as possible 
to have SOMETHING!!!!}


The purpose of building a framework for multithreaded linking is similar to 
the that of our multicore part,
provide the thread-local interface 
by hiding other threads' behavior. 
It, however, differs from multicore linking part, of which the  context and the configuration 
are simpler than those of multithreaded linking part. 
When looking at the multithreaded linking, 
systems already has to provide 
scheduling related primitives (\ie, yield, sleep, create)
as well as other system services 
that are necessary to implement those primitives. 
For example, 
thread (process) creation usually related to the 
resource management,
such as the maximum number of memories.
In addition, 
some memory areas for multiple threads should be 
mutually exclusive from others. 
In addition to that, 
several private state,
which is hidden from other threads,
has to be properly initialized 
according to other thread.
Those initialized values
 are usually determined by their parents, 
 and they are dynamically allocated.

To sum up, 
Multithreaded linking poses 
multiple challenges based on the environment for the multithreaded programs.
We assume that 
there are arbitrary active or available thread set on the CPU, 
Which does not need to be a sequence of consecutive numbers.
For example, when the maximum range of
the thread number in the system i from 0 to 1023, 
then, CPU 1 may be able to run threads associated the numbers that can be divided by 8. 
Each thread associated with the 
designated thread ID. 
It is possible for threads to use the same identifier again, but 
we avoid this re-usage of the same number because it increase complexity without a huge benefits. 
We, however, assume that the thread set is set of non-consecutive unbounded numbers,
which gives a huge freedom. 
In addition to that, 
we allow dynamic initial states for each thread. 
For example, each thread has maximum capacity of page numbers that they have get is 
assigned by its parent. 
Simpler systems may not allow this dynamic allocation for each thread,
but many systems assign appropriate initial state for each thread 
according to the information when the thread has been spawned.

Using those environment, 
our purpose multthreaded linking is listed as follows:
1) hide context switching between threads; 
2) construct the environmental context for each thread and show the relationship between the 
CPU-local machine evaluation with the each thread's evaluation based on the environmental context;
3) prove compositionalilty of multiple per-thread machines; and 
4) provide the same (almost similar) interface for per-thread layers 
for users to build layers on top of thread local machines. 
\jieung{need to explain more about those challenge}
\jieung{Expecially about context switching - page 20 of concurrent linking slide}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth, page=21]{figs/conlink/concurrent_linking}
\jieung{Need to redraw this figure to add only one env-context for thread local layers}
\caption{Multithreaded Linking Structures.}
\label{fig:chapter:linking:multithreaded-linking-structure}
\end{center}
\end{figure}
Similar to the multicore linking, 
those challenges are hard for us to solve within a single step. 
In this sense, 
we also introduce multiple intermediate languages
in Figure~\ref{fig:chapter:linking:multithreaded-linking-structure}. 


The bottom level of mulithreaded linking is 
a layer that contains scheduling primitives, thread sleep and yield.
Formally, 
when the layer $\CSched[cpuid, \oracle_{cpuid}] = (\Layer_{\CSched}, \ignorechar, \ignorechar)$, which is parameterized by the focused CPU ID ($cpuid$) and the proper environmental context ($\oracle_{cpuid}$), 
the layer should satisfies 
$(\threadyieldfunc, \ignorechar) \in \Layer_{\CSched}$ as well as 
$(\threadsleepfunc, \ignorechar) \in \Layer_{\CSched}$. 
This is the minimum requirement for the multithreaded linking proofs. 
Consequently, 
the top-most layer in the thread local machine
has to include those two primitives. 
Formally, 
when the layer $\TSched[thrd, \oracle_{thrd}] = (\Layer_{\TSched}, \ignorechar, \ignorechar)$, which is parameterized by the focused thread identifier ($thrd$) and the proper environmental context ($\oracle_{thrd}$), 
the layer should satisfies 
$(\threadyieldfunc, \ignorechar) \in \Layer_{\TSched}$ as well as 
$(\threadsleepfunc, \ignorechar) \in \Layer_{\TSched}$. 
They, however, differs from 
the same primitives 
in  $\CSched$ in terms of their behavior. 
The CPU local machine that uses $\CSched[cpuid, \oracle_{cpuid}]$  as its parameter 
uses the state which is defined as
a tuple, 
$(rs, m, a, l)$,
which represents 
a register set, a memory, an abstract state, and a log.
Among them, a register set, a memory, and an abstract state are private datum for CPU local machines. 
In this sense, scheduling primitives, including $\threadyieldfunc$ and $\threadsleepfunc$,
modifies them during their transitions. 
Especially, they requires the change in the register values,  context switching,
which stores the current thread's register value 
and restore the register values for the next scheduled thread. 

To introduce a thread local interface while keeping a capability of 
using the same compiler with the CPU local interface ($\compcertx$, 
thread local layers also has to use the same state definition and the machine model 
with the CPU local interface, which is $(rs, m, a, l)$.
The private state of it, however, 
is only related to the thread. 
In this sense, 
behaviors of scheduling primitives remain those thread local states as they are in their machines. 
The only element that can be changed  in the thread local machine during the scheduling primitives 
is the shared log $l$. 

To hide them, 
we introduced multiple intermediate languages 
that has a transition rules of those primitives explicitly, and the 
the layer that are used as an argument of 
intermediate languages ($\TLink$) is introduced which does not contain those scheduling primitives in it. 

These differences are also applied to 
other primitives in $\CSched$ and $\TSched$.
Some primitives in $\CSched$ accesses CPU-local data, but some of them 
are not always easy to divide them clearly for each thread. 
Pages in the memory, for example, 
can be dynamicaly allocated, thus 
each thread does not know exactly 
which pages are associated with the thread statically
(\ie, it is possible for us to assume that each thread statically 
reserve the number of pages as well as 
the actual page number, but this is far from usual design principal.)
With the given concrete layer definitions for 
all $\CSched$, $\TLink$, as well as $\TSched$,
providing the detailed 
way to divide the CPU-local private states into multiple thread local private states 
may be possible. 
We, however, divide this process 
as two parts, the connection between machine models based on the configurations and abstract relations, 
and introduce the instances of them to link the concrete CPU local machine with 
the thread local machine. 
To make it general as much as possible, 
we have defined two abstract relations, 
which is $AbsRelC$ and $AbsRelT$ in the figure with will work 
with the arbitrary layers for each machines as well as the thread configuration $C$. 


\input{thesiscontents/conlink/multithreaded/mtlinkoverview}
\input{thesiscontents/conlink/multithreaded/singlecoremachine}
\input{thesiscontents/conlink/multithreaded/mtenvconf}
\input{thesiscontents/conlink/multithreaded/mtmachinemodel}
\input{thesiscontents/conlink/multithreaded/stmachinemodel}
\input{thesiscontents/conlink/multithreaded/connectingmtlink}
