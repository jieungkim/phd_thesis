

\subsubsection{AbstractRel}

This provides the relation bewteen PHBThread layer runs with EAsm and PBThread layer runs with LAsm. 

\begin{lstlisting}[language=C]
    Definition pperm_inject (ha_ppermtable : PPermT) (la_ppermtable : PPermT) : Prop := 
      forall i, 
        match ZMap.get i ha_ppermtable, ZMap.get i la_ppermtable with 
          | PGUndef, _ => True
          | PGAlloc, PGAlloc => True 
          | PGHide ho, PGHide lo => ho = lo
          | _, _ => False
        end.
    
    Definition B_GetContainerUsed' (tid: Z) (cid : Z) (big_log: BigLogType) : bool :=
      match big_log with 
      | BigUndef => false
      | BigDef l => B_GetContainerUsed tid cid l
      end.

    Definition relate_AC_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
                        (* I can use the precise definition which I commented out instead of the version 
                                      that contains the True value. But, if I do that, I have to redefine init_dproc
                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
                                      So, for the simplicity, I will use the current version *)
                        if zeq id main_thread 
                        then AC pd =  ZMap.get id (AbstractDataType.AC ladt)
                        else if zlt_lt TOTAL_CPU id num_proc then AC pd = ZMap.get id (AbstractDataType.AC ladt) 
                             else True
                      (* The following things are for thread spawn related_RData.
                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
                                    However, instead of using dummy True, I decided to add the precise value 
                                    to handle the case. This should be much better then the dummy True *)
                      else if zlt_lt TOTAL_CPU id num_proc then AC pd = AC (thread_init_dproc id) else True
      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
      (* I can use the precise definition which I commented out instead of the version that contains the True value.
                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
                    and init_dproc in EAsm and TAsm.
                    So, for the simplicity, I will use the current version *)
      else if zeq id main_thread 
           then (AC pd) = ZMap.get id (AbstractDataType.AC ladt) 
           else if zlt_lt TOTAL_CPU id num_proc then AC pd =  AC (thread_init_dproc id) else True.

    (*
    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
      (forall i, 0 <= i < UCTXT_SIZE -> 
                 i <> U_EIP ->
                 ZMap.get i huctx = ZMap.get i luctx) /\ 
      (exists v, ZMap.get U_EIP luctx = v).
    *)
      
    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
      match ZMap.get U_EIP huctx with 
        | Vint i => if Int.eq i (Int.repr 0) then 
                      (forall i, 0 <= i < UCTXT_SIZE -> 
                                 i <> U_EIP ->
                                 ZMap.get i huctx = ZMap.get i luctx) /\ 
                      (exists v, ZMap.get U_EIP luctx = v)
                    else huctx = luctx
        | Vundef => (forall i, 0 <= i < UCTXT_SIZE -> 
                               i <> U_EIP ->
                               ZMap.get i huctx = ZMap.get i luctx) /\ 
                    (exists v, ZMap.get U_EIP luctx = v)
        | _ => False
      end.

    Definition relate_uctxt_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
                        (* I can use the precise definition which I commented out instead of the version 
                                      that contains the True value. But, if I do that, I have to redefine init_dproc
                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
                                      So, for the simplicity, I will use the current version *)
                        if zeq id main_thread 
                        then uctxt_bieq (uctxt pd) (ZMap.get id (AbstractDataType.uctxt ladt))
                        (* then uctxt pd =  ZMap.get id (AbstractDataType.uctxt ladt) *)
                        else if zlt_lt TOTAL_CPU id num_proc then  uctxt_bieq (uctxt pd) 
                                                                              (ZMap.get id (AbstractDataType.uctxt ladt))
                             else True
                      (* The following things are for thread spawn related_RData.
                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
                                    However, instead of using dummy True, I decided to add the precise value 
                                    to handle the case. This should be much better then the dummy True *)
                      else if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True
                      (* else  if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True *)
      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
      (* I can use the precise definition which I commented out instead of the version that contains the True value.
                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
                    and init_dproc in EAsm and TAsm.
                    So, for the simplicity, I will use the current version *)
      else if zeq id main_thread 
           then  uctxt pd = ZMap.get id (AbstractDataType.uctxt ladt)
           else if zlt_lt TOTAL_CPU id num_proc then  uctxt pd = uctxt (thread_init_dproc id) else True.

    Definition relate_SyncChanPool_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
      if (init sd) then 
        (* check only and only if the current thread is protected by acquire_lock *)
        (* it will consider the current channel / do not care about other channels *)
        if B_inLock (CPU_ID sd) (big_log sd) then 
          if zeq id (proc_id sd) 
          then syncchpool pd = AbstractDataType.syncchpool ladt
          else True (* don't care about other's syncpool *) 
        else match (big_log sd) with 
               | BigDef nil => (* if we never call lock at all the value should be initialized value
                                                      - need this one in sched_init function proof *)
                 syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef)
               | BigDef _ => True
               | _ => False (* if the system is initialized, this case should not happen *)
             end
      (* initial state need to be matched for all threads *)
      (* case analysis is required for sched_init  - look at the difference between 
         main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
      else if zeq id main_thread  
           then syncchpool pd = (ZMap.init SyncChanUndef)
           else syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef).

    Record E2PBThreadGenPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
           (ladt : AbstractDataType.RData) :=
      mkE2PBThreadGenPerDInv {

          dirty_page_per_thread_inv:
            forall res i, ZMap.get i (pperm pd) = PGUndef -> ZMap.get res (HP pd) = ZMap.get res (FlatMem.free_page i (HP pd))
          
        }.

    Record relate_RData_per_pd  (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
           (ladt : AbstractDataType.RData) :=
      mkrelate_RData_per_pd {
          (* for shared data parts - it's duplicated, but ok *)
          vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
          CR3_re: CR3 sd = AbstractDataType.CR3 ladt;
          pg_re:  pg sd =  AbstractDataType.pg ladt;
          nps_re: nps sd = AbstractDataType.nps ladt;
          init_re: init sd = AbstractDataType.init ladt;
          lock_re: lock sd = AbstractDataType.lock ladt;
          
          CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
          cid_re: if init sd
                  then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
                  else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
                       (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
                        then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
                        else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
          idpde_re: idpde sd = AbstractDataType.idpde ladt;
          kctxt_re: kctxt_val= ZMap.get id (AbstractDataType.kctxt ladt);
          big_log_re: big_log sd = AbstractDataType.big_log ladt;
          big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;

          (* flatmem - may need an extra relation to prove the equality for load, store, and copy. 
                     - See E2PBThreadGenDef.v file *)
          (* flatmem_re: FlatMem.flatmem_inj (HP pd) (AbstractDataType.HP ladt); *)
          flatmem_re: forall v ofs TY,
                        ZMap.get ((v * PgSize + ofs mod PgSize) / PgSize) (pperm pd) = PGAlloc ->
                        ofs mod 4096 <= 4096 - size_chunk TY ->
                        (align_chunk TY | ofs mod PgSize) -> 
                        FlatMem.load TY (HP pd) (v * PgSize + ofs mod PgSize) =
                        FlatMem.load TY (AbstractDataType.HP ladt) (v * PgSize + ofs mod PgSize);
          
          (* except the running thread, all other threads should have the default value 
           - necessary for yield and sleep case *)
          ikern_re: if zeq id (proc_id sd) then ikern pd = AbstractDataType.ikern ladt else ikern pd = true;

          (* except the running thread, all other threads should have the default value 
           - necessary for yield and sleep case *)
          ihost_re: if zeq id (proc_id sd) then ihost pd = AbstractDataType.ihost ladt else ihost pd = true;
          
          (* main_thread is (CPU_ID adt + 1) now. The constraint - 
             all ID in the full_thread_list should satisfy the following constraint:
             (forall l, proc_id (uRData l) /in full_thread_list) /\ 
             (forall i, i /in full_thread_list -> i = i = main_thread \/ TOTAL_CPU < i < num_proc) *)
          AC_re: relate_AC_per_pd  id sd pd ladt;
           
          (* we assume that ti will be setted as a default value when the kernel 
             exit to the user process (by trapout) - for the precise implementation, we may need to 
             change the definition of trapout? *)
          ti_re: if zeq id (proc_id sd) then ti pd = AbstractDataType.ti ladt else  ti pd = init_trap_info;

          (* may need an extra relationship in here for mutex property? *)
          pperm_re: pperm_inject (pperm pd) (AbstractDataType.pperm ladt);
          
          (* case analysis is required for sched_init  - look at the difference between 
             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
          PT_re: if init sd 
                 then if zeq id (proc_id sd) then PT pd = AbstractDataType.PT ladt else PT pd = 0
                 else if zeq id main_thread then PT pd = -1 else PT pd = 0;

          (* ptpool initialization is not setting def val for all i. So I will keep the 
             whole ptpool in each pd, but will check each entry of each thread's ptpool for simulation *)
          (* only need to check the ptpool for each thread *)
          (* case analysis is required for sched_init  - look at the difference between 
             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
          (* main_thread is 0 now, but need to change it later as (CPU_ID adt) + 1 *)
          ptp_re: if init sd 
                  then ZMap.get id (ptpool pd) = ZMap.get id (AbstractDataType.ptpool ladt)
                  else if zeq id main_thread then ptpool pd = (AbstractDataType.ptpool ladt) 
                       else ptpool pd = CalRealPT.real_pt (AbstractDataType.ptpool ladt);

          (* except the running thread, all other threads should have the default value  - necessary for yield and sleep case *)
          ipt_re: if zeq id (proc_id sd) then ipt pd = AbstractDataType.ipt ladt else ipt pd = true;

          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)
          intr_flag_re: if zeq id (proc_id sd) then intr_flag pd = AbstractDataType.intr_flag ladt else intr_flag pd = true;

          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)          
          in_intr_re: if zeq id (proc_id sd) then in_intr pd = AbstractDataType.in_intr ladt else in_intr pd = false;

          (* from com1_re to drv_serial_re ----
             for the simplicity, I assume that main_thread = dev_handling_cid. 
             If we change the number of main_thread as (CPU_ID adt) + 1, then, this assumption doesn't 
             geneate any nonsensical cases. I can remove this assumption (main_thread = dev_handling_cid), 
             but, then, I need an another case analysis for init_dproc in (EAsm.v and TAsm.v files) 
             to handle them *)
          com1_re: if zeq id dev_handling_cid then com1 pd = AbstractDataType.com1 ladt else True;

          console_re: if zeq id dev_handling_cid then console pd = AbstractDataType.console ladt else True;

          console_concrete_re: if zeq id dev_handling_cid 
                               then console_concrete pd = AbstractDataType.console_concrete ladt else True;

          ioapic_re: if zeq id dev_handling_cid 
                     then ioapic pd = AbstractDataType.ioapic ladt else True;

          lapic_re: if zeq id dev_handling_cid 
                    then lapic pd = AbstractDataType.lapic ladt else True;

          curr_intr_num_re: if zeq id dev_handling_cid 
                            then curr_intr_num pd = AbstractDataType.curr_intr_num ladt else True;

          drv_serial_re: if zeq id dev_handling_cid 
                         then drv_serial pd = AbstractDataType.drv_serial ladt else True;

          (* concept: ok. I'll not care the actual match state of syncchpool except the case 
             when we call acquire_lock, which we have to match the syncchpool with thread-machine with 
             CPU-machine *)
          (* we can optimize this definition 
             - e.g. we can check only one syncchan value related to the lock id. Then, I may be able to 
               remove some definitions. 
           *)
          syncchpool_re: relate_SyncChanPool_per_pd id sd pd ladt;
          uctxt_re: relate_uctxt_per_pd id sd pd ladt;

          ept_re: if zeq id vm_handling_cid
                  then ept pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.ept ladt)
                  else True;
          vmcs_re: if zeq id vm_handling_cid
                   then vmcs pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmcs ladt)
                   else True;
          vmx_re: if zeq id vm_handling_cid
                  then vmx pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmx ladt)
                  else True;

          inv_re: E2PBThreadGenPerDInv id kctxt_val sd pd ladt
        }.

    Record E2PBThreadGenEmptyPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (ladt : AbstractDataType.RData) :=
      mkE2PBThreadGenEmptyPerDInv {

        }.


    Record E2PBThreadGenSharedDInv (kctxt_pool : KContextPool) (sd : sharedData) (ladt : AbstractDataType.RData) :=
      mkE2PBThreadGenSharedDInv {

          dirty_page_shared_inv:
            forall res i, ZMap.get i (AbstractDataType.pperm ladt) = PGUndef ->
                          ZMap.get res (AbstractDataType.HP ladt) = ZMap.get res (FlatMem.free_page i (AbstractDataType.HP ladt));
          
          init_big_log_inv: init sd = false -> big_log sd = BigUndef;
          init_pperm_inv: init sd = false -> AbstractDataType.pperm ladt = ZMap.init PGUndef;
          init_uctxt_inv: init sd = false -> AbstractDataType.uctxt ladt = ZMap.init (ZMap.init Vundef);
         
          syncchpool_inv:  
              BigLogThreadConfigFunction.B_inLock (CPU_ID sd) (big_log sd) = false ->
              BigLogThreadConfigFunction.B_GetlastPush (CPU_ID sd) (big_log sd) 
              = AbstractDataType.syncchpool ladt;
          
          container_used_inv :
            forall tid, In tid full_thread_list -> B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) 
                                                   = cused (ZMap.get tid (AbstractDataType.AC ladt));

          uctxt_used_inv :
            forall tid, B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) = false ->
                        ZMap.get tid (AbstractDataType.uctxt ladt) = ZMap.init Vundef;

          
          valid_AT_log_inv: valid_AT_log_type_B (big_log sd); 
          valid_TCB_log_inv: valid_TCB_log_type_B (big_log sd);
          big_oracle_inv: valid_big_oracle (big_oracle sd);

          valid_B_Cal_AT_log_inv: forall i l atable, 
                                    ZMap.get i (AbstractDataType.pperm ladt) <> PGUndef ->
                                    (AbstractDataType.big_log ladt) = BigDef l ->
                                    B_CalAT_log_real l = Some atable ->
                                    ZMap.get i atable = ATValid true ATNorm
        }.

    Record E2PBThreadGenSharedMemInv (pdpool: ZMap.t (option privData)) :=
      mkE2PBThreadGenSharedMemInv {
          
          pperm_disjoint: 
            forall i j pd pd',
              i <> j ->
              ZMap.get i pdpool = Some pd ->
              ZMap.get j pdpool = Some pd' ->
              (forall j, ZMap.get j (pperm pd) <> PGUndef ->
                         ZMap.get j (pperm pd')= PGUndef)
        }.

    Record relate_RData (kctxt_pool : KContextPool)  (sd : sharedData)  (pdpool: ZMap.t (option privData))
           (ladt : AbstractDataType.RData) :=
      mkrelate_RData {
          
          sh_vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
          sh_CR3_re: CR3 sd= AbstractDataType.CR3 ladt;
          sh_pg_re:  pg sd =  AbstractDataType.pg ladt;
          sh_nps_re: nps sd = AbstractDataType.nps ladt;
          sh_init_re: init sd = AbstractDataType.init ladt;
          sh_lock_re: lock sd = AbstractDataType.lock ladt;
          
          sh_CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
          sh_cid_re: if init sd
                     then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
                     else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
                          (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
                           then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
                           else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
          sh_idpde_re: idpde sd = AbstractDataType.idpde ladt;
          sh_kctxt_re: kctxt_pool = (AbstractDataType.kctxt ladt);
          sh_big_log_re: big_log sd = AbstractDataType.big_log ladt;
          sh_big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;
          
          per_data_re: forall i,
                         match ZMap.get i pdpool with 
                           | Some pd => relate_RData_per_pd i (ZMap.get i kctxt_pool) sd pd ladt
                           | _ => E2PBThreadGenEmptyPerDInv i (ZMap.get i kctxt_pool)  sd ladt
                         end;
          
          sh_shared_inv_re: E2PBThreadGenSharedDInv kctxt_pool sd ladt;
          
          sh_mem_inv_re: E2PBThreadGenSharedMemInv pdpool 
                                                    
        }.
\end{lstlisting}
