\subsection{Concrete Definitions for Multithreaded Linking Framework} 
\label{chapter:certikos:phbthread}

Building intermediate layers to facilitates our multithreaded linking framework 
for $\certikos$ first requires the concrete definitions 
that the layer relies on, 
thread configurations as well as auxiliary functions in Section~\ref{chapter:linking:subsec:multithreaded-machine-model}.

\begin{figure}
\begin{lstlisting}[language=C]
Record RData := mkRData {
  CPU_ID: Z; // current CPU_ID 
  cid: ZMap.t Z; // current thread id
  big_log: BigLogType; // global log
  init: bool; // the logical flag about initialization
  AC : Container; // container tree for all agents
  pperm: PPermT; // physical page permission table 
  PT: Z; // the current page table index
  ptpool: PMapPool; // page table pool
  uctxt : UCtxt; // user context of the thread
  syncchpool : SyncChanPool; // the channel pool for synchronous IPC
 <@$\cdots$@> }.
\end{lstlisting}
\caption{Abstract Data for  $\codeinmath{PBThrd}$ Layer Interface.}
\label{fig:chapter:certikos:abstract-data-for-pbthread-layer}
\end{figure}



\subsubsection{Thread Configurations and Auxiliary Functions}

\begin{figure}
\begin{lstlisting}[language=C]
// the type of shared data by all threads
Record sharedData := mk_sharedData {
  CPU_ID: Z; // current CPU_ID 
  cid: ZMap.t Z; // current thread id
  big_log: BigLogType; // global log
  init: bool; // the logical flag about initialization
  <@$\cdots$@> }.
  
// the type of thread private data
Record privData := mk_privData {
  AC : Container; // container tree for all agents
  pperm: PPermT; // physical page permission table 
  PT: Z; // the current page table index
  ptpool: PMapPool; // page table pool
  uctxt : UCtxt; // user context of the thread
  syncchpool : SyncChanPool; // the channel pool for synchronous IPC
  <@$\cdots$@> }.

// the instance of SingleData in CertiKOS
Global Instance single_data : SingleData := {
  dshare := sharedData;  // instance of shared abstract data to use the framework
  proc_id s :=  ZMap.get (CPU_ID s) (cid s);
  processor_id s := CPU_ID s;
  dproc := privData; // instance of shared abstract data to use the framework
  <@$\cdots$@> }.
\end{lstlisting}
\caption{Concrete Definition of $\codeinmath{SingleData}$ in Figure~\ref{fig:chapter:linking:thread-configurations}}

\label{fig:chapter:certikos:single-data-of-multithreaded-linking-certikos}
\end{figure}

Providing abstract data types in  Figure~\ref{fig:chapter:linking:thread-configurations} is an initial step 
to connect our multithreaded linking framework with $\certikos$,
and it requires us to divide the abstract data in $\certikos$.
The part of abstract data ($\codeinmath{RData}$) in $\codeinmath{PBThrd}$ 
is define in Figure~\ref{fig:chapter:certikos:abstract-data-for-pbthread-layer}, 
which contains the field for a container tree, a page table pool, a global log, a user context, \etc.
We explain several parts of them in Section~\ref{chapter:certikos:sec:per-cpu-modules}. 
Dividing the abstract data into two parts by distinguishing 
each field into either a shard data or a private data 
requires a full understanding of the behavior of all primitives in $\certikos$;
thus we faced multiple trial-and-error.
The parts of proper division on the abstract state are in Figure~\ref{fig:chapter:certikos:single-data-of-multithreaded-linking-certikos},
which implies that 
all threads share the information about the current CPU ID, thread ID, the global log for the shared state,
 as well as the status of initialization of the current system. 
 They, however, have separate data structures 
 for containers, permission tables for all pages in the memory, 
 their page map table, user contexts, and the information of the synchronization pool for IPC.
 It implies that 
 each thread cannot look up the global permission table (\ie, that tells which pages are already allocated to some threads),
 other threads' page map table, or the communication information (IPC channel) that is not associated with the thread.

\begin{figure}
\begin{lstlisting}[language=C, deletekeywords={int}]
// auxiliary function to calculate the PC for the specific thread
Definition prim_thread_init_pc {F V} (ge : Genv.t F V) (name : ident) 
  (args : list lval): option val :=
  if peq name proc_create then 
     // check the existence of the main function for the thread's context
     match Genv.find_symbol ge START_USER_FUN_LOC with
     | Some b' => Some (Vptr b' Int.zero) | _ => None
     end  else None.

// assign the proper value for the initial state (for thread's private abstract data)
Definition cal_init_dproc (pv_adt : dproc) (parent: Z) (q: Z) (buc : block) 
  (uc_ofs : int): dproc:= 
  let uctx := <@$\cdots$@> in 
  (pv_adt {pv_AC: (mkContainer q 0 parent nil true)} {pv_uctxt: uctx}).

// search the initial log to find out the proper spawn event for the focused thread
Fixpoint thread_init_dproc_loop (curid: Z) (l : Log) : dproc :=
  match l with 
  | ev::l_tl => match ev with 
    <@$\cdots$@>
    if peq name proc_create
      then match largs with
        | (Lint elf_id)::(Lptr buc uc_ofs)::(Lint q)::nil
           => (cal_init_dproc nomain_init_priv_adt id (Int. unsigned q) buc uc_ofs)
      <@$\cdots$@>

// top-level function to calculate the initial state of the focused threads
Definition thread_init_dproc (curid: Z) :  dproc :=
  // if it is a main thread, we use the fixed value (the initial state of the system)
  if zeq curid main_thread then main_init_dproc 
     // call to function to dynamically allocated the initial state
     else thread_init_dproc_loop curid  init_log.
     
// the function to check whether the primitive accesses the shared state or not;
// thus has to trigger an event for the call or not 
Definition has_event (name : ident) :=
  if peq name palloc then true else if peq name pt_resv then true else
     if peq name proc_create then true else <@$\cdots$@>
 
// the instance of SingleOracle in CertiKOS 
Program Instance s_oracle_prf : SingleOracle <@$\cdots$@>:= { 
  has_event := has_event;
  update := update;
  thread_init_dproc := thread_init_dproc;
  prim_thread_init_pc := @prim_thread_init_pc
  <@$\cdots$@> }.
\end{lstlisting}
\caption{Concrete Definition of $\codeinmath{SingleOracle}$ in Figure~\ref{fig:chapter:conlink:multithreaded-linking-aux-functions}}
\label{fig:chapter:certikos:auxfunctions-of-multithreaded-linking-certikos}
\end{figure}

All auxiliary functions in Figure~\ref{fig:chapter:conlink:multithreaded-linking-aux-functions} are also have to be defined 
properly, and Figure~\ref{fig:chapter:certikos:auxfunctions-of-multithreaded-linking-certikos} shows
those function definitions in $\certikos$. 
One of key purposes of providing them is to assign an adequate initial value and state to each thread.
The \lstinline$prim_thread_init_pc$ provides the proper initial program counter for each thread, 
when assuming that there exists a proper function pointer \lstinline$START_USER_FUN_LOC $ 
of the main function for the thread.
Multiple functions are also presented to define \lstinline$thread_init_dproc$, the function that calculates the initial private state for each thread. 
It searches the initial log of the thread, and 
use the information of the process creation event  for the thread via
calling \lstinline$cal_init_dproc$.
The behavior of \lstinline$cal_init_dproc$ regarding updating the container information for the newly created thread is similar to the behavior 
of process create function specification in $\codeinmath{PBThrd}$ (\ie, 
see line 11
Figure~\ref{fig:chapter:certikos:proc-create-cpu-spec}.)
The \lstinline$has_event$ is associated with the intermediate machine definitions in Section~\ref{chapter:linking:sec:multithreaded-linking}
which checks 
whether the primitive call will update the shared state or not.
For example, $\pallocfunc$, \lstinline$pt_resv$, and \lstinline$proc_create$ has to 
trigger the event during their evaluations since they modify parts of shared states
among threads.



\subsubsection{$\codeinmath{PHBThrd}$ Definition}

%%Our intermediate layer definition has a different state definition (not only for the memory and registers, but also for the abstract data); thus we also provide the 
%%layer that can be used for those intermediate machine models. 
%%In addition to that, our intermediate machine models has explicit 
%%transition rules for yield ans sleep. 
%They are defined in the lanuage level 

\begin{figure}
\begin{lstlisting}[language=C, deletekeywords={int}]
Function single_big_proc_create_spec_share (adt : sharedData) (buc: block) (ofs_uc: int) q
   (child_id : Z) : option (sharedData * Z) :=
   let curid := ZMap.get (CPU_ID adt) (cid adt) in
   let cpu := CPU_ID adt in
   <@$\cdots$@>
    // add the thread spawn event
    let e := TBSHARED (BTDSPAWN curid child_id q ofs buc ofs_uc) in
    let l<@$'$@> := (TBEVENT cpu e) :: l1 in
    // update the global log
    | Some _ => Some (adt {sh_big_log: BigDef l<@$'$@>}, child_id)
   <@$\cdots$@>
      
// PData is a pair of [sharedData] and [privData]
Function single_big_proc_create_spec (d: PData) (b b<@$'$@> buc: block) (ofs_uc: int) (q : Z) 
  : option (PData * Z) :=
  let curid := ZMap.get (CPU_ID (fst d)) (cid (fst d)) in
  let cpu := CPU_ID (fst d) in let c := (AC (snd d)) in
  // assign a new thread ID for the child
  let i :=  curid * max_children + 1 + Z_of_nat (length (cchildren c)) in
  // check the validity of the quota (given as an argument)
  match (zle_le 0 q (cquota c - cusage c), <@$\cdots$@>
  <@$\cdots$@>
  match big_log (fst d) with
  | BigDef l =>
    // adjust the container information for the parent
    let parent := (mkContainer (cquota c) (cusage c + q)
                                                  (cparent c) (i :: cchildren c) (cused c)) in
    // call the specifications that modifies shared states 
    match single_big_proc_create_spec_share (fst d) buc ofs_uc q i with
    | Some (adt<@$'$@>, i<@$'$@>) => Some (adt<@$'$@>, (snd d) {pv_AC: parent}, i) | _ => None
    <@$\cdots$@>       
\end{lstlisting}
\caption{Process Create Primitive Specification in $\codeinmath{PHBThrd}$ (Written in $\coq$.)}
\label{fig:chapter:certikos:proc-create-cpu-spec-phbthred}
\end{figure}

Using the illustrated definitions, we provide the concrete instance of $\TLink$ in our multithreaded linking,
which is layer $\codeinmath{PHBThrd}$. 
It requires a lot of work because of  
$\codeinmath{PHBThrd}$ layer is based on the different state definition with the state that 
$\codeinmath{PBThrd}$, 
but $\codeinmath{PHBThrd}$ has to contain all primitives (except scheduling primitives)
that $\codeinmath{PBThrd}$ contains.
In this sense, 
we re-define specifications for all primitives to build $\codeinmath{PHBThrd}$; thus it explores the size of the code in the multithreaded linking part of $\certikos$.
Figure~\ref{fig:chapter:certikos:proc-create-cpu-spec-phbthred} shows the specification for the process create primitive in $\codeinmath{PHBThrd}$ layer.
When compared to the specification in $\codeinmath{PBThrd}$ in Figure~\ref{fig:chapter:certikos:proc-create-cpu-spec},
 it does not modify the child's local state while it updates the 
 parent's state in a similar way that the specification in $\codeinmath{PBThrd}$ does.
The modification (dynamic initialization) of the child's initial state is a responsibility of the child by using auxiliary functions in Figure~\ref{fig:chapter:certikos:auxfunctions-of-multithreaded-linking-certikos}.
This work requires a lot of work but is scalable.
Adding a primitive in both layers only defines the specifications for the newly added primitive.


\subsubsection{Contextual Refinements}
Contextual refinement between the program with $\codeinmath{PBThrd}$ on $\lasmmach$ and 
 the program with $\codeinmath{PBHThrd}$ on $\easmmach$
 needs to facilitate Lemma~\ref{lemma:chapter:conlink:parallel-composition}, 
 which requires us to instantiate all evidences for elements in $\codeinmath{AbsRelC}$ (\eg, 
 Figure~\ref{fig:chapter:conlink:two-cases-of-abs-rel-c}).
The abstract relation relies on the relation between  \lstinline$EData$ (of $\easmmach$) and \lstinline$RData$ (of $\lasmmach$),
which specifies the relation between a set of thread states and a single per-CPU state. 
Providing the definition is another task that requires enormous efforts 
because it has to reflect how
all primitives and transitions modify all parts of the state.
Figure~\ref{fig:chapter:certikos:absrelc-of-multithreaded-linking-certikos} provides
few interesting parts of  \lstinline$match_EData_RData$, the refinement relation between \lstinline$EData$ and  \lstinline$RData$.
Few cases, such as \lstinline$CPU_ID_re$, which matches the current CPU ID in both parts are trivial and straightforward because of the simple modification on them. 
Others, such as the case for containers, needs complex case analysis based on the system's behavior. 
The \lstinline$relate_AC_per_pd$ shows parts of case analysis,
which distinguishes the case whether the system is initialized or not, whether the thread has been
spawned or not (via calling \lstinline$B_GetContainerUsed id (CPU_ID sd) (big_log sd)$),
as well as whether the thread is the main thread or not.
The refinement relation also states multiple invariant
that each machine has to follow.
For example, \lstinline$pperm_disjoint$ shows
that page permission tables in multiple thread's states are disjoint from others; thus implies
the mutual exclusion of the page allocation in the system. 
With providing this refinement relation,
we give the instance for $\codeinmath{AbsRelC}$ by proving 
that each transition on both machines satisfies the property stated in $\codeinmath{AbsRelC}$,
mainly focused on the case analysis on the primitives in  $\codeinmath{PBThrd}$ and $\codeinmath{PBHThrd}$.
Again, this work requires a lot of work but is scalable.
Adding a primitive in both layers only requires adding an instance of the property for the primitive.
Also, adding an item in the refinement relation,   \lstinline$match_EData_RData$, requires 
us to prove the case for each instance of $\codeinmath{AbsRelC}$, 
which is isolated from showing the evidence for other parts of the refinement relation.

\begin{figure}
\begin{lstlisting}[language=C, morekeywords={Record}]           
Definition relate_AC_per_pd (id : Z) (sd : sharedData) (pd: privData)
  (ladt : RData) :=
  if init sd then if B_GetContainerUsed id (CPU_ID sd) (big_log sd) then 
  // necessary to reflects the correct behaviour of the initialization 
     if zeq id main_thread  then AC pd =  ZMap.get id (AbstractDataType.AC ladt)
        else AC pd = ZMap.get id (AC ladt)  <@$\cdots$@>
    <@$\cdots$@>

// relation between private abstract states for multithreaded machine models and 
// abstract state for per-CPU machine model 
Record relate_RData_per_pd  (id : Z) (kctxt_val : Kctxt) (sd : sharedData) 
  (pd : privData) (ladt : RData) := mkrelate_RData_per_pd {
    AC_re: relate_AC_per_pd  id sd pd ladt;
     <@$\cdots$@> }.  

// relation between abstract states for multithreaded machine models and 
// abstract state for per-CPU machine model 
Record relate_RData (kctxt_pool : KctxtPool)  (sd : sharedData)  
  (pdpool: ZMap.t (option privData)) (ladt : RData) := mkrelate_RData {
  CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
  
  // mutual exclusion property of page allocation table of two thread private states                                       
  per_data_re: forall i,
    match ZMap.get i pdpool with 
    | Some pd => relate_RData_per_pd i (ZMap.get i kctxt_pool) sd pd ladt
    | None => True   
    end;          
                         
  // mutual exclusion property of page allocation table of two thread private states                         
  pperm_disjoint:  forall i j pd1 pd2,  i <> j ->
    ZMap.get i pdpool = Some pd1 -> ZMap.get j pdpool = Some pd2 ->
    (forall k, ZMap.get k (pperm pd1) <> PGUndef -> ZMap.get k (pperm pd2)= PGUndef)
     <@$\cdots$@> }.  
\end{lstlisting}
\caption{Parts of  \lstinline$match_EData_RData$  in $\certikos$.}
\label{fig:chapter:certikos:absrelc-of-multithreaded-linking-certikos}
\end{figure}
 

\begin{figure}
\begin{lstlisting}
Record relate_RData (kctxt_val : KContext) (hadt : RData) (sd : sharedData) (pd : dproc) :=
  mkrelate_RData {
    AC_re: ZMap.get (ZMap.get (CPU_ID hadt) (cid hadt)) (AC hadt) = AC pd;    
    pperm_re: pperm hadt = pperm pd;
    CPU_ID_re: CPU_ID hadt = CPU_ID sd; 
    <@$\cdots$@> }.
\end{lstlisting}
\caption{Parts of  \lstinline$match_dproc_RData$ in $\certikos$.}
\label{fig:chapter:certikos:absrelt-of-multithreaded-linking-certikos}
\end{figure}

 Similarly, 
 Contextual refinement between the program with $\codeinmath{PHBThrd}$ on $\tasmmach$ and 
 the program with $\codeinmath{PHThrd}$ on $\hasmmach$
 needs to facilitate Lemma~\ref{lemma:chapter:conlink:tasm-refines-hasm}.
Providing the instance of $\codeinmath{AbsRelT}$, however, is more straightforward than that for  $\codeinmath{AbsRelC}$;
it again depends on the refinement relation between the state definition of $\tasmmach$ and that of $\hasmmach$,
which is much simpler than providing the refinement relation for  $\codeinmath{AbsRelC}$.
Since the abstract data of $\tasmmach$ only contains one private abstract state ($\codeinmath{dproc}$) and 
a shared abstract state ($\codeinmath{sharedData}$), 
the refinement relation \lstinline$match_dproc_RData$, which is required for us to provide the instance for $\codeinmath{AbsRelT}$,
is merely matching each field in either $\codeinmath{sharedData}$ or $\codeinmath{dproc}$ with
each field in $RData$, the abstract state definition for $\codeinmath{PHThrd}$ on $\hasmmach$.
Figure~\ref{fig:chapter:certikos:absrelt-of-multithreaded-linking-certikos} shows few parts of \lstinline$match_dproc_RData$, especially how we match container information, a page permission table, as well as a current CPU ID in both sides.
With providing this refinement relation,
we again give the instance for $\codeinmath{AbsRelT}$ by proving 
that each transition on both machines satisfies the property stated in $\codeinmath{AbsRelT}$,
mainly focused on the case analysis on the primitives in  $\codeinmath{PHBThrd}$ and $\codeinmath{PHThrd}$.


\jieung{I can add (a little bit formal definition for AbsRelT adn AbsRelC, which shows the type of them (only for proc creates case?)}

%\subsubsection{AbstractRelT}
%
%This provides the relation bewteen PHThread layer runs with Hasm and PHBThread layer runs with TAsm. 
%
%\begin{lstlisting}[language=C]
%
%    Definition combine_data (kctxtOpt : option KContext) (sd : sharedData) (pd: privData) : AbstractDataType.RData :=
%      {|
%        AbstractDataType.CPU_ID:= CPU_ID sd;
%        AbstractDataType.MM:= MM sd;
%        AbstractDataType.MMSize:= MMSize sd;
%        AbstractDataType.vmxinfo:= vmxinfo sd;
%
%        AbstractDataType.CR3:= CR3 sd;
%
%        AbstractDataType.ti:= ti pd;
%
%        AbstractDataType.pg := pg sd;
%        AbstractDataType.ikern:= ikern pd;
%        AbstractDataType.ihost:= ihost pd;
%
%        AbstractDataType.HP:= HP pd;
%
%        AbstractDataType.cid := cid sd;
%        AbstractDataType.multi_log:= ZMap.init MultiUndef;
%        AbstractDataType.multi_oracle:= multi_oracle_init8;
%        AbstractDataType.lock:= lock sd;
%        
%        AbstractDataType.AC:= ZMap.set (ZMap.get (CPU_ID sd) (cid sd)) (AC pd) (ZMap.init Container_unused); 
%
%        AbstractDataType.AT:= (ZMap.init ATUndef);
%        AbstractDataType.ATC:=  (ZMap.init ATCUndef);
%        AbstractDataType.nps:= nps sd;
%        AbstractDataType.init:= init sd;
%        AbstractDataType.pperm:= pperm pd;
%
%        AbstractDataType.PT:= PT pd;
%        AbstractDataType.ptpool:= ptpool pd;
%        AbstractDataType.idpde:= idpde sd;
%        AbstractDataType.ipt:= ipt pd;
%        AbstractDataType.LAT:= ZMap.init LATCUndef;
%        AbstractDataType.smspool:=  ZMap.init (ZMap.init SHRDUndef);
%
%        (* special treatment for kctxt *)
%        AbstractDataType.kctxt:= match kctxtOpt with 
%                                 | Some kctxt_val =>  ZMap.set (ZMap.get (CPU_ID sd) (cid sd)) kctxt_val 
%                                                               (ZMap.init (Pregmap.init Vundef))
%                                 | _ => (ZMap.init (Pregmap.init Vundef))
%                                 end;
%        
%        AbstractDataType.sleeper:= init_sleeper;
%        AbstractDataType.tcb:= ZMap.init TCBUndef;
%        AbstractDataType.tdq:= ZMap.init TDQUndef;
%        AbstractDataType.abtcb:= ZMap.init AbTCBUndef;
%        AbstractDataType.abq:=  ZMap.init AbQUndef;
%        AbstractDataType.syncchpool:= syncchpool pd;
%        AbstractDataType.buffer:= buffer pd;
%        
%        AbstractDataType.big_log:= big_log sd;
%        AbstractDataType.big_oracle:= big_oracle sd;
%        
%        AbstractDataType.uctxt:= (ZMap.set (ZMap.get (CPU_ID sd) (cid sd)) (uctxt pd)  (ZMap.init (ZMap.init Vundef)));
%        
%        AbstractDataType.ept:= (ZMap.set (CPU_ID sd) (ept pd) (ZMap.init (ZMap.init EPML4EUndef)));
%        
%        AbstractDataType.vmcs := (ZMap.set (CPU_ID sd) (vmcs pd) 
%                                           (ZMap.init (VMCSValid Vzero Vzero (ZMap.init Vundef))));
%        
%        AbstractDataType.vmx := (ZMap.set (CPU_ID sd) (vmx pd) (ZMap.init (ZMap.init Vundef)));
%
%        AbstractDataType.ts:= 0;
%
%        AbstractDataType.com1:= com1 pd;
%        AbstractDataType.drv_serial:= drv_serial pd;
%        AbstractDataType.console_concrete:= console_concrete pd;
%        AbstractDataType.console:= console pd;
%        
%        AbstractDataType.ioapic:= ioapic pd;
%        AbstractDataType.lapic:= lapic pd; 
%        AbstractDataType.tf:= tf pd;
%        AbstractDataType.tf_reg:= tf_reg pd;
%        AbstractDataType.curr_intr_num:= curr_intr_num pd;
%        AbstractDataType.intr_flag:= intr_flag pd;
%        AbstractDataType.saved_intr_flags:= saved_intr_flags pd;
%
%        AbstractDataType.in_intr:= in_intr pd;
%        AbstractDataType.i_dev_serial:= i_dev_serial pd;
%
%        AbstractDataType.kbd:= kbd_init;
%        AbstractDataType.kbd_drv:= kbd_drv_init
%      |}.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%
%  Section MATCH.
%    Set Printing All.
%
%    Record PHThread2TGenInv (kctxt_val : KContext) (hadt : AbstractDataType.RData) (l : Log) (pd : dproc) :=
%      { 
%        CPU_ID_inv: (AbstractDataType.CPU_ID hadt) = GlobalOracle.current_CPU_ID /\
%                    CPU_ID (update init_shared_adt l) = GlobalOracle.current_CPU_ID;
%        
%        valid_big_oracle_inv: valid_big_oracle (AbstractDataType.big_oracle hadt) /\
%                              valid_big_oracle (big_oracle (update init_shared_adt l))
%      }.
%    
%    Record relate_RData (kctxt_val : KContext) (hadt : AbstractDataType.RData) (l : Log) (pd : dproc) :=
%        mkrelate_RData {
%            flatmem_re: (AbstractDataType.HP hadt) = (HP pd);
%            vmxinfo_re: AbstractDataType.vmxinfo hadt = vmxinfo (update init_shared_adt l);
%            CR3_re:  AbstractDataType.CR3 hadt = CR3 (update init_shared_adt l);
%            ikern_re: AbstractDataType.ikern hadt = ikern pd;
%            pg_re: AbstractDataType.pg hadt = pg (update init_shared_adt l);
%            ihost_re: AbstractDataType.ihost hadt = ihost pd;
%            AC_re: ZMap.get (ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt))
%                            (AbstractDataType.AC hadt) = AC pd;
%            ti_re: AbstractDataType.ti hadt = ti pd;
%            
%            nps_re: AbstractDataType.nps hadt = nps (update init_shared_adt l);
%            init_re: AbstractDataType.init hadt = init (update init_shared_adt l);
%
%            pperm_re: AbstractDataType.pperm hadt = pperm pd;
%            PT_re: AbstractDataType.PT hadt = PT pd;
%            ptp_re: AbstractDataType.ptpool hadt = ptpool pd;
%            idpde_re: AbstractDataType.idpde hadt = idpde (update init_shared_adt l);
%            ipt_re: AbstractDataType.ipt hadt = ipt pd;
%
%            CPU_ID_re: AbstractDataType.CPU_ID hadt = CPU_ID (update init_shared_adt l);
%            cid_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt)
%                    = ZMap.get (CPU_ID (update init_shared_adt l)) (cid (update init_shared_adt l));
%            lock_re: AbstractDataType.lock hadt = lock (update init_shared_adt l);
%
%            com1_re: AbstractDataType.com1 hadt = com1 pd;
%            console_re: AbstractDataType.console hadt = console pd;
%            console_concrete_re: AbstractDataType.console_concrete hadt = console_concrete pd;
%            ioapic_re: AbstractDataType.ioapic hadt = ioapic pd;
%            lapic_re: AbstractDataType.lapic hadt = lapic pd;
%            intr_flag_re: AbstractDataType.intr_flag hadt = intr_flag pd;
%            curr_intr_num_re: AbstractDataType.curr_intr_num hadt = curr_intr_num pd;
%            in_intr_re: AbstractDataType.in_intr hadt = in_intr pd;
%            drv_serial_re: AbstractDataType.drv_serial hadt = drv_serial pd;
%
%            kctxt_re: ZMap.get (ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt)) 
%                               (AbstractDataType.kctxt hadt) = kctxt_val;
%            uctxt_re: ZMap.get (ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt))
%                               (AbstractDataType.uctxt hadt) = uctxt pd;
%
%            syncchpool_re: AbstractDataType.syncchpool hadt = syncchpool pd;
%
%            big_log_re: AbstractDataType.big_log hadt = big_log (update init_shared_adt l);
%            big_oracle_re: AbstractDataType.big_oracle hadt = big_oracle (update init_shared_adt l);
%            
%            ept_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.ept hadt) = ept pd;
%            vmcs_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.vmcs hadt) = vmcs pd;
%            vmx_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.vmx hadt) = vmx pd;
%            
%            inv_re: PHThread2TGenInv kctxt_val hadt l pd
%          }.
%                                                       
%  End MATCH.
%
%\end{lstlisting}


%\begin{lstlisting}[language=C]
%  Record sharedData :=
%    mk_sharedData {
%        CPU_ID: Z; (**r current CPU_ID *)
%        MM: MMTable; (**r table of the physical memory's information*)
%        MMSize: Z; (**r size of MMTable*)
%        vmxinfo: VMXInfo; (**r information of vmx*)
%        CR3: globalpointer; (**r abstract of CR3, stores the pointer to page table*)
%        pg: bool; (**r abstract of CR0, indicates whether the paging is enabled or not*)
%        cid: ZMap.t Z; (**r current thread id*)
%        nps: Z; (**r number of the pages*)
%        init: bool; (**r pure logic flag, show whether the initialization at this layer has been called or not*)
%        idpde: IDPDE; (**r shared identity maps *)
%        big_log: BigLogType;
%        big_oracle: BigOracle
%      }.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%  Record privData :=
%    mk_privData {
%        ti: trapinfo; (**r abstract of CR2, stores the address where page fault happens*)
%
%        ikern: bool; (**r pure logic flag, shows whether it's in kernel mode or not*)
%        ihost: bool; (**r logic flag, shows whether it's in the host mode or not*)         
%
%
%        HP: flatmem; (**r we model the memory from 1G to 3G as heap*)
%
%        AC : Container; (**r container tree for all agents *)
%        
%        uctxt : UContext; (**r user context pool*)
%
%        pperm: PPermT; (**r physical page permission table *) (* need fancy merging *)
%
%        PT: Z; (**r the current page table index*) 
%        ptpool: PMapPool; (**r page table pool*)
%        ipt: bool; (**r pure logic flag, shows whether the current page map is the kernel's page map*)
%        
%        syncchpool : SyncChanPool; (**r the channel pool for synchronous IPC*)
%        buffer: PageBufferPool; (**r page buffer in the IPC module*)
%
%        ept: EPT; (**r nested page table for guest mode*)
%        vmcs: VMCS; (**r virtual machine control structure for current VM *)
%        vmx: VMX;  (**r VMX structure to store the extra registers of host *) 
%
%        com1: SerialData; (**r serial port COM1*)
%        drv_serial: SerialDriver; (**r serial driver states*)
%        console_concrete: ConsoleDriverConcrete; (**r console driver states concrete implementation*)
%        console: ConsoleDriver; (**r console driver states*)
%
%        ioapic: IoApicData; (**r I/O Advanced Programmable Interrupt Controller *)
%        lapic: LApicData; (**r Local Advanced Programmable Interrupt Controller *)
%        tf: TrapFrames; (**r Trap frame automatically pushed by CPU *)
%        tf_reg: val; (** temporary place to save an intermediate tf regiter *) 
%        curr_intr_num: Z; (**r current interrupt vector number *)
%        intr_flag: bool; 
%        saved_intr_flags: list bool;
%
%        in_intr: bool; (**r in the interrupt handler *)
%        i_dev_serial: bool (**r in the critical section of operating serial *)
%      }.
%\end{lstlisting}



%\label{chapter:certikos:subsec:multithreaded-configuration-instance}
%
%Two big challenge in here is related initial state of thread local machines; 
%1) how we assing the initial state; 2) how we prove the invariant about initial state 
%of each thread. 
%Both of them are possible by using our global log. 
%
%\begin{lstlisting}[language=C]
%  Record sharedData :=
%    mk_sharedData {
%        CPU_ID: Z; (**r current CPU_ID *)
%        MM: MMTable; (**r table of the physical memory's information*)
%        MMSize: Z; (**r size of MMTable*)
%        vmxinfo: VMXInfo; (**r information of vmx*)
%        CR3: globalpointer; (**r abstract of CR3, stores the pointer to page table*)
%        pg: bool; (**r abstract of CR0, indicates whether the paging is enabled or not*)
%        cid: ZMap.t Z; (**r current thread id*)
%        nps: Z; (**r number of the pages*)
%        init: bool; (**r pure logic flag, show whether the initialization at this layer has been called or not*)
%        idpde: IDPDE; (**r shared identity maps *)
%        big_log: BigLogType;
%        big_oracle: BigOracle
%      }.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%  Record privData :=
%    mk_privData {
%        ti: trapinfo; (**r abstract of CR2, stores the address where page fault happens*)
%
%        ikern: bool; (**r pure logic flag, shows whether it's in kernel mode or not*)
%        ihost: bool; (**r logic flag, shows whether it's in the host mode or not*)         
%
%
%        HP: flatmem; (**r we model the memory from 1G to 3G as heap*)
%
%        AC : Container; (**r container tree for all agents *)
%        
%        uctxt : UContext; (**r user context pool*)
%
%        pperm: PPermT; (**r physical page permission table *) (* need fancy merging *)
%
%        PT: Z; (**r the current page table index*) 
%        ptpool: PMapPool; (**r page table pool*)
%        ipt: bool; (**r pure logic flag, shows whether the current page map is the kernel's page map*)
%        
%        syncchpool : SyncChanPool; (**r the channel pool for synchronous IPC*)
%        buffer: PageBufferPool; (**r page buffer in the IPC module*)
%
%        ept: EPT; (**r nested page table for guest mode*)
%        vmcs: VMCS; (**r virtual machine control structure for current VM *)
%        vmx: VMX;  (**r VMX structure to store the extra registers of host *) 
%
%        com1: SerialData; (**r serial port COM1*)
%        drv_serial: SerialDriver; (**r serial driver states*)
%        console_concrete: ConsoleDriverConcrete; (**r console driver states concrete implementation*)
%        console: ConsoleDriver; (**r console driver states*)
%
%        ioapic: IoApicData; (**r I/O Advanced Programmable Interrupt Controller *)
%        lapic: LApicData; (**r Local Advanced Programmable Interrupt Controller *)
%        tf: TrapFrames; (**r Trap frame automatically pushed by CPU *)
%        tf_reg: val; (** temporary place to save an intermediate tf regiter *) 
%        curr_intr_num: Z; (**r current interrupt vector number *)
%        intr_flag: bool; 
%        saved_intr_flags: list bool;
%
%        in_intr: bool; (**r in the interrupt handler *)
%        i_dev_serial: bool (**r in the critical section of operating serial *)
%      }.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Definition prim_thread_init_pc {F V} (ge : Genv.t F V) (name : ident) (args : list lval): option val :=
%      if peq name proc_create
%      then match Genv.find_symbol ge START_USER_FUN_LOC with
%           | Some b' => Some (Vptr b' Int.zero)
%           | _ => None
%           end
%      else None.
%
%    Definition cal_init_dproc (pv_adt : dproc) (parent: Z) (q: Z) (buc : block) (uc_ofs : int): dproc:= 
%      let uctx0 := uctxt pv_adt in
%      let uctx1 := ZMap.set U_SS CPU_GDT_UDATA
%                            (ZMap.set U_CS CPU_GDT_UCODE 
%                                      (ZMap.set U_DS CPU_GDT_UDATA
%                                                (ZMap.set U_ES CPU_GDT_UDATA uctx0))) in
%      (* U_EIP will be setted as zero for initial low level invariant proofs  
%        - To enable this one, I changed proc start and exit semantic rules 
%          we can optimize it later (after we port our version into the new layer framework *)
%      let uctx2 := ZMap.set U_EIP Vzero
%                            (ZMap.set U_EFLAGS FL_IF 
%                                      (ZMap.set U_ESP (Vint STACK_TOP) uctx1)) in
%      (pv_adt {pv_AC: (mkContainer q 0 parent nil true)} {pv_uctxt: uctx2}).
%
%    Fixpoint thread_init_dproc_iter (curid: Z) (l : Log) : option dproc :=
%      match l with 
%      | nil => None (* we may be able to remove this case *)
%      | ev::l' => 
%        match ev with 
%        | LEvent id ev_detail =>
%          match ev_detail with 
%          | LogPrim name largs new_id _=>
%            if peq name proc_create 
%            then if zeq curid new_id (* the function to calculate new_id is defined in ObjPHBThreadreplayfunction.v file *) 
%                 then match largs with 
%                      | (Lint elf_id)::(Lptr buc uc_ofs)::(Lint q)::nil =>
%                        match (zle_lt (id * Constant.max_children + 1) curid (id * Constant.max_children 
%                                                                              + 1 + Constant.max_children),
%                               zlt_lt Constant.TOTAL_CPU curid num_proc,
%                               zle_le 0 (Int.unsigned q) Int.max_unsigned,
%                               pg (update init_shared_adt l), 
%                               init (update init_shared_adt l)) with    
%                        (* from here - need to be consistent with  dnew_semantics in layerlib/PrimSemantics.v *) 
%                        (* this is the case that has the corresponding spawn and return the initialized private adt *)
%                        (* q is the initial quota / id is a parent of this thread *)
%                        (* id: parent / q : quota / curid : child *)
%                        | (left _, left _, left _, true, true) 
%                          => Some (cal_init_dproc nomain_init_priv_adt id (Int.unsigned q) buc uc_ofs)
%                        | ((*_, _, *) _, _, _, _) => None
%                        end
%                      | _ => None 
%                      end
%                 else thread_init_dproc_iter curid l'
%            else thread_init_dproc_iter curid l'
%          | _ => thread_init_dproc_iter curid l'
%          end
%        end
%      end.
%    
%    Definition thread_init_dproc_aux (curid: Z) (l : Log) : option dproc :=
%      if zeq curid main_thread 
%      then match l with 
%           | nil => Some main_init_dproc 
%           | _ => None
%           end
%      else thread_init_dproc_iter curid l.
%
%    Definition thread_init_dproc (curid: Z) : dproc :=
%      match thread_init_dproc_aux curid init_log with
%      | Some init_dproc_val => init_dproc_val
%      | _ => if zeq curid main_thread then main_init_dproc else nomain_init_priv_adt
%      end.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%Definition has_event (name : ident) :=
%  if peq name palloc then true else 
%    if peq name pt_resv then true else
%      if peq name proc_create then true else
%        if peq name thread_wakeup then true else
%          if peq name sched_init then true else
%            if peq name acquire_lock_CHAN then true else
%              if peq name release_lock_CHAN then true else
%                if peq name ipc_send_body then true else false.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Definition choice_check (name : ident) (largs : list lval) (sd: sharedData) (pd: privData) : Z :=
%      match prim_id_num name with 
%      | palloc_num =>
%        match largs with 
%        |  (Lint n)::nil => single_big_palloc_spec_test (Int.unsigned n) (sd, pd)
%        | _ => 42
%        end
%      | pt_resv_num => 
%        match largs with 
%        | (Lint n)::(Lint vadr)::(Lint perm)::nil => single_big_ptResv_spec_test (Int.unsigned n) 
%                                                                                 (Int.unsigned vadr)
%                                                                                 (Int.unsigned perm) (sd, pd)
%        | _ => 42
%        end
%      | proc_create_num =>
%        match largs with 
%        | (Lint elf_id)::(Lptr buc uc_ofs)::(Lint q)::nil => single_big_proc_create_spec_test 
%                                                               (sd, pd) buc uc_ofs (Int.unsigned q)
%        | _ => 0
%        end
%      | _ => 42 (* wrong case that should not be called *)
%      end.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Definition apply_event (ev : LogEvent) (adt : dshare) : option dshare := 
%      match ev with 
%      | LEvent tid ev_unit =>
%        match ev_unit with 
%        | LogPrim prim_id args choice dSnapShot =>
%          match prim_id_num prim_id with 
%          | palloc_num =>
%            match args with 
%            |  (Lint n)::nil =>
%               (* 0 means no allocation due to the usage of container and 1 means allocation trial happens *)
%               match single_big_palloc_spec_share (Int.unsigned n) choice adt with 
%               | Some (adt', _) => Some adt'
%               | _ => None 
%               end
%            | _ => None
%            end
%            <@$\cdots$@>
%            
%    Fixpoint update (adt: dshare) (sh_log : Log) {struct sh_log} : dshare :=
%      match sh_log with
%      | nil => adt
%      | hd::tl => let adt' := update adt tl in 
%                  match apply_event hd adt' with 
%                  | Some adt'' => adt'' 
%                  | _ => adt' 
%                  end
%      end.
%
%    Lemma update_invariant (I: dshare -> Prop):
%      (forall e d d', apply_event e d = Some d' -> I d -> I d') ->
%      (forall d l, I d -> I (update d l)).
%    Proof.
%      induction l; simpl; eauto.
%      destruct (apply_event a _) eqn:Hd'; eauto.
%    Qed.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%  Definition thread_init_pc {F V} (ge: Genv.t F V) (e : LogEvent) :=
%    match e with
%      | LEvent _ (LogPrim f args new_id _) => match prim_thread_init_pc ge f args with 
%                                            | Some pc => Some (new_id, pc)
%                                            | _ => None
%                                            end
%      | _ => None
%    end.
%
%  Definition thread_init_pc_of {F V} ge (i : Z) (e : LogEvent) : option val :=
%    match thread_init_pc (F:=F) (V:=V) ge e with
%      | Some (j, pc) => if decide (i = j) then Some pc else None
%      | None => None
%    end.
%
%  (** Using [thread_init_pc], we can extract the initial program
%    counter for a thread from any log. The initial state of the main
%    thread is hardcoded to point to main() as set by [make_program],
%    and is already available with an empty log. For other threads,
%    this function will compute their initial states by examining the
%    log for a corresponding spawn event. *)
%
%  Fixpoint initial_thread_pc {F V} (ge: Genv.t F V) i (l : Log) : option val :=
%    match l with
%      | e :: l' =>
%        match initial_thread_pc ge i l' with
%          | Some pc => Some pc
%          | None => thread_init_pc_of ge i e
%        end
%      | nil =>
%        match decide (i = main_thread) with
%          | left _ => Some (symbol_offset ge 1%positive Int.zero)
%          | right _ => None
%        end
%    end.
%
%  Definition initial_regset_state pc :=
%    (Pregmap.init Vundef) # PC <- pc # ESP <- Vzero.
%
%  Definition initial_thread_state {F V} (ge: Genv.t F V) i l : option regset :=
%    match initial_thread_pc ge i l with
%      | Some pc => Some (initial_regset_state pc)
%      | None => None
%    end.
%
%  (** Before we "return" into a (non-main) thread that is scheduled
%    for the first time, the saved context has a slightly different
%    format, where the code pointer is stored in [RA]. *)
%
%  Definition initial_regset_kctxt pc :=
%    (Pregmap.init Vundef) # RA <- pc # ESP <- Vzero.
%
%  Definition initial_thread_kctxt {F V} (ge: Genv.t F V) i l : option regset :=
%    match initial_thread_pc ge i l with
%      | Some pc => Some (initial_regset_kctxt pc)
%      | None => None
%    end.
%    
%  Definition init_mem_lift_nextblock (m: mem) :=
%    match init_log with
%      | nil => m
%      | _::_ => mem_lift_nextblock m (Pos.to_nat (last_nb init_log) -
%                                      Pos.to_nat (Mem.nextblock m))
%    end.
%
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Program Instance s_oracle_prf : SingleOracle (single_data := AuxSingleAbstractDataType.single_data) 
%                                                 (single_oracle_ops := s_oracle_ops) 
%                                                 (threads_conf_ops := s_threads_ops):=
%      { 
%        has_event := has_event;
%        update := update;
%        thread_init_dproc := thread_init_dproc;
%        state_check := state_check;
%        sync_chpool_check := ObjPHBThreadReplayFunction.sync_chpool_check;
%        snap_func := snap_func;
%        snap_rev_func := snap_rev_func;
%        choice_check := ObjPHBThreadReplayFunction.choice_check;
%        PHThread2TCompose := PHThread2TComposeData.combine_data;
%        prim_thread_init_pc := @prim_thread_init_pc
%      }.
%\end{lstlisting}


%
%
%This provides the relation bewteen PHBThread layer runs with EAsm and PBThread layer runs with LAsm. 
%
%\begin{lstlisting}[language=C]
%    Definition pperm_inject (ha_ppermtable : PPermT) (la_ppermtable : PPermT) : Prop := 
%      forall i, 
%        match ZMap.get i ha_ppermtable, ZMap.get i la_ppermtable with 
%          | PGUndef, _ => True
%          | PGAlloc, PGAlloc => True 
%          | PGHide ho, PGHide lo => ho = lo
%          | _, _ => False
%        end.
%    
%    Definition B_GetContainerUsed' (tid: Z) (cid : Z) (big_log: BigLogType) : bool :=
%      match big_log with 
%      | BigUndef => false
%      | BigDef l => B_GetContainerUsed tid cid l
%      end.
%
%    Definition relate_AC_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
%      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
%                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%                        (* I can use the precise definition which I commented out instead of the version 
%                                      that contains the True value. But, if I do that, I have to redefine init_dproc
%                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
%                                      So, for the simplicity, I will use the current version *)
%                        if zeq id main_thread 
%                        then AC pd =  ZMap.get id (AbstractDataType.AC ladt)
%                        else if zlt_lt TOTAL_CPU id num_proc then AC pd = ZMap.get id (AbstractDataType.AC ladt) 
%                             else True
%                      (* The following things are for thread spawn related_RData.
%                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
%                                    However, instead of using dummy True, I decided to add the precise value 
%                                    to handle the case. This should be much better then the dummy True *)
%                      else if zlt_lt TOTAL_CPU id num_proc then AC pd = AC (thread_init_dproc id) else True
%      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%      (* I can use the precise definition which I commented out instead of the version that contains the True value.
%                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
%                    and init_dproc in EAsm and TAsm.
%                    So, for the simplicity, I will use the current version *)
%      else if zeq id main_thread 
%           then (AC pd) = ZMap.get id (AbstractDataType.AC ladt) 
%           else if zlt_lt TOTAL_CPU id num_proc then AC pd =  AC (thread_init_dproc id) else True.
%
%    (*
%    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
%      (forall i, 0 <= i < UCTXT_SIZE -> 
%                 i <> U_EIP ->
%                 ZMap.get i huctx = ZMap.get i luctx) /\ 
%      (exists v, ZMap.get U_EIP luctx = v).
%    *)
%      
%    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
%      match ZMap.get U_EIP huctx with 
%        | Vint i => if Int.eq i (Int.repr 0) then 
%                      (forall i, 0 <= i < UCTXT_SIZE -> 
%                                 i <> U_EIP ->
%                                 ZMap.get i huctx = ZMap.get i luctx) /\ 
%                      (exists v, ZMap.get U_EIP luctx = v)
%                    else huctx = luctx
%        | Vundef => (forall i, 0 <= i < UCTXT_SIZE -> 
%                               i <> U_EIP ->
%                               ZMap.get i huctx = ZMap.get i luctx) /\ 
%                    (exists v, ZMap.get U_EIP luctx = v)
%        | _ => False
%      end.
%
%    Definition relate_uctxt_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
%      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
%                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%                        (* I can use the precise definition which I commented out instead of the version 
%                                      that contains the True value. But, if I do that, I have to redefine init_dproc
%                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
%                                      So, for the simplicity, I will use the current version *)
%                        if zeq id main_thread 
%                        then uctxt_bieq (uctxt pd) (ZMap.get id (AbstractDataType.uctxt ladt))
%                        (* then uctxt pd =  ZMap.get id (AbstractDataType.uctxt ladt) *)
%                        else if zlt_lt TOTAL_CPU id num_proc then  uctxt_bieq (uctxt pd) 
%                                                                              (ZMap.get id (AbstractDataType.uctxt ladt))
%                             else True
%                      (* The following things are for thread spawn related_RData.
%                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
%                                    However, instead of using dummy True, I decided to add the precise value 
%                                    to handle the case. This should be much better then the dummy True *)
%                      else if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True
%                      (* else  if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True *)
%      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%      (* I can use the precise definition which I commented out instead of the version that contains the True value.
%                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
%                    and init_dproc in EAsm and TAsm.
%                    So, for the simplicity, I will use the current version *)
%      else if zeq id main_thread 
%           then  uctxt pd = ZMap.get id (AbstractDataType.uctxt ladt)
%           else if zlt_lt TOTAL_CPU id num_proc then  uctxt pd = uctxt (thread_init_dproc id) else True.
%
%    Definition relate_SyncChanPool_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
%      if (init sd) then 
%        (* check only and only if the current thread is protected by acquire_lock *)
%        (* it will consider the current channel / do not care about other channels *)
%        if B_inLock (CPU_ID sd) (big_log sd) then 
%          if zeq id (proc_id sd) 
%          then syncchpool pd = AbstractDataType.syncchpool ladt
%          else True (* don't care about other's syncpool *) 
%        else match (big_log sd) with 
%               | BigDef nil => (* if we never call lock at all the value should be initialized value
%                                                      - need this one in sched_init function proof *)
%                 syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef)
%               | BigDef _ => True
%               | _ => False (* if the system is initialized, this case should not happen *)
%             end
%      (* initial state need to be matched for all threads *)
%      (* case analysis is required for sched_init  - look at the difference between 
%         main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
%      else if zeq id main_thread  
%           then syncchpool pd = (ZMap.init SyncChanUndef)
%           else syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef).
%
%    Record E2PBThreadGenPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
%           (ladt : AbstractDataType.RData) :=
%      mkE2PBThreadGenPerDInv {
%
%          dirty_page_per_thread_inv:
%            forall res i, ZMap.get i (pperm pd) = PGUndef -> ZMap.get res (HP pd) = ZMap.get res (FlatMem.free_page i (HP pd))
%          
%        }.
%
%    Record relate_RData_per_pd  (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
%           (ladt : AbstractDataType.RData) :=
%      mkrelate_RData_per_pd {
%          (* for shared data parts - it's duplicated, but ok *)
%          vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
%          CR3_re: CR3 sd = AbstractDataType.CR3 ladt;
%          pg_re:  pg sd =  AbstractDataType.pg ladt;
%          nps_re: nps sd = AbstractDataType.nps ladt;
%          init_re: init sd = AbstractDataType.init ladt;
%          lock_re: lock sd = AbstractDataType.lock ladt;
%          
%          CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
%          cid_re: if init sd
%                  then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
%                  else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
%                       (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
%                        then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
%                        else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
%          idpde_re: idpde sd = AbstractDataType.idpde ladt;
%          kctxt_re: kctxt_val= ZMap.get id (AbstractDataType.kctxt ladt);
%          big_log_re: big_log sd = AbstractDataType.big_log ladt;
%          big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;
%
%          (* flatmem - may need an extra relation to prove the equality for load, store, and copy. 
%                     - See E2PBThreadGenDef.v file *)
%          (* flatmem_re: FlatMem.flatmem_inj (HP pd) (AbstractDataType.HP ladt); *)
%          flatmem_re: forall v ofs TY,
%                        ZMap.get ((v * PgSize + ofs mod PgSize) / PgSize) (pperm pd) = PGAlloc ->
%                        ofs mod 4096 <= 4096 - size_chunk TY ->
%                        (align_chunk TY | ofs mod PgSize) -> 
%                        FlatMem.load TY (HP pd) (v * PgSize + ofs mod PgSize) =
%                        FlatMem.load TY (AbstractDataType.HP ladt) (v * PgSize + ofs mod PgSize);
%          
%          (* except the running thread, all other threads should have the default value 
%           - necessary for yield and sleep case *)
%          ikern_re: if zeq id (proc_id sd) then ikern pd = AbstractDataType.ikern ladt else ikern pd = true;
%
%          (* except the running thread, all other threads should have the default value 
%           - necessary for yield and sleep case *)
%          ihost_re: if zeq id (proc_id sd) then ihost pd = AbstractDataType.ihost ladt else ihost pd = true;
%          
%          (* main_thread is (CPU_ID adt + 1) now. The constraint - 
%             all ID in the full_thread_list should satisfy the following constraint:
%             (forall l, proc_id (uRData l) /in full_thread_list) /\ 
%             (forall i, i /in full_thread_list -> i = i = main_thread \/ TOTAL_CPU < i < num_proc) *)
%          AC_re: relate_AC_per_pd  id sd pd ladt;
%           
%          (* we assume that ti will be setted as a default value when the kernel 
%             exit to the user process (by trapout) - for the precise implementation, we may need to 
%             change the definition of trapout? *)
%          ti_re: if zeq id (proc_id sd) then ti pd = AbstractDataType.ti ladt else  ti pd = init_trap_info;
%
%          (* may need an extra relationship in here for mutex property? *)
%          pperm_re: pperm_inject (pperm pd) (AbstractDataType.pperm ladt);
%          
%          (* case analysis is required for sched_init  - look at the difference between 
%             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
%          PT_re: if init sd 
%                 then if zeq id (proc_id sd) then PT pd = AbstractDataType.PT ladt else PT pd = 0
%                 else if zeq id main_thread then PT pd = -1 else PT pd = 0;
%
%          (* ptpool initialization is not setting def val for all i. So I will keep the 
%             whole ptpool in each pd, but will check each entry of each thread's ptpool for simulation *)
%          (* only need to check the ptpool for each thread *)
%          (* case analysis is required for sched_init  - look at the difference between 
%             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
%          (* main_thread is 0 now, but need to change it later as (CPU_ID adt) + 1 *)
%          ptp_re: if init sd 
%                  then ZMap.get id (ptpool pd) = ZMap.get id (AbstractDataType.ptpool ladt)
%                  else if zeq id main_thread then ptpool pd = (AbstractDataType.ptpool ladt) 
%                       else ptpool pd = CalRealPT.real_pt (AbstractDataType.ptpool ladt);
%
%          (* except the running thread, all other threads should have the default value  - necessary for yield and sleep case *)
%          ipt_re: if zeq id (proc_id sd) then ipt pd = AbstractDataType.ipt ladt else ipt pd = true;
%
%          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
%          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)
%          intr_flag_re: if zeq id (proc_id sd) then intr_flag pd = AbstractDataType.intr_flag ladt else intr_flag pd = true;
%
%          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
%          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)          
%          in_intr_re: if zeq id (proc_id sd) then in_intr pd = AbstractDataType.in_intr ladt else in_intr pd = false;
%
%          (* from com1_re to drv_serial_re ----
%             for the simplicity, I assume that main_thread = dev_handling_cid. 
%             If we change the number of main_thread as (CPU_ID adt) + 1, then, this assumption doesn't 
%             geneate any nonsensical cases. I can remove this assumption (main_thread = dev_handling_cid), 
%             but, then, I need an another case analysis for init_dproc in (EAsm.v and TAsm.v files) 
%             to handle them *)
%          com1_re: if zeq id dev_handling_cid then com1 pd = AbstractDataType.com1 ladt else True;
%
%          console_re: if zeq id dev_handling_cid then console pd = AbstractDataType.console ladt else True;
%
%          console_concrete_re: if zeq id dev_handling_cid 
%                               then console_concrete pd = AbstractDataType.console_concrete ladt else True;
%
%          ioapic_re: if zeq id dev_handling_cid 
%                     then ioapic pd = AbstractDataType.ioapic ladt else True;
%
%          lapic_re: if zeq id dev_handling_cid 
%                    then lapic pd = AbstractDataType.lapic ladt else True;
%
%          curr_intr_num_re: if zeq id dev_handling_cid 
%                            then curr_intr_num pd = AbstractDataType.curr_intr_num ladt else True;
%
%          drv_serial_re: if zeq id dev_handling_cid 
%                         then drv_serial pd = AbstractDataType.drv_serial ladt else True;
%
%          (* concept: ok. I'll not care the actual match state of syncchpool except the case 
%             when we call acquire_lock, which we have to match the syncchpool with thread-machine with 
%             CPU-machine *)
%          (* we can optimize this definition 
%             - e.g. we can check only one syncchan value related to the lock id. Then, I may be able to 
%               remove some definitions. 
%           *)
%          syncchpool_re: relate_SyncChanPool_per_pd id sd pd ladt;
%          uctxt_re: relate_uctxt_per_pd id sd pd ladt;
%
%          ept_re: if zeq id vm_handling_cid
%                  then ept pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.ept ladt)
%                  else True;
%          vmcs_re: if zeq id vm_handling_cid
%                   then vmcs pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmcs ladt)
%                   else True;
%          vmx_re: if zeq id vm_handling_cid
%                  then vmx pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmx ladt)
%                  else True;
%
%          inv_re: E2PBThreadGenPerDInv id kctxt_val sd pd ladt
%        }.
%
%    Record E2PBThreadGenEmptyPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (ladt : AbstractDataType.RData) :=
%      mkE2PBThreadGenEmptyPerDInv {
%
%        }.
%
%
%    Record E2PBThreadGenSharedDInv (kctxt_pool : KContextPool) (sd : sharedData) (ladt : AbstractDataType.RData) :=
%      mkE2PBThreadGenSharedDInv {
%
%          dirty_page_shared_inv:
%            forall res i, ZMap.get i (AbstractDataType.pperm ladt) = PGUndef ->
%                          ZMap.get res (AbstractDataType.HP ladt) = ZMap.get res (FlatMem.free_page i (AbstractDataType.HP ladt));
%          
%          init_big_log_inv: init sd = false -> big_log sd = BigUndef;
%          init_pperm_inv: init sd = false -> AbstractDataType.pperm ladt = ZMap.init PGUndef;
%          init_uctxt_inv: init sd = false -> AbstractDataType.uctxt ladt = ZMap.init (ZMap.init Vundef);
%         
%          syncchpool_inv:  
%              BigLogThreadConfigFunction.B_inLock (CPU_ID sd) (big_log sd) = false ->
%              BigLogThreadConfigFunction.B_GetlastPush (CPU_ID sd) (big_log sd) 
%              = AbstractDataType.syncchpool ladt;
%          
%          container_used_inv :
%            forall tid, In tid full_thread_list -> B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) 
%                                                   = cused (ZMap.get tid (AbstractDataType.AC ladt));
%
%          uctxt_used_inv :
%            forall tid, B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) = false ->
%                        ZMap.get tid (AbstractDataType.uctxt ladt) = ZMap.init Vundef;
%
%          
%          valid_AT_log_inv: valid_AT_log_type_B (big_log sd); 
%          valid_TCB_log_inv: valid_TCB_log_type_B (big_log sd);
%          big_oracle_inv: valid_big_oracle (big_oracle sd);
%
%          valid_B_Cal_AT_log_inv: forall i l atable, 
%                                    ZMap.get i (AbstractDataType.pperm ladt) <> PGUndef ->
%                                    (AbstractDataType.big_log ladt) = BigDef l ->
%                                    B_CalAT_log_real l = Some atable ->
%                                    ZMap.get i atable = ATValid true ATNorm
%        }.
%
%    Record E2PBThreadGenSharedMemInv (pdpool: ZMap.t (option privData)) :=
%      mkE2PBThreadGenSharedMemInv {
%          
%          pperm_disjoint: 
%            forall i j pd pd',
%              i <> j ->
%              ZMap.get i pdpool = Some pd ->
%              ZMap.get j pdpool = Some pd' ->
%              (forall j, ZMap.get j (pperm pd) <> PGUndef ->
%                         ZMap.get j (pperm pd')= PGUndef)
%        }.
%
%    Record relate_RData (kctxt_pool : KContextPool)  (sd : sharedData)  (pdpool: ZMap.t (option privData))
%           (ladt : AbstractDataType.RData) :=
%      mkrelate_RData {
%          
%          sh_vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
%          sh_CR3_re: CR3 sd= AbstractDataType.CR3 ladt;
%          sh_pg_re:  pg sd =  AbstractDataType.pg ladt;
%          sh_nps_re: nps sd = AbstractDataType.nps ladt;
%          sh_init_re: init sd = AbstractDataType.init ladt;
%          sh_lock_re: lock sd = AbstractDataType.lock ladt;
%          
%          sh_CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
%          sh_cid_re: if init sd
%                     then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
%                     else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
%                          (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
%                           then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
%                           else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
%          sh_idpde_re: idpde sd = AbstractDataType.idpde ladt;
%          sh_kctxt_re: kctxt_pool = (AbstractDataType.kctxt ladt);
%          sh_big_log_re: big_log sd = AbstractDataType.big_log ladt;
%          sh_big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;
%          
%          per_data_re: forall i,
%                         match ZMap.get i pdpool with 
%                           | Some pd => relate_RData_per_pd i (ZMap.get i kctxt_pool) sd pd ladt
%                           | _ => E2PBThreadGenEmptyPerDInv i (ZMap.get i kctxt_pool)  sd ladt
%                         end;
%          
%          sh_shared_inv_re: E2PBThreadGenSharedDInv kctxt_pool sd ladt;
%          
%          sh_mem_inv_re: E2PBThreadGenSharedMemInv pdpool 
%                                                    
%        }.
%\end{lstlisting}


