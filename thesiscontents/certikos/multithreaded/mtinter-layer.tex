\subsection{Building Intermediate Layer for Multithreaded Linking Machine Models}
\label{chapter:certikos:phbthread}



\subsubsection{Thread Configurations and Auxiliary Functions}


%\label{chapter:certikos:subsec:multithreaded-configuration-instance}
%
%Two big challenge in here is related initial state of thread local machines; 
%1) how we assing the initial state; 2) how we prove the invariant about initial state 
%of each thread. 
%Both of them are possible by using our global log. 
%
%\begin{lstlisting}[language=C]
%  Record sharedData :=
%    mk_sharedData {
%        CPU_ID: Z; (**r current CPU_ID *)
%        MM: MMTable; (**r table of the physical memory's information*)
%        MMSize: Z; (**r size of MMTable*)
%        vmxinfo: VMXInfo; (**r information of vmx*)
%        CR3: globalpointer; (**r abstract of CR3, stores the pointer to page table*)
%        pg: bool; (**r abstract of CR0, indicates whether the paging is enabled or not*)
%        cid: ZMap.t Z; (**r current thread id*)
%        nps: Z; (**r number of the pages*)
%        init: bool; (**r pure logic flag, show whether the initialization at this layer has been called or not*)
%        idpde: IDPDE; (**r shared identity maps *)
%        big_log: BigLogType;
%        big_oracle: BigOracle
%      }.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%  Record privData :=
%    mk_privData {
%        ti: trapinfo; (**r abstract of CR2, stores the address where page fault happens*)
%
%        ikern: bool; (**r pure logic flag, shows whether it's in kernel mode or not*)
%        ihost: bool; (**r logic flag, shows whether it's in the host mode or not*)         
%
%
%        HP: flatmem; (**r we model the memory from 1G to 3G as heap*)
%
%        AC : Container; (**r container tree for all agents *)
%        
%        uctxt : UContext; (**r user context pool*)
%
%        pperm: PPermT; (**r physical page permission table *) (* need fancy merging *)
%
%        PT: Z; (**r the current page table index*) 
%        ptpool: PMapPool; (**r page table pool*)
%        ipt: bool; (**r pure logic flag, shows whether the current page map is the kernel's page map*)
%        
%        syncchpool : SyncChanPool; (**r the channel pool for synchronous IPC*)
%        buffer: PageBufferPool; (**r page buffer in the IPC module*)
%
%        ept: EPT; (**r nested page table for guest mode*)
%        vmcs: VMCS; (**r virtual machine control structure for current VM *)
%        vmx: VMX;  (**r VMX structure to store the extra registers of host *) 
%
%        com1: SerialData; (**r serial port COM1*)
%        drv_serial: SerialDriver; (**r serial driver states*)
%        console_concrete: ConsoleDriverConcrete; (**r console driver states concrete implementation*)
%        console: ConsoleDriver; (**r console driver states*)
%
%        ioapic: IoApicData; (**r I/O Advanced Programmable Interrupt Controller *)
%        lapic: LApicData; (**r Local Advanced Programmable Interrupt Controller *)
%        tf: TrapFrames; (**r Trap frame automatically pushed by CPU *)
%        tf_reg: val; (** temporary place to save an intermediate tf regiter *) 
%        curr_intr_num: Z; (**r current interrupt vector number *)
%        intr_flag: bool; 
%        saved_intr_flags: list bool;
%
%        in_intr: bool; (**r in the interrupt handler *)
%        i_dev_serial: bool (**r in the critical section of operating serial *)
%      }.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Definition prim_thread_init_pc {F V} (ge : Genv.t F V) (name : ident) (args : list lval): option val :=
%      if peq name proc_create
%      then match Genv.find_symbol ge START_USER_FUN_LOC with
%           | Some b' => Some (Vptr b' Int.zero)
%           | _ => None
%           end
%      else None.
%
%    Definition cal_init_dproc (pv_adt : dproc) (parent: Z) (q: Z) (buc : block) (uc_ofs : int): dproc:= 
%      let uctx0 := uctxt pv_adt in
%      let uctx1 := ZMap.set U_SS CPU_GDT_UDATA
%                            (ZMap.set U_CS CPU_GDT_UCODE 
%                                      (ZMap.set U_DS CPU_GDT_UDATA
%                                                (ZMap.set U_ES CPU_GDT_UDATA uctx0))) in
%      (* U_EIP will be setted as zero for initial low level invariant proofs  
%        - To enable this one, I changed proc start and exit semantic rules 
%          we can optimize it later (after we port our version into the new layer framework *)
%      let uctx2 := ZMap.set U_EIP Vzero
%                            (ZMap.set U_EFLAGS FL_IF 
%                                      (ZMap.set U_ESP (Vint STACK_TOP) uctx1)) in
%      (pv_adt {pv_AC: (mkContainer q 0 parent nil true)} {pv_uctxt: uctx2}).
%
%    Fixpoint thread_init_dproc_iter (curid: Z) (l : Log) : option dproc :=
%      match l with 
%      | nil => None (* we may be able to remove this case *)
%      | ev::l' => 
%        match ev with 
%        | LEvent id ev_detail =>
%          match ev_detail with 
%          | LogPrim name largs new_id _=>
%            if peq name proc_create 
%            then if zeq curid new_id (* the function to calculate new_id is defined in ObjPHBThreadreplayfunction.v file *) 
%                 then match largs with 
%                      | (Lint elf_id)::(Lptr buc uc_ofs)::(Lint q)::nil =>
%                        match (zle_lt (id * Constant.max_children + 1) curid (id * Constant.max_children 
%                                                                              + 1 + Constant.max_children),
%                               zlt_lt Constant.TOTAL_CPU curid num_proc,
%                               zle_le 0 (Int.unsigned q) Int.max_unsigned,
%                               pg (update init_shared_adt l), 
%                               init (update init_shared_adt l)) with    
%                        (* from here - need to be consistent with  dnew_semantics in layerlib/PrimSemantics.v *) 
%                        (* this is the case that has the corresponding spawn and return the initialized private adt *)
%                        (* q is the initial quota / id is a parent of this thread *)
%                        (* id: parent / q : quota / curid : child *)
%                        | (left _, left _, left _, true, true) 
%                          => Some (cal_init_dproc nomain_init_priv_adt id (Int.unsigned q) buc uc_ofs)
%                        | ((*_, _, *) _, _, _, _) => None
%                        end
%                      | _ => None 
%                      end
%                 else thread_init_dproc_iter curid l'
%            else thread_init_dproc_iter curid l'
%          | _ => thread_init_dproc_iter curid l'
%          end
%        end
%      end.
%    
%    Definition thread_init_dproc_aux (curid: Z) (l : Log) : option dproc :=
%      if zeq curid main_thread 
%      then match l with 
%           | nil => Some main_init_dproc 
%           | _ => None
%           end
%      else thread_init_dproc_iter curid l.
%
%    Definition thread_init_dproc (curid: Z) : dproc :=
%      match thread_init_dproc_aux curid init_log with
%      | Some init_dproc_val => init_dproc_val
%      | _ => if zeq curid main_thread then main_init_dproc else nomain_init_priv_adt
%      end.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%Definition has_event (name : ident) :=
%  if peq name palloc then true else 
%    if peq name pt_resv then true else
%      if peq name proc_create then true else
%        if peq name thread_wakeup then true else
%          if peq name sched_init then true else
%            if peq name acquire_lock_CHAN then true else
%              if peq name release_lock_CHAN then true else
%                if peq name ipc_send_body then true else false.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Definition choice_check (name : ident) (largs : list lval) (sd: sharedData) (pd: privData) : Z :=
%      match prim_id_num name with 
%      | palloc_num =>
%        match largs with 
%        |  (Lint n)::nil => single_big_palloc_spec_test (Int.unsigned n) (sd, pd)
%        | _ => 42
%        end
%      | pt_resv_num => 
%        match largs with 
%        | (Lint n)::(Lint vadr)::(Lint perm)::nil => single_big_ptResv_spec_test (Int.unsigned n) 
%                                                                                 (Int.unsigned vadr)
%                                                                                 (Int.unsigned perm) (sd, pd)
%        | _ => 42
%        end
%      | proc_create_num =>
%        match largs with 
%        | (Lint elf_id)::(Lptr buc uc_ofs)::(Lint q)::nil => single_big_proc_create_spec_test 
%                                                               (sd, pd) buc uc_ofs (Int.unsigned q)
%        | _ => 0
%        end
%      | _ => 42 (* wrong case that should not be called *)
%      end.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Definition apply_event (ev : LogEvent) (adt : dshare) : option dshare := 
%      match ev with 
%      | LEvent tid ev_unit =>
%        match ev_unit with 
%        | LogPrim prim_id args choice dSnapShot =>
%          match prim_id_num prim_id with 
%          | palloc_num =>
%            match args with 
%            |  (Lint n)::nil =>
%               (* 0 means no allocation due to the usage of container and 1 means allocation trial happens *)
%               match single_big_palloc_spec_share (Int.unsigned n) choice adt with 
%               | Some (adt', _) => Some adt'
%               | _ => None 
%               end
%            | _ => None
%            end
%            <@$\cdots$@>
%            
%    Fixpoint update (adt: dshare) (sh_log : Log) {struct sh_log} : dshare :=
%      match sh_log with
%      | nil => adt
%      | hd::tl => let adt' := update adt tl in 
%                  match apply_event hd adt' with 
%                  | Some adt'' => adt'' 
%                  | _ => adt' 
%                  end
%      end.
%
%    Lemma update_invariant (I: dshare -> Prop):
%      (forall e d d', apply_event e d = Some d' -> I d -> I d') ->
%      (forall d l, I d -> I (update d l)).
%    Proof.
%      induction l; simpl; eauto.
%      destruct (apply_event a _) eqn:Hd'; eauto.
%    Qed.
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%  Definition thread_init_pc {F V} (ge: Genv.t F V) (e : LogEvent) :=
%    match e with
%      | LEvent _ (LogPrim f args new_id _) => match prim_thread_init_pc ge f args with 
%                                            | Some pc => Some (new_id, pc)
%                                            | _ => None
%                                            end
%      | _ => None
%    end.
%
%  Definition thread_init_pc_of {F V} ge (i : Z) (e : LogEvent) : option val :=
%    match thread_init_pc (F:=F) (V:=V) ge e with
%      | Some (j, pc) => if decide (i = j) then Some pc else None
%      | None => None
%    end.
%
%  (** Using [thread_init_pc], we can extract the initial program
%    counter for a thread from any log. The initial state of the main
%    thread is hardcoded to point to main() as set by [make_program],
%    and is already available with an empty log. For other threads,
%    this function will compute their initial states by examining the
%    log for a corresponding spawn event. *)
%
%  Fixpoint initial_thread_pc {F V} (ge: Genv.t F V) i (l : Log) : option val :=
%    match l with
%      | e :: l' =>
%        match initial_thread_pc ge i l' with
%          | Some pc => Some pc
%          | None => thread_init_pc_of ge i e
%        end
%      | nil =>
%        match decide (i = main_thread) with
%          | left _ => Some (symbol_offset ge 1%positive Int.zero)
%          | right _ => None
%        end
%    end.
%
%  Definition initial_regset_state pc :=
%    (Pregmap.init Vundef) # PC <- pc # ESP <- Vzero.
%
%  Definition initial_thread_state {F V} (ge: Genv.t F V) i l : option regset :=
%    match initial_thread_pc ge i l with
%      | Some pc => Some (initial_regset_state pc)
%      | None => None
%    end.
%
%  (** Before we "return" into a (non-main) thread that is scheduled
%    for the first time, the saved context has a slightly different
%    format, where the code pointer is stored in [RA]. *)
%
%  Definition initial_regset_kctxt pc :=
%    (Pregmap.init Vundef) # RA <- pc # ESP <- Vzero.
%
%  Definition initial_thread_kctxt {F V} (ge: Genv.t F V) i l : option regset :=
%    match initial_thread_pc ge i l with
%      | Some pc => Some (initial_regset_kctxt pc)
%      | None => None
%    end.
%    
%  Definition init_mem_lift_nextblock (m: mem) :=
%    match init_log with
%      | nil => m
%      | _::_ => mem_lift_nextblock m (Pos.to_nat (last_nb init_log) -
%                                      Pos.to_nat (Mem.nextblock m))
%    end.
%
%\end{lstlisting}
%
%\begin{lstlisting}[language=C]
%    Program Instance s_oracle_prf : SingleOracle (single_data := AuxSingleAbstractDataType.single_data) 
%                                                 (single_oracle_ops := s_oracle_ops) 
%                                                 (threads_conf_ops := s_threads_ops):=
%      { 
%        has_event := has_event;
%        update := update;
%        thread_init_dproc := thread_init_dproc;
%        state_check := state_check;
%        sync_chpool_check := ObjPHBThreadReplayFunction.sync_chpool_check;
%        snap_func := snap_func;
%        snap_rev_func := snap_rev_func;
%        choice_check := ObjPHBThreadReplayFunction.choice_check;
%        PHThread2TCompose := PHThread2TComposeData.combine_data;
%        prim_thread_init_pc := @prim_thread_init_pc
%      }.
%\end{lstlisting}



\subsubsection{$\codeinmath{PHBThread}$ Definition}



%\label{chapter:certikos:subsec:layer-on-intermediate-languages-in-multithreaded-linking}
%
%Our intermediate layer definition has a different state definition (not only for the memory and registers, but also for the abstract data); thus we also provide the 
%layer that can be used for those intermediate machine models. 
%In addition to that, our intermediate machine models has explicit 
%transition rules for yield ans sleep. 
%They are defined in the lanuage level 
%
%\jieung{Need to mention about few specs - spawn}


\subsubsection{Instance of $\codeinmath{AbsRelC}$}



\subsubsection{Refinement between $\codeinmath{PHThrd}$ on $\lasmmach$ and 
 $\codeinmath{PBHThrd}$ on $\easmmach$}

%
%
%This provides the relation bewteen PHBThread layer runs with EAsm and PBThread layer runs with LAsm. 
%
%\begin{lstlisting}[language=C]
%    Definition pperm_inject (ha_ppermtable : PPermT) (la_ppermtable : PPermT) : Prop := 
%      forall i, 
%        match ZMap.get i ha_ppermtable, ZMap.get i la_ppermtable with 
%          | PGUndef, _ => True
%          | PGAlloc, PGAlloc => True 
%          | PGHide ho, PGHide lo => ho = lo
%          | _, _ => False
%        end.
%    
%    Definition B_GetContainerUsed' (tid: Z) (cid : Z) (big_log: BigLogType) : bool :=
%      match big_log with 
%      | BigUndef => false
%      | BigDef l => B_GetContainerUsed tid cid l
%      end.
%
%    Definition relate_AC_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
%      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
%                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%                        (* I can use the precise definition which I commented out instead of the version 
%                                      that contains the True value. But, if I do that, I have to redefine init_dproc
%                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
%                                      So, for the simplicity, I will use the current version *)
%                        if zeq id main_thread 
%                        then AC pd =  ZMap.get id (AbstractDataType.AC ladt)
%                        else if zlt_lt TOTAL_CPU id num_proc then AC pd = ZMap.get id (AbstractDataType.AC ladt) 
%                             else True
%                      (* The following things are for thread spawn related_RData.
%                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
%                                    However, instead of using dummy True, I decided to add the precise value 
%                                    to handle the case. This should be much better then the dummy True *)
%                      else if zlt_lt TOTAL_CPU id num_proc then AC pd = AC (thread_init_dproc id) else True
%      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%      (* I can use the precise definition which I commented out instead of the version that contains the True value.
%                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
%                    and init_dproc in EAsm and TAsm.
%                    So, for the simplicity, I will use the current version *)
%      else if zeq id main_thread 
%           then (AC pd) = ZMap.get id (AbstractDataType.AC ladt) 
%           else if zlt_lt TOTAL_CPU id num_proc then AC pd =  AC (thread_init_dproc id) else True.
%
%    (*
%    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
%      (forall i, 0 <= i < UCTXT_SIZE -> 
%                 i <> U_EIP ->
%                 ZMap.get i huctx = ZMap.get i luctx) /\ 
%      (exists v, ZMap.get U_EIP luctx = v).
%    *)
%      
%    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
%      match ZMap.get U_EIP huctx with 
%        | Vint i => if Int.eq i (Int.repr 0) then 
%                      (forall i, 0 <= i < UCTXT_SIZE -> 
%                                 i <> U_EIP ->
%                                 ZMap.get i huctx = ZMap.get i luctx) /\ 
%                      (exists v, ZMap.get U_EIP luctx = v)
%                    else huctx = luctx
%        | Vundef => (forall i, 0 <= i < UCTXT_SIZE -> 
%                               i <> U_EIP ->
%                               ZMap.get i huctx = ZMap.get i luctx) /\ 
%                    (exists v, ZMap.get U_EIP luctx = v)
%        | _ => False
%      end.
%
%    Definition relate_uctxt_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
%      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
%                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%                        (* I can use the precise definition which I commented out instead of the version 
%                                      that contains the True value. But, if I do that, I have to redefine init_dproc
%                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
%                                      So, for the simplicity, I will use the current version *)
%                        if zeq id main_thread 
%                        then uctxt_bieq (uctxt pd) (ZMap.get id (AbstractDataType.uctxt ladt))
%                        (* then uctxt pd =  ZMap.get id (AbstractDataType.uctxt ladt) *)
%                        else if zlt_lt TOTAL_CPU id num_proc then  uctxt_bieq (uctxt pd) 
%                                                                              (ZMap.get id (AbstractDataType.uctxt ladt))
%                             else True
%                      (* The following things are for thread spawn related_RData.
%                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
%                                    However, instead of using dummy True, I decided to add the precise value 
%                                    to handle the case. This should be much better then the dummy True *)
%                      else if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True
%                      (* else  if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True *)
%      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
%      (* I can use the precise definition which I commented out instead of the version that contains the True value.
%                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
%                    and init_dproc in EAsm and TAsm.
%                    So, for the simplicity, I will use the current version *)
%      else if zeq id main_thread 
%           then  uctxt pd = ZMap.get id (AbstractDataType.uctxt ladt)
%           else if zlt_lt TOTAL_CPU id num_proc then  uctxt pd = uctxt (thread_init_dproc id) else True.
%
%    Definition relate_SyncChanPool_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
%      if (init sd) then 
%        (* check only and only if the current thread is protected by acquire_lock *)
%        (* it will consider the current channel / do not care about other channels *)
%        if B_inLock (CPU_ID sd) (big_log sd) then 
%          if zeq id (proc_id sd) 
%          then syncchpool pd = AbstractDataType.syncchpool ladt
%          else True (* don't care about other's syncpool *) 
%        else match (big_log sd) with 
%               | BigDef nil => (* if we never call lock at all the value should be initialized value
%                                                      - need this one in sched_init function proof *)
%                 syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef)
%               | BigDef _ => True
%               | _ => False (* if the system is initialized, this case should not happen *)
%             end
%      (* initial state need to be matched for all threads *)
%      (* case analysis is required for sched_init  - look at the difference between 
%         main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
%      else if zeq id main_thread  
%           then syncchpool pd = (ZMap.init SyncChanUndef)
%           else syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef).
%
%    Record E2PBThreadGenPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
%           (ladt : AbstractDataType.RData) :=
%      mkE2PBThreadGenPerDInv {
%
%          dirty_page_per_thread_inv:
%            forall res i, ZMap.get i (pperm pd) = PGUndef -> ZMap.get res (HP pd) = ZMap.get res (FlatMem.free_page i (HP pd))
%          
%        }.
%
%    Record relate_RData_per_pd  (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
%           (ladt : AbstractDataType.RData) :=
%      mkrelate_RData_per_pd {
%          (* for shared data parts - it's duplicated, but ok *)
%          vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
%          CR3_re: CR3 sd = AbstractDataType.CR3 ladt;
%          pg_re:  pg sd =  AbstractDataType.pg ladt;
%          nps_re: nps sd = AbstractDataType.nps ladt;
%          init_re: init sd = AbstractDataType.init ladt;
%          lock_re: lock sd = AbstractDataType.lock ladt;
%          
%          CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
%          cid_re: if init sd
%                  then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
%                  else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
%                       (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
%                        then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
%                        else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
%          idpde_re: idpde sd = AbstractDataType.idpde ladt;
%          kctxt_re: kctxt_val= ZMap.get id (AbstractDataType.kctxt ladt);
%          big_log_re: big_log sd = AbstractDataType.big_log ladt;
%          big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;
%
%          (* flatmem - may need an extra relation to prove the equality for load, store, and copy. 
%                     - See E2PBThreadGenDef.v file *)
%          (* flatmem_re: FlatMem.flatmem_inj (HP pd) (AbstractDataType.HP ladt); *)
%          flatmem_re: forall v ofs TY,
%                        ZMap.get ((v * PgSize + ofs mod PgSize) / PgSize) (pperm pd) = PGAlloc ->
%                        ofs mod 4096 <= 4096 - size_chunk TY ->
%                        (align_chunk TY | ofs mod PgSize) -> 
%                        FlatMem.load TY (HP pd) (v * PgSize + ofs mod PgSize) =
%                        FlatMem.load TY (AbstractDataType.HP ladt) (v * PgSize + ofs mod PgSize);
%          
%          (* except the running thread, all other threads should have the default value 
%           - necessary for yield and sleep case *)
%          ikern_re: if zeq id (proc_id sd) then ikern pd = AbstractDataType.ikern ladt else ikern pd = true;
%
%          (* except the running thread, all other threads should have the default value 
%           - necessary for yield and sleep case *)
%          ihost_re: if zeq id (proc_id sd) then ihost pd = AbstractDataType.ihost ladt else ihost pd = true;
%          
%          (* main_thread is (CPU_ID adt + 1) now. The constraint - 
%             all ID in the full_thread_list should satisfy the following constraint:
%             (forall l, proc_id (uRData l) /in full_thread_list) /\ 
%             (forall i, i /in full_thread_list -> i = i = main_thread \/ TOTAL_CPU < i < num_proc) *)
%          AC_re: relate_AC_per_pd  id sd pd ladt;
%           
%          (* we assume that ti will be setted as a default value when the kernel 
%             exit to the user process (by trapout) - for the precise implementation, we may need to 
%             change the definition of trapout? *)
%          ti_re: if zeq id (proc_id sd) then ti pd = AbstractDataType.ti ladt else  ti pd = init_trap_info;
%
%          (* may need an extra relationship in here for mutex property? *)
%          pperm_re: pperm_inject (pperm pd) (AbstractDataType.pperm ladt);
%          
%          (* case analysis is required for sched_init  - look at the difference between 
%             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
%          PT_re: if init sd 
%                 then if zeq id (proc_id sd) then PT pd = AbstractDataType.PT ladt else PT pd = 0
%                 else if zeq id main_thread then PT pd = -1 else PT pd = 0;
%
%          (* ptpool initialization is not setting def val for all i. So I will keep the 
%             whole ptpool in each pd, but will check each entry of each thread's ptpool for simulation *)
%          (* only need to check the ptpool for each thread *)
%          (* case analysis is required for sched_init  - look at the difference between 
%             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
%          (* main_thread is 0 now, but need to change it later as (CPU_ID adt) + 1 *)
%          ptp_re: if init sd 
%                  then ZMap.get id (ptpool pd) = ZMap.get id (AbstractDataType.ptpool ladt)
%                  else if zeq id main_thread then ptpool pd = (AbstractDataType.ptpool ladt) 
%                       else ptpool pd = CalRealPT.real_pt (AbstractDataType.ptpool ladt);
%
%          (* except the running thread, all other threads should have the default value  - necessary for yield and sleep case *)
%          ipt_re: if zeq id (proc_id sd) then ipt pd = AbstractDataType.ipt ladt else ipt pd = true;
%
%          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
%          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)
%          intr_flag_re: if zeq id (proc_id sd) then intr_flag pd = AbstractDataType.intr_flag ladt else intr_flag pd = true;
%
%          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
%          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)          
%          in_intr_re: if zeq id (proc_id sd) then in_intr pd = AbstractDataType.in_intr ladt else in_intr pd = false;
%
%          (* from com1_re to drv_serial_re ----
%             for the simplicity, I assume that main_thread = dev_handling_cid. 
%             If we change the number of main_thread as (CPU_ID adt) + 1, then, this assumption doesn't 
%             geneate any nonsensical cases. I can remove this assumption (main_thread = dev_handling_cid), 
%             but, then, I need an another case analysis for init_dproc in (EAsm.v and TAsm.v files) 
%             to handle them *)
%          com1_re: if zeq id dev_handling_cid then com1 pd = AbstractDataType.com1 ladt else True;
%
%          console_re: if zeq id dev_handling_cid then console pd = AbstractDataType.console ladt else True;
%
%          console_concrete_re: if zeq id dev_handling_cid 
%                               then console_concrete pd = AbstractDataType.console_concrete ladt else True;
%
%          ioapic_re: if zeq id dev_handling_cid 
%                     then ioapic pd = AbstractDataType.ioapic ladt else True;
%
%          lapic_re: if zeq id dev_handling_cid 
%                    then lapic pd = AbstractDataType.lapic ladt else True;
%
%          curr_intr_num_re: if zeq id dev_handling_cid 
%                            then curr_intr_num pd = AbstractDataType.curr_intr_num ladt else True;
%
%          drv_serial_re: if zeq id dev_handling_cid 
%                         then drv_serial pd = AbstractDataType.drv_serial ladt else True;
%
%          (* concept: ok. I'll not care the actual match state of syncchpool except the case 
%             when we call acquire_lock, which we have to match the syncchpool with thread-machine with 
%             CPU-machine *)
%          (* we can optimize this definition 
%             - e.g. we can check only one syncchan value related to the lock id. Then, I may be able to 
%               remove some definitions. 
%           *)
%          syncchpool_re: relate_SyncChanPool_per_pd id sd pd ladt;
%          uctxt_re: relate_uctxt_per_pd id sd pd ladt;
%
%          ept_re: if zeq id vm_handling_cid
%                  then ept pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.ept ladt)
%                  else True;
%          vmcs_re: if zeq id vm_handling_cid
%                   then vmcs pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmcs ladt)
%                   else True;
%          vmx_re: if zeq id vm_handling_cid
%                  then vmx pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmx ladt)
%                  else True;
%
%          inv_re: E2PBThreadGenPerDInv id kctxt_val sd pd ladt
%        }.
%
%    Record E2PBThreadGenEmptyPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (ladt : AbstractDataType.RData) :=
%      mkE2PBThreadGenEmptyPerDInv {
%
%        }.
%
%
%    Record E2PBThreadGenSharedDInv (kctxt_pool : KContextPool) (sd : sharedData) (ladt : AbstractDataType.RData) :=
%      mkE2PBThreadGenSharedDInv {
%
%          dirty_page_shared_inv:
%            forall res i, ZMap.get i (AbstractDataType.pperm ladt) = PGUndef ->
%                          ZMap.get res (AbstractDataType.HP ladt) = ZMap.get res (FlatMem.free_page i (AbstractDataType.HP ladt));
%          
%          init_big_log_inv: init sd = false -> big_log sd = BigUndef;
%          init_pperm_inv: init sd = false -> AbstractDataType.pperm ladt = ZMap.init PGUndef;
%          init_uctxt_inv: init sd = false -> AbstractDataType.uctxt ladt = ZMap.init (ZMap.init Vundef);
%         
%          syncchpool_inv:  
%              BigLogThreadConfigFunction.B_inLock (CPU_ID sd) (big_log sd) = false ->
%              BigLogThreadConfigFunction.B_GetlastPush (CPU_ID sd) (big_log sd) 
%              = AbstractDataType.syncchpool ladt;
%          
%          container_used_inv :
%            forall tid, In tid full_thread_list -> B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) 
%                                                   = cused (ZMap.get tid (AbstractDataType.AC ladt));
%
%          uctxt_used_inv :
%            forall tid, B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) = false ->
%                        ZMap.get tid (AbstractDataType.uctxt ladt) = ZMap.init Vundef;
%
%          
%          valid_AT_log_inv: valid_AT_log_type_B (big_log sd); 
%          valid_TCB_log_inv: valid_TCB_log_type_B (big_log sd);
%          big_oracle_inv: valid_big_oracle (big_oracle sd);
%
%          valid_B_Cal_AT_log_inv: forall i l atable, 
%                                    ZMap.get i (AbstractDataType.pperm ladt) <> PGUndef ->
%                                    (AbstractDataType.big_log ladt) = BigDef l ->
%                                    B_CalAT_log_real l = Some atable ->
%                                    ZMap.get i atable = ATValid true ATNorm
%        }.
%
%    Record E2PBThreadGenSharedMemInv (pdpool: ZMap.t (option privData)) :=
%      mkE2PBThreadGenSharedMemInv {
%          
%          pperm_disjoint: 
%            forall i j pd pd',
%              i <> j ->
%              ZMap.get i pdpool = Some pd ->
%              ZMap.get j pdpool = Some pd' ->
%              (forall j, ZMap.get j (pperm pd) <> PGUndef ->
%                         ZMap.get j (pperm pd')= PGUndef)
%        }.
%
%    Record relate_RData (kctxt_pool : KContextPool)  (sd : sharedData)  (pdpool: ZMap.t (option privData))
%           (ladt : AbstractDataType.RData) :=
%      mkrelate_RData {
%          
%          sh_vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
%          sh_CR3_re: CR3 sd= AbstractDataType.CR3 ladt;
%          sh_pg_re:  pg sd =  AbstractDataType.pg ladt;
%          sh_nps_re: nps sd = AbstractDataType.nps ladt;
%          sh_init_re: init sd = AbstractDataType.init ladt;
%          sh_lock_re: lock sd = AbstractDataType.lock ladt;
%          
%          sh_CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
%          sh_cid_re: if init sd
%                     then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
%                     else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
%                          (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
%                           then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
%                           else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
%          sh_idpde_re: idpde sd = AbstractDataType.idpde ladt;
%          sh_kctxt_re: kctxt_pool = (AbstractDataType.kctxt ladt);
%          sh_big_log_re: big_log sd = AbstractDataType.big_log ladt;
%          sh_big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;
%          
%          per_data_re: forall i,
%                         match ZMap.get i pdpool with 
%                           | Some pd => relate_RData_per_pd i (ZMap.get i kctxt_pool) sd pd ladt
%                           | _ => E2PBThreadGenEmptyPerDInv i (ZMap.get i kctxt_pool)  sd ladt
%                         end;
%          
%          sh_shared_inv_re: E2PBThreadGenSharedDInv kctxt_pool sd ladt;
%          
%          sh_mem_inv_re: E2PBThreadGenSharedMemInv pdpool 
%                                                    
%        }.
%\end{lstlisting}
