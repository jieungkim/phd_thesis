\section{Multithreaded Linking for CertiKOS}
\label{chapter:certikos:sec:multithreaded-linking-for-certikos}


Multithreaded linking in $\certikos$ is connecting the top layer in the per-CPU layer interface with
the corresponding bottom layer in the per-thread layer interface. 
In that purpose, multithreaded linking framework~\ref{chapter:linking:sec:multithreaded-linking} 
has been applied to the $\certikos$ to prove the contextual refinement proof between the program running on the layers associated with different machine models.
Using the framework requires us to define concrete instances 
of the abstract definitions that the framework relies on (in Figure~\ref{fig:chapter:linking:multithreaded-linking-structure});
the thread configuration ($C$), the concrete instance of three layers ($\CSched$, $\TLink$, and $\TSched$), 
as well as the two abstract relations between those layers ($\codeinmath{AbsRelC}$ and $\codeinmath{AbsRelT}$). 

This section first show the concrete definition of $\CSched$ in $\certikos$, which we name it $\codeinmath{PHThrd}$. 
While explaining the layer interface by providing a small subset of the layer's definition as well as the machine model ($\lasmmach$)
alongside the layer.

We then show how we instantiate thread configurations as well as several abstract definitions provided by our multithreaded linking framework, and we have proved that these abstract definitions satisfy the requirements of our toolkit.
Using them, we also define an intermediate layer interface (we call it $\codeinmath{PHBThrd}$) that will be used as a layer instance of $\TLink$ and is a layer that is associated with $\tasmmach$, $\ieasmmach$, as well as $\easmmach$.
It also includes  the explanation of the proof between the program with  $\codeinmath{PHThrd}$ on $\lasmmach$ 
with $\codeinmath{PHBThrd}$ on $\easmmach$. 
This work consists of two part:  (1) define the refinement relation based on the implementation, which is an instance of $\codeinmath{AbsRelC}$ between two states of two different machine models,
$\lasmmach(\PLayer{\codeinmath{PHThrd}}{cid}{\oracle_{cid}})$ and 
$\easmmach(\parallel tid \in T_{[cid]} \PLayer{\codeinmath{PHBThrd}}{tid}{\oracle_{cid}}$); and 
(2) show that all transition rules (\ie, instructions and primitive calls) preserve the refinement relation. 

The next part is how the concrete definition of  $\TSched$ in $\certikos$, which we name it $\codeinmath{PBThrd}$. 
While explaining the layer interface by providing a small subset of the layer's definition as well as the machine model ($\hasmmach$)
alongside the layer.
Similar to the previous case, 
It also includes  the explanation of the proof between the program with  $\codeinmath{PHBThrd}$ on $\tasmmach$ 
with $\codeinmath{PHThrd}$ on $\hasmmach$. 
This work consists of two part:  (1) define the refinement relation based on the implementation, which is an instance of $\codeinmath{AbsRelT}$ between two states of two different machine models,
$\tasmmach(\PLayer{\codeinmath{PHBThrd}}{tid}{\oracle^{MTLink}_{tid}})$ and 
$\hasmmach(\PLayer{\codeinmath{PHThrd}}{tid}{\oracle_{tid}})$; and 
(2) show that all transition rules (\ie, instructions and primitive calls) preserve the refinement relation. 

After separating these three components, proving the main theorem for multithreaded-linking is straightforward by connecting 
them with our multithreaded lining framework.