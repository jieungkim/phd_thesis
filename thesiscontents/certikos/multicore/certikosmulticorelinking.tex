\section{Multicore Linking for CertiKOS}
\label{chapter:certikos:sec:multicore-linking-for-certikos}

Similar to the multithreaded linking instances in Section~\ref{chapter:certikos:sec:multithreaded-linking-for-certikos}\jieung{Need to write that part}, a few steps are required us to provide the multicore linking for $\certikos$.
For the linking with $\certikos$
our goal is facilitating all the intermediate languages
and proofs in Section~\ref{chapter:linking:sec:multicore-linking},
and
Figure~\ref{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking} and 
Section~\ref{chapter:linking:sec:multicore-linking} show all definitions and 
proofs that the linking for $\certikos$ wants to use. 
To use them, 
Instantiating hardware setting (HardWareSetting) and the local program transition rules (HardSemantics) 
(defined in Figure~\ref{fig:chapter:conlink:hardware-local-step-transition-rules})
are required. 

With the concrete definitions for those abstract configurations, 
The one thing that we required for the linking (without getting any benefits from the framework and the library)
is providing the evidence that any program on the $\codeinmath{MBoot}$ layer with $\codeinmath{Mach}_{\lasm}$ is contextually refined by the program on the $\codeinmath{MBoot}$ layer with $\singleseparatestepkwd$, which is the adjacent machine model with $\codeinmath{Mach}_{\lasm}$ in our multicore linking framework. This proof is not provided by our multicore linking library toolkit because it heavily depends on the definition of the $\codeinmath{Mach}_{\lasm}$ layer.

Without those two things, 
providing the proof instances for other parts is straightforward with our library. 
By connecting the configuration instances and our machine (and proof) libraries, 
we are able to use  all refinement proofs in Section~\ref{chapter:linking:sec:multicore-linking}. 
This guarantees that ``any program on the $\codeinmath{MBoot}$ layer with $\singleseparatestepkwd$ contextually refines that program on the $\codeinmath{MBoot}$ layer with $\hardwarestepkwd$ (which is the non-deterministic $\intelmachine$ multicore semantics).''
Thanks to our framework, most proofs in this step can be directly achieved by applying the existing refinement proofs in our library.
%
