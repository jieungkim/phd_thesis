\section{Multicore Linking for CertiKOS}
\label{chapter:certikos:sec:multicore-linking-for-certikos}

Multicore linking in CertiKOS facilitates all the intermediate languages
and proofs in Section~\ref{chapter:linking:sec:multicore-linking}.
Figure~\ref{fig:chapter:conlink:intermediate-languages-and-their-relationsihps-for-multicore-linking} and 
Section~\ref{chapter:linking:sec:multicore-linking} show all definitions and 
proofs that connect all those things. 
However, to build the local layer interface, 
Instantiating the hardware configuration, 
use the concrete definition $L$, which will be the 
bottom layer of our local layer interface, 
and combine those intermediate languages and proofs with $\compcert$ semantic and backward simulation 
forms to connect them rigorously. 

\input{thesiscontents/certikos/hardwareconfinstance}
\input{thesiscontents/certikos/intermediatemachines}


\subsection{Connect Layers on Multicore Machine and CPU-Local Machine}
\label{chapter:certikos:subsec:connect-multicore}

All refinement proofs in Section~\ref{chapter:linking:sec:multicore-linking} are also applicable 
to those instances. 
All those proofs requires the additional refinement proofs for between adjacent step relations, but they can 
use the corresponding theorems in Section~\ref{chapter:linking:sec:multicore-linking}. 
For example, the refinement proof between an environmental step machine with a single core and the environmental step machine with full core set is 
as follows:
\begin{lstlisting}[language=C]
Lemma one_step_env_refines_env_concrete:
  forall st t st' st0
    (Hone: env_step_single_aux_ge' ge st t st')
    (Hmatch: match_eestate_link st st0),
    (exists st0',
      (plus env_step_full_aux_ge') ge st0 t st0' /\
        match_eestate_link st' st0') \/
      ((state_measure (s_set current_CPU_ID) st' < state_measure (s_set current_CPU_ID) st)%nat /\ t = E0 /\
        match_eestate_link st' st0).
Proof.
  <@$\cdots$@>
   eapply single_env_step_refines_full_env_step in Hone; eauto.
   <@$\cdots$@>
Qed.
\end{lstlisting}
, which uses the proof in Section~\ref{chapter:linking:subsec:concurrent-machine-model}.
Using those theorems, 
we prove the backward simulation proofs (in $\compcert$ style) 
\begin{lstlisting}[language=C]
Theorem cl_backward_simulation:
  forall (s: stencil) (CTXT: LAsm.module) (ph: AST.program fundef unit)
           (Hmakep: make_program (module_ops:= LAsm.module_ops) s CTXT 
           (mboot <@$\oplus$@> L64) = OK ph),
  backward_simulation
   (env_semantics (s_set current_CPU_ID) single_oracle
   (Hmakege := make_program_globalenv (make_program_ops := make_program_ops)
      _ _ _ _ Hmakep) (Genv.globalenv ph) s CTXT ph)
   (env_semantics core_set hw_oracle
   (Hmakege := make_program_globalenv (make_program_ops := make_program_ops) 
     _ _ _ _ Hmakep) (Genv.globalenv ph) s CTXT ph).
\end{lstlisting}

The top level theorem for multicore linking uses the backward simulation proofs 
for each steps that we have described in Section~\ref{chapter:linking:sec:multicore-linking}.
The top level theorem is in Figure~\ref{fig:chapter:certikos:top-level-multicore-theorem}.

\begin{figure}
\begin{lstlisting}[language=C]
Theorem concurrent_backward_simulation:
  forall (s: stencil) (CTXT: LAsm.module) (ph: AST.program fundef unit)
    (Hmakep: make_program (module_ops:= LAsm.module_ops) s CTXT (mboot <@$\oplus$@> L64) = OK ph),
    backward_simulation
    (LAsm.semantics (lcfg_ops := LC (mboot <@$\oplus$@> L64)) ph)          
    (hwstep_semantics 
      (Hmakege := make_program_globalenv (make_program_ops := make_program_ops) 
      _ _ _ _ Hmakep) (Genv.globalenv ph) s CTXT ph).
\end{lstlisting}
\caption{Top Level Multicore Linking Theorem}
\label{fig:chapter:certikos:top-level-multicore-theorem}
\end{figure}

The proof, of course has several assumptions. 
\jieung{need to mention assumptions}

