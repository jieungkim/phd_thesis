\section{Multicore Linking for CertiKOS}
\label{chapter:certikos:sec:multicore-linking-for-certikos}

Multicore linking in CertiKOS facilitates all the intermediate languages
and proofs in Section~\ref{chapter:linking:sec:multicore-linking}.

\subsection{Hardware Configuration Instance}
\label{chapter:certikos:subsec:hardware-configuration-instance}

The hardware configuration in Section~\ref{chapter:linking:subsec:hardware-configuration} works as a 
template for users to instantiate all intermediate machine models in multicore linking. 

To show the instantiation,
we briefly show the state definition of $\compcertx$. 
The $\compcertx$ state is defined as

\begin{figure}
\begin{lstlisting}[language=Caml]
Function get_last_event (l: MultiLogType) :=
  match l with
  | MultiUndef => None
  | MultiDef nil => Some OINIT
  | MultiDef (e:: l) =>
    match e with
    | TEVENT _ e0 =>
      match e0 with
      | TTICKET e1 =>
        match e1 with
        | INC_TICKET n => Some (OINC_TICKET n)
        | INC_NOW => Some OINC_NOW       
        | GET_NOW => Some OGET_NOW
        | HOLD_LOCK => Some OHOLD_LOCK
        | _ => None
        end
      | TSHARED (OBUFFERE b) => Some (OPAGE_COPY b)
      | _ => None
      end
    end
  end.
\end{lstlisting} 
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Caml]
 Inductive state `{memory_model_ops: Mem.MemoryModelOps mem}: Type :=
  | State: regset -> mem -> state.
\end{lstlisting}
\end{figure}


\begin{figure}

\begin{lstlisting}[language=Caml]
  Local Open Scope Z_scope.

  Definition genv := Genv.t fundef unit.
    
  // to determine PC from the state 
  Inductive command_predicate (ge: genv): mstate -> command -> Prop :=
  | acq_prim_call:
      forall b ef rs m lid index ofs sig,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        sig = mksignature (AST.Tint::AST.Tint::nil) None cc_default ->
        extcall_arguments rs m sig (Vint index :: Vint ofs :: nil) ->
        index2Z (Int.unsigned index) (Int.unsigned ofs) = Some lid ->
        match ef with
          | EF_external eid _ => 
            if peq eid acquire_shared then True
            else False
          | _ => False
        end ->
        command_predicate ge (Asm.State rs m) (ACQ_SHARED lid)

  | rel_prim_call:
      forall b ef rs m lid index ofs sig,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        sig = mksignature (AST.Tint::AST.Tint::nil) None cc_default ->
        extcall_arguments rs m sig (Vint index :: Vint ofs :: nil) ->
        index2Z (Int.unsigned index) (Int.unsigned ofs) = Some lid ->
        match ef with
          | EF_external eid _ => 
            if peq eid release_shared then True
            else False
          | _ => False
        end ->
        command_predicate ge (Asm.State rs m) (REL_SHARED lid)
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Caml]
  | command_prim_atomic:
      forall b ef rs m lid index ofs sig eid,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        atomic_id eid ->
        eid <> page_copy ->
        match ef with
          | EF_external eid' _ =>
            if peq eid eid' then True
            else False
          | _ => False
        end ->
        sig = mksignature (AST.Tint::AST.Tint::nil) None cc_default ->
        extcall_arguments rs m sig (Vint index :: Vint ofs :: nil) ->
        index2Z (Int.unsigned index) (Int.unsigned ofs) = Some lid ->
        command_predicate ge (Asm.State rs m) (ATOMIC lid eid)

  | command_prim_page_copy:
      forall b ef rs m lid cv count from sig,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        match ef with
          | EF_external eid _ => 
            if peq eid page_copy then True
            else False
          | _ => False
        end ->
        sig = mksignature (AST.Tint::AST.Tint::AST.Tint::nil) None cc_default ->
        extcall_arguments rs m sig (Vint cv :: Vint count :: Vint from :: nil) ->
        index2Z ID_SC (slp_q_id (Int.unsigned cv) 0) = Some lid ->
        command_predicate ge (Asm.State rs m) (ATOMIC lid page_copy)
\end{lstlisting}
\end{figure}

\begin{figure}

\begin{lstlisting}[language=Caml]
  | command_prim_FAI:
      forall b ef rs m lid index ofs sig bound,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        match ef with
          | EF_external eid _ => 
            if peq eid atomic_FAI then True
            else False
          | _ => False
        end ->
        sig = mksignature (AST.Tint::AST.Tint::AST.Tint::nil) None cc_default ->
        extcall_arguments rs m sig (Vint bound :: Vint index :: Vint ofs :: nil) ->
        index2Z (Int.unsigned index) (Int.unsigned ofs) = Some lid ->
        command_predicate ge (Asm.State rs m) (ATOMIC lid atomic_FAI)

  | command_internal:
      forall b ofs f rs m,
        rs Asm.PC = Vptr b ofs ->
        Genv.find_funct_ptr ge b = Some (Internal f) ->
        command_predicate ge (Asm.State rs m) PRIVATE

  | command_prim_private:
      forall b ef rs m,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        match ef with
          | EF_external eid _ => 
            private_id eid
          | _ => True
        end ->
        command_predicate ge (Asm.State rs m) PRIVATE.
\end{lstlisting}
\end{figure}


\begin{figure}
\begin{lstlisting}[language=Caml]
  Global Instance hdseting: HardWaredSetting :=
    {
      private_state := mstate;
      shared_piece := list Integers.Byte.int;
      atomic_event := OtherEvent;
      atomic_event_ident := OtherEvent_2_ident;
      core_set := cpu_set;
      sched_id := 9
    }.
  Proof.
    - intros.
      eapply list_eq_dec. intros.
      eapply Byte.eq_dec.
    - repeat decide equality.
      eapply Int.eq_dec.
    - trivial.
  Defined.
\end{lstlisting}
\end{figure}

\begin{figure}

\begin{lstlisting}[language=Caml]
  // private execution - similar to Asm
  Inductive private_exec (ge: genv): Z -> mstate -> mstate -> Prop :=
    | private_step_internal:
        forall b ofs f i rs (m m': mwd LDATAOps) rs' cid,
        rs Asm.PC = Vptr b ofs ->
        Genv.find_funct_ptr ge b = Some (Internal f) ->
        find_instr (Int.unsigned ofs) f.(fn_code) = Some i ->
        exec_instr ge f i rs m = Next rs' m' ->
        CPU_ID (snd m) = cid ->
        private_exec ge cid (Asm.State rs m) (Asm.State rs' m')

  | private_step_builtin:
      forall b ofs f ef args res rs (m m': mwd LDATAOps) t vl rs' cid,
      rs Asm.PC = Vptr b ofs ->
      Genv.find_funct_ptr ge b = Some (Internal f) ->
      find_instr (Int.unsigned ofs) f.(fn_code) = Some (asm_instruction (Pbuiltin ef args res)) ->
      external_call' (fun _ => True) ef ge (map rs args) m t vl m' ->
      rs' = nextinstr_nf 
             (set_regs res vl
               (undef_regs (map preg_of (destroyed_by_builtin ef)) rs)) ->
      CPU_ID (snd m) = cid ->
     //  [CertiKOS:test-compcert-disable-extcall-as-builtin] We need
     // to disallow the use of external function calls (EF_external) as
     //  builtins. 
      forall BUILTIN_ENABLED: match ef with
                                | EF_external _ _ => False
                                | _ => True
                              end,
    // [CompCertX:test-compcert-wt-builtin] We need to prove that registers updated by builtins are
    // of the same type as the return type of the builtin. 
      forall BUILTIN_WT: 
               subtype_list (proj_sig_res' (ef_sig ef)) (map typ_of_preg res) = true,
        private_exec ge cid (Asm.State rs m) (Asm.State rs' m')
\end{lstlisting}
\end{figure}

\begin{figure}

\begin{lstlisting}[language=Caml]
  | private_step_annot:
      forall b ofs f ef args rs (m m': mwd LDATAOps) vargs t v cid,
      rs Asm.PC = Vptr b ofs ->
      Genv.find_funct_ptr ge b = Some (Internal f) ->
      find_instr (Int.unsigned ofs) f.(fn_code) = Some (asm_instruction (Pannot ef args)) ->
      annot_arguments rs m args vargs ->
      external_call' (fun _ => True) ef ge vargs m t v m' ->
      CPU_ID (snd m) = cid ->
      forall BUILTIN_ENABLED: match ef with
                                | EF_external _ _ => False
                                | _ => True
                              end,
      private_exec ge cid (Asm.State rs m)
           (Asm.State (nextinstr rs) m')

    | private_step_external:
        forall b ef args res rs (m m': mwd LDATAOps) t rs' cid,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        extcall_arguments rs m (ef_sig ef) args ->
        external_call' (fun _ => True) ef ge args m t res m' ->
        rs' = (set_regs (loc_external_result (ef_sig ef)) res 
                        (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil) 
                                    (undef_regs (map preg_of destroyed_at_call) rs))) 
                #Asm.PC <- (rs RA) #RA <- Vundef ->
        CPU_ID (snd m) = cid ->
        forall STACK:
        forall b o, rs ESP = Vptr b o ->
                    (Ple (Genv.genv_next ge) b /\ Plt b (Mem.nextblock m)),
        forall SP_NOT_VUNDEF: rs ESP <> Vundef,
        forall RA_NOT_VUNDEF: rs RA <> Vundef,
        private_exec ge cid (Asm.State rs m) (Asm.State rs' m')

    | private_step_prim_call:
        forall b ef rs (m m': mwd LDATAOps) t rs' cid,
          rs Asm.PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          primitive_call ef ge rs m t rs' m' ->
          CPU_ID (snd m) = cid ->
          private_exec ge cid (Asm.State rs m) (Asm.State rs' m').
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Caml]
    // shared executions - get and set    
    Inductive get_shared_sem (ge: genv) : mstate -> list Integers.Byte.int -> mstate -> Prop:=
    | get_shared_intro: 
        forall rs sig m a index ofs id l b size ml0 z,
          Genv.find_symbol ge id = Some b
          -> id2size (Int.unsigned index) = Some (size, id)
          -> Mem.loadbytes m b 0 size = Some (ByteList l)
          -> sig = mksignature (AST.Tint::AST.Tint::nil) None cc_default
          -> extcall_arguments rs m sig (Vint index :: Vint ofs ::nil) ->
          forall (Hindex: index2Z (Int.unsigned index) (Int.unsigned ofs) = Some z)
            (Hlog: ZMap.get z (multi_log a) = MultiDef ml0),
            let rs' := (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF
                                       :: IR EAX :: RA :: nil)
                                   (undef_regs (List.map preg_of destroyed_at_call) rs)) in
            let a' := a {multi_log: ZMap.set z (MultiDef (TEVENT (CPU_ID a) (TSHARED (OMEME l)) :: ml0))
                                             (multi_log a)} in
            get_shared_sem ge (Asm.State (mem:= mwd LDATAOps) rs (m, a)) l 
                           (Asm.State (rs'#RA <- Vundef#Asm.PC <- (rs RA)) (m, a')).
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Caml]
    Inductive set_shared_sem (ge: genv) : mstate -> option (list Integers.Byte.int) -> mstate -> Prop:=
    | set_shared_sem_intro: 
        forall rs sig m m' a index ofs id l b size ml0 z,
          Genv.find_symbol ge id = Some b
          -> id2size (Int.unsigned index) = Some (size, id)
          -> match l with
               | Some l' => Mem.storebytes m b 0 (ByteList l') = Some m'
               | _ => m' = m
             end
          -> sig = mksignature (AST.Tint::AST.Tint::nil) None cc_default
          -> extcall_arguments rs m sig (Vint index :: Vint ofs :: nil) ->
          forall (Hindex: index2Z (Int.unsigned index) (Int.unsigned ofs) = Some z)
                 (Hlog: ZMap.get z (multi_log a) = MultiDef ml0),
            let rs' := (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF
                                       :: IR EAX :: RA :: nil)
                                   (undef_regs (List.map preg_of destroyed_at_call) rs)) in
            let a' := a {multi_log: ZMap.set z (MultiDef (TEVENT (CPU_ID a) (TSHARED OPULL) :: ml0))
                                             (multi_log a)} in
            set_shared_sem ge (Asm.State (mem:= mwd LDATAOps) rs (m, a)) l 
                           (Asm.State (rs'#RA <- Vundef#Asm.PC <- (rs RA)) (m', a')).
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Caml]
    // atomic executions 
    Inductive atomic_exec (ge: genv): Z -> Z -> mstate -> Log -> mstate -> OtherEvent -> Prop :=
    | atomic_step_external:
        forall b ef args res rs (m m': mwd LDATAOps) t rs' cid e id sl,
        rs Asm.PC = Vptr b Int.zero ->
        Genv.find_funct_ptr ge b = Some (External ef) ->
        extcall_arguments rs m (ef_sig ef) args ->
        external_call' (fun _ => True) ef ge args m t res m' ->
        rs' = (set_regs (loc_external_result (ef_sig ef)) res (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil) (undef_regs (map preg_of destroyed_at_call) rs))) #Asm.PC <- (rs RA) #RA <- Vundef ->
        get_last_event (ZMap.get id (multi_log (snd m'))) = Some e ->
        forall STACK:
        forall b o, rs ESP = Vptr b o ->
                    (Ple (Genv.genv_next ge) b /\ Plt b (Mem.nextblock m)),
        forall SP_NOT_VUNDEF: rs ESP <> Vundef,
        forall RA_NOT_VUNDEF: rs RA <> Vundef,
          atomic_exec ge cid id (Asm.State rs m) sl (Asm.State rs' m') e

    | atomic_step_prim_call:
        forall b ef rs (m m': mwd LDATAOps) t rs' cid  e id sl,
          rs Asm.PC = Vptr b Int.zero ->
          Genv.find_funct_ptr ge b = Some (External ef) ->
          primitive_call ef ge rs m t rs' m' ->
          get_last_event (ZMap.get id (multi_log (snd m'))) = Some e ->
          atomic_exec ge cid id (Asm.State rs m) sl (Asm.State rs' m') e.
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Caml]
      
      Variables (ge: genv) (sten: stencil) (M: module).
      Context {Hmakege: make_globalenv (module_ops:= LAsm.module_ops) (mkp_ops:= make_program_ops) 
                                       sten M (mboot <@$\oplus$@> L64) = ret ge}.
      
      Local Obligation Tactic := intros.
      
      Global Program Instance hdsem : HardSemantics (hdset:= hdseting)
        :=
          {
            PC := command_predicate ge;
            private_step := private_exec ge;
            get_shared := get_shared_sem ge;
            set_shared := set_shared_sem ge;
            atomic_step := atomic_exec ge
          }.
\end{lstlisting}
\end{figure}


\clearpage
\subsection{Intermediate Machine Instantiation}
\label{chapter:certikos:subsec:intermediate-machine-instantiation}

Our intermediate machine models are abstract languages, but 
our goal is connecting them with backward simulation proofs in $\compcert$. 
For that purpose, 
we need to instantiate those abstract languages to make them fit into 
the semantics definition in $\compcert$.


\begin{lstlisting}[language=Caml]
    Variables (ge: genv) (sten: stencil) (M: module).
    Context {Hmakege: make_globalenv (module_ops:= LAsm.module_ops) (mkp_ops:= make_program_ops) 
                                     sten M (mboot <@$\oplus$@> L64) = ret ge}.
    
    Local Obligation Tactic := intros.
    
    Definition hdsem_instance := @hdsem mem memory_model_ops Hmem Hmwd real_params_ops oracle_ops0
                                        oracle_ops big_ops builtin_idents_norepet_prf ge sten M Hmakege.
    
    // now, define a concrete semantics for single core machine
    Definition hw_step_aux :=
      @hardware_step hdseting hdsem_instance pmap current_CPU_ID.
      
    Inductive hw_step_aux_ge : genv -> hstate -> trace -> hstate -> Prop :=
    | hw_step_aux_ge_intro : 
        forall s t s',
            hw_step_aux s t s' -> hw_step_aux_ge ge s t s'.
    
    Inductive hwstep_initial_state (p: AST.program fundef unit): 
      (hstate (hdset := hdseting)) -> Prop := 
    | initial_hwstep_state_intro: 
        forall (m0: mwd LDATAOps),
          Genv.init_mem p = Some m0 ->
          let ge := Genv.globalenv p in
          let rs0 :=
              (Pregmap.init Vundef)
                # Asm.PC <- (symbol_offset ge p.(prog_main) Int.zero)
                # ESP <- Vzero in
          hwstep_initial_state p (HState current_CPU_ID (pinit (B := core_set) (Asm.State rs0 m0)) nil).

    Definition hwstep_final_state (s : hstate (hdset := hdseting)) (i : int) : Prop :=
      False.
      
         
    Definition hwstep_semantics (p: program) :=
      Smallstep.Semantics hw_step_aux_ge (hwstep_initial_state p) 
                          hwstep_final_state (Genv.globalenv p).
    
\end{lstlisting}


\begin{lstlisting}[language=Caml]
   
    Variables (ge: genv) (sten: stencil) (M: module).
    Context {Hmakege: make_globalenv (module_ops:= LAsm.module_ops) (mkp_ops:= make_program_ops) 
                                     sten M (mboot <@$\oplus$@> L64) = ret ge}.
    
    Local Obligation Tactic := intros.
    
    Definition hdsem_instance := @hdsem mem memory_model_ops Hmem Hmwd real_params_ops oracle_ops0
                                        oracle_ops big_ops builtin_idents_norepet_prf ge sten M Hmakege.

    // now, define a concrete semantics for single core machine
    Definition oracle_step_aux :=
      @oracle_step zset_op hdseting op_general hdsem_instance pmap hw_oracle.

    Inductive oracle_step_aux_ge : genv -> state -> trace -> state -> Prop :=
    | oracle_step_aux_ge_intro : 
        forall s t s',
          oracle_step_aux s t s' -> oracle_step_aux_ge ge s t s'.

    Inductive oracle_initial_state (p: AST.program fundef unit): 
      (state (hdset := hdseting)) -> Prop := 
    | initial_oracle_state_intro: 
        forall (m0: mwd LDATAOps),
          Genv.init_mem p = Some m0 ->
          let ge := Genv.globalenv p in
          let rs0 :=
              (Pregmap.init Vundef)
                # Asm.PC <- (symbol_offset ge p.(prog_main) Int.zero)
                # ESP <- Vzero in
          oracle_initial_state p (State current_CPU_ID 
                                        (pset current_CPU_ID (LState (Asm.State rs0 m0) true)
                                              (pinit (B := core_set) (LState (Asm.State rs0 m0) false)))
                                        nil).

    Definition oracle_final_state (s : state (hdset := hdseting)) (i : int) : Prop :=
      False.
      
    Definition oracle_semantics (p: program) :=
      Smallstep.Semantics oracle_step_aux_ge (oracle_initial_state p) 
                          oracle_final_state (Genv.globalenv p). 
\end{lstlisting}



\begin{lstlisting}[language=Caml]
    Variable cores : ZSet.
    Variable o : GeneralOracleType.
    Variables (ge: genv) (sten: stencil) (M: module).
    Context {Hmakege: make_globalenv (module_ops:= LAsm.module_ops) (mkp_ops:= make_program_ops) 
                                     sten M (mboot <@$\oplus$@> L64) = ret ge}.
    
    Local Obligation Tactic := intros.
    
    Definition hdsem_instance := @hdsem mem memory_model_ops Hmem Hmwd real_params_ops oracle_ops0
                                        oracle_ops big_ops builtin_idents_norepet_prf ge sten M Hmakege.
    
    // now, define a concrete semantics for single core machine 
    Definition env_step_aux:=
      @env_step zset_op hdseting op_general hdsem_instance pmap cores o.
    
    Inductive env_step_aux_ge : genv -> (estate (A:= cores))  -> trace -> (estate (A:= cores)) -> Prop :=
    | env_step_aux_ge_intro : 
        forall s t s',
          env_step_aux s t s' -> env_step_aux_ge ge s t s'.
    
    Inductive env_initial_state (p: AST.program fundef unit): 
      (estate (A := cores) (hdset := hdseting)) -> Prop :=
    | initial_env_state_intro: 
        forall (m0: mwd LDATAOps),
          Genv.init_mem p = Some m0 ->
          let ge := Genv.globalenv p in
          let rs0 :=
              (Pregmap.init Vundef)
                # Asm.PC <- (symbol_offset ge p.(prog_main) Int.zero)
                # ESP <- Vzero in
          env_initial_state p (EState current_CPU_ID 
                                      (pset current_CPU_ID (LState (Asm.State rs0 m0) true)
                                            (pinit (B := cores) (LState (Asm.State rs0 m0) false)))
                                      nil).
    

    Definition env_final_state (s : estate (A:=cores) (hdset := hdseting)) (i : int) : Prop :=
      False.
      

    Definition env_semantics (p: program) :=
      Smallstep.Semantics env_step_aux_ge (env_initial_state p) 
                          env_final_state (Genv.globalenv p).
    
\end{lstlisting}



\begin{lstlisting}[language=Caml]

    Variables (ge: genv) (sten: stencil) (M: module).
    Context {Hmakege: make_globalenv (module_ops:= LAsm.module_ops) (mkp_ops:= make_program_ops) 
                                     sten M (mboot <@$\oplus$@> L64) = ret ge}.

    Local Obligation Tactic := intros.
    
    Definition hdsem_instance := @hdsem mem memory_model_ops Hmem Hmwd real_params_ops oracle_ops0
                                        oracle_ops big_ops builtin_idents_norepet_prf ge sten M Hmakege.

    // now, define a concrete semantics for reorder  machine 
    Definition single_step_aux :=
      @single_step zset_op hdseting op_general hdsem_instance 
                   current_CPU_ID single_oracle.

    Inductive single_step_aux_ge : genv -> single_state -> trace -> single_state -> Prop :=
    | single_step_aux_ge_intro : 
        forall s t s',
          single_step_aux s t s' -> single_step_aux_ge ge s t s'.

    Inductive single_initial_state (p: AST.program fundef unit): 
      (single_state (hdset := hdseting)) -> Prop :=
    | initial_single_state_intro: 
        forall (m0: mwd LDATAOps),
          Genv.init_mem p = Some m0 ->
          let ge := Genv.globalenv p in
          let rs0 :=
              (Pregmap.init Vundef)
                # Asm.PC <- (symbol_offset ge p.(prog_main) Int.zero)
                # ESP <- Vzero in
          single_initial_state p (SState current_CPU_ID (LState (Asm.State rs0 m0) true) nil).

    Definition single_final_state (s : single_state (hdset := hdseting)) (i : int) : Prop :=
      False.
      
    Definition single_semantics (p: program) :=
      Smallstep.Semantics single_step_aux_ge (single_initial_state p) 
                          single_final_state (Genv.globalenv p).

\end{lstlisting}


\begin{lstlisting}[language=Caml]
\end{lstlisting}

\begin{lstlisting}[language=Caml]
\end{lstlisting}

\begin{lstlisting}[language=Caml]
\end{lstlisting}

\begin{lstlisting}[language=Caml]
\end{lstlisting}

\begin{lstlisting}[language=Caml]
\end{lstlisting}


\begin{lstlisting}[language=Caml]
\end{lstlisting}


\clearpage
\subsection{Connect Layers on Multicore Machine and CPU-Local Machine}
\label{chapter:certikos:subsec:connect-multicore}

\begin{lstlisting}[language=Caml]
    Variables (ge: genv) (sten: stencil) (M: module).
    Context {Hmakege: make_globalenv (module_ops:= LAsm.module_ops) (mkp_ops:= make_program_ops) 
                                       sten M (mboot <@$\oplus$@>  L64) = ret ge}.

    Definition hdsem_instance := @hdsem mem memory_model_ops Hmem Hmwd real_params_ops oracle_ops0
                                        oracle_ops big_ops builtin_idents_norepet_prf ge sten M Hmakege.

    Definition oracle_step_aux_ge' :=
      @oracle_step_aux_ge mem memory_model_ops Hmem Hmwd
                          real_params_ops oracle_ops0 oracle_ops big_ops
                          builtin_idents_norepet_prf pmap zset_op mc_oracle
                          ge sten M Hmakege.

    Definition hw_step_aux_ge' :=
      @hw_step_aux_ge mem memory_model_ops Hmem Hmwd
                      real_params_ops oracle_ops0 oracle_ops big_ops
                      builtin_idents_norepet_prf pmap
                      ge sten M Hmakege.
                      
    Definition match_state_link := match_state (hdset := hdseting) (pmap := pmap) current_CPU_ID.
    
    Hint Unfold match_state_link.
    Existing Instance op_general.                      
                      
\end{lstlisting}

\begin{lstlisting}[language=Caml]


    // backward refinement
    Lemma one_step_hw_refines_oracle_concrete:
      forall s s0 s' t
             (Hone: hw_step_aux_ge' ge s t s')
             (Hmatch: match_state_link s0 s),
      exists s0',
        plus oracle_step_aux_ge' ge s0 t s0'
        /\ match_state_link s0' s'.
    Proof.

  Theorem cl_backward_simulation:
    forall (s: stencil) (CTXT: LAsm.module) (ph: AST.program fundef unit)
           (Hmakep: make_program (module_ops:= LAsm.module_ops) s CTXT (mboot <@$\oplus$@> L64) = OK ph),
      backward_simulation
        (oracle_semantics 
           (Hmakege := make_program_globalenv (make_program_ops := make_program_ops) _ _ _ _ Hmakep)
           (Genv.globalenv ph) s CTXT ph)
        (hwstep_semantics 
           (Hmakege := make_program_globalenv (make_program_ops := make_program_ops) _ _ _ _ Hmakep)
           (Genv.globalenv ph) s CTXT ph).
  Proof.
\end{lstlisting}

Connecting all proofs for mluticore linking is then possible by using the result of previous sections.