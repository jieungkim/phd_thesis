\section{Multithreaded Linking for CertiKOS}
\label{chapter:certikos:sec:multithreaded-linking-for-certikos}

Multithreaded linking for $\certikos$ is connecting the top-most layer of CPU layer
 interface with
the corresponding bottom-most layer in the thread layer interface. 
The biggest difference between those two layers is 
the way to handle scheduling primitive. 



\section{Top-most Layer of CPU Layer Interface}
\label{chapter:certikos:subsec:pbthread}

The top-most layer in our CPU machine is ``pbthread''.


\jieung{Need to mention about few specs - sleep spawn yield}



\subsection{Multithreaded Configuration Instance}
\label{chapter:certikos:subsec:multithreaded-configuration-instance}

Two big challenge in here is related initial state of thread local machines; 
1) how we assing the initial state; 2) how we prove the invariant about initial state 
of each thread. 
Both of them are possible by using our global log. 

\begin{lstlisting}[language=C]
  Record sharedData :=
    mk_sharedData {
        CPU_ID: Z; (**r current CPU_ID *)
        MM: MMTable; (**r table of the physical memory's information*)
        MMSize: Z; (**r size of MMTable*)
        vmxinfo: VMXInfo; (**r information of vmx*)
        CR3: globalpointer; (**r abstract of CR3, stores the pointer to page table*)
        pg: bool; (**r abstract of CR0, indicates whether the paging is enabled or not*)
        cid: ZMap.t Z; (**r current thread id*)
        nps: Z; (**r number of the pages*)
        init: bool; (**r pure logic flag, show whether the initialization at this layer has been called or not*)
        idpde: IDPDE; (**r shared identity maps *)
        big_log: BigLogType;
        big_oracle: BigOracle
      }.
\end{lstlisting}

\begin{lstlisting}[language=C]
  Record privData :=
    mk_privData {
        ti: trapinfo; (**r abstract of CR2, stores the address where page fault happens*)

        ikern: bool; (**r pure logic flag, shows whether it's in kernel mode or not*)
        ihost: bool; (**r logic flag, shows whether it's in the host mode or not*)         


        HP: flatmem; (**r we model the memory from 1G to 3G as heap*)

        AC : Container; (**r container tree for all agents *)
        
        uctxt : UContext; (**r user context pool*)

        pperm: PPermT; (**r physical page permission table *) (* need fancy merging *)

        PT: Z; (**r the current page table index*) 
        ptpool: PMapPool; (**r page table pool*)
        ipt: bool; (**r pure logic flag, shows whether the current page map is the kernel's page map*)
        
        syncchpool : SyncChanPool; (**r the channel pool for synchronous IPC*)
        buffer: PageBufferPool; (**r page buffer in the IPC module*)

        ept: EPT; (**r nested page table for guest mode*)
        vmcs: VMCS; (**r virtual machine control structure for current VM *)
        vmx: VMX;  (**r VMX structure to store the extra registers of host *) 

        com1: SerialData; (**r serial port COM1*)
        drv_serial: SerialDriver; (**r serial driver states*)
        console_concrete: ConsoleDriverConcrete; (**r console driver states concrete implementation*)
        console: ConsoleDriver; (**r console driver states*)

        ioapic: IoApicData; (**r I/O Advanced Programmable Interrupt Controller *)
        lapic: LApicData; (**r Local Advanced Programmable Interrupt Controller *)
        tf: TrapFrames; (**r Trap frame automatically pushed by CPU *)
        tf_reg: val; (** temporary place to save an intermediate tf regiter *) 
        curr_intr_num: Z; (**r current interrupt vector number *)
        intr_flag: bool; 
        saved_intr_flags: list bool;

        in_intr: bool; (**r in the interrupt handler *)
        i_dev_serial: bool (**r in the critical section of operating serial *)
      }.
\end{lstlisting}

\begin{lstlisting}[language=C]
    Definition prim_thread_init_pc {F V} (ge : Genv.t F V) (name : ident) (args : list lval): option val :=
      if peq name proc_create
      then match Genv.find_symbol ge START_USER_FUN_LOC with
           | Some b' => Some (Vptr b' Int.zero)
           | _ => None
           end
      else None.

    Definition cal_init_dproc (pv_adt : dproc) (parent: Z) (q: Z) (buc : block) (uc_ofs : int): dproc:= 
      let uctx0 := uctxt pv_adt in
      let uctx1 := ZMap.set U_SS CPU_GDT_UDATA
                            (ZMap.set U_CS CPU_GDT_UCODE 
                                      (ZMap.set U_DS CPU_GDT_UDATA
                                                (ZMap.set U_ES CPU_GDT_UDATA uctx0))) in
      (* U_EIP will be setted as zero for initial low level invariant proofs  
        - To enable this one, I changed proc start and exit semantic rules 
          we can optimize it later (after we port our version into the new layer framework *)
      let uctx2 := ZMap.set U_EIP Vzero
                            (ZMap.set U_EFLAGS FL_IF 
                                      (ZMap.set U_ESP (Vint STACK_TOP) uctx1)) in
      (pv_adt {pv_AC: (mkContainer q 0 parent nil true)} {pv_uctxt: uctx2}).

    Fixpoint thread_init_dproc_iter (curid: Z) (l : Log) : option dproc :=
      match l with 
      | nil => None (* we may be able to remove this case *)
      | ev::l' => 
        match ev with 
        | LEvent id ev_detail =>
          match ev_detail with 
          | LogPrim name largs new_id _=>
            if peq name proc_create 
            then if zeq curid new_id (* the function to calculate new_id is defined in ObjPHBThreadreplayfunction.v file *) 
                 then match largs with 
                      | (Lint elf_id)::(Lptr buc uc_ofs)::(Lint q)::nil =>
                        match (zle_lt (id * Constant.max_children + 1) curid (id * Constant.max_children 
                                                                              + 1 + Constant.max_children),
                               zlt_lt Constant.TOTAL_CPU curid num_proc,
                               zle_le 0 (Int.unsigned q) Int.max_unsigned,
                               pg (update init_shared_adt l), 
                               init (update init_shared_adt l)) with    
                        (* from here - need to be consistent with  dnew_semantics in layerlib/PrimSemantics.v *) 
                        (* this is the case that has the corresponding spawn and return the initialized private adt *)
                        (* q is the initial quota / id is a parent of this thread *)
                        (* id: parent / q : quota / curid : child *)
                        | (left _, left _, left _, true, true) 
                          => Some (cal_init_dproc nomain_init_priv_adt id (Int.unsigned q) buc uc_ofs)
                        | ((*_, _, *) _, _, _, _) => None
                        end
                      | _ => None 
                      end
                 else thread_init_dproc_iter curid l'
            else thread_init_dproc_iter curid l'
          | _ => thread_init_dproc_iter curid l'
          end
        end
      end.
    
    Definition thread_init_dproc_aux (curid: Z) (l : Log) : option dproc :=
      if zeq curid main_thread 
      then match l with 
           | nil => Some main_init_dproc 
           | _ => None
           end
      else thread_init_dproc_iter curid l.

    Definition thread_init_dproc (curid: Z) : dproc :=
      match thread_init_dproc_aux curid init_log with
      | Some init_dproc_val => init_dproc_val
      | _ => if zeq curid main_thread then main_init_dproc else nomain_init_priv_adt
      end.
\end{lstlisting}

\begin{lstlisting}[language=C]
Definition has_event (name : ident) :=
  if peq name palloc then true else 
    if peq name pt_resv then true else
      if peq name proc_create then true else
        if peq name thread_wakeup then true else
          if peq name sched_init then true else
            if peq name acquire_lock_CHAN then true else
              if peq name release_lock_CHAN then true else
                if peq name ipc_send_body then true else false.
\end{lstlisting}

\begin{lstlisting}[language=C]
    Definition choice_check (name : ident) (largs : list lval) (sd: sharedData) (pd: privData) : Z :=
      match prim_id_num name with 
      | palloc_num =>
        match largs with 
        |  (Lint n)::nil => single_big_palloc_spec_test (Int.unsigned n) (sd, pd)
        | _ => 42
        end
      | pt_resv_num => 
        match largs with 
        | (Lint n)::(Lint vadr)::(Lint perm)::nil => single_big_ptResv_spec_test (Int.unsigned n) 
                                                                                 (Int.unsigned vadr)
                                                                                 (Int.unsigned perm) (sd, pd)
        | _ => 42
        end
      | proc_create_num =>
        match largs with 
        | (Lint elf_id)::(Lptr buc uc_ofs)::(Lint q)::nil => single_big_proc_create_spec_test 
                                                               (sd, pd) buc uc_ofs (Int.unsigned q)
        | _ => 0
        end
      | _ => 42 (* wrong case that should not be called *)
      end.
\end{lstlisting}

\begin{lstlisting}[language=C]
    Definition apply_event (ev : LogEvent) (adt : dshare) : option dshare := 
      match ev with 
      | LEvent tid ev_unit =>
        match ev_unit with 
        | LogPrim prim_id args choice dSnapShot =>
          match prim_id_num prim_id with 
          | palloc_num =>
            match args with 
            |  (Lint n)::nil =>
               (* 0 means no allocation due to the usage of container and 1 means allocation trial happens *)
               match single_big_palloc_spec_share (Int.unsigned n) choice adt with 
               | Some (adt', _) => Some adt'
               | _ => None 
               end
            | _ => None
            end
            <@$\cdots$@>
            
    Fixpoint update (adt: dshare) (sh_log : Log) {struct sh_log} : dshare :=
      match sh_log with
      | nil => adt
      | hd::tl => let adt' := update adt tl in 
                  match apply_event hd adt' with 
                  | Some adt'' => adt'' 
                  | _ => adt' 
                  end
      end.

    Lemma update_invariant (I: dshare -> Prop):
      (forall e d d', apply_event e d = Some d' -> I d -> I d') ->
      (forall d l, I d -> I (update d l)).
    Proof.
      induction l; simpl; eauto.
      destruct (apply_event a _) eqn:Hd'; eauto.
    Qed.
\end{lstlisting}

\begin{lstlisting}[language=C]
  Definition thread_init_pc {F V} (ge: Genv.t F V) (e : LogEvent) :=
    match e with
      | LEvent _ (LogPrim f args new_id _) => match prim_thread_init_pc ge f args with 
                                            | Some pc => Some (new_id, pc)
                                            | _ => None
                                            end
      | _ => None
    end.

  Definition thread_init_pc_of {F V} ge (i : Z) (e : LogEvent) : option val :=
    match thread_init_pc (F:=F) (V:=V) ge e with
      | Some (j, pc) => if decide (i = j) then Some pc else None
      | None => None
    end.

  (** Using [thread_init_pc], we can extract the initial program
    counter for a thread from any log. The initial state of the main
    thread is hardcoded to point to main() as set by [make_program],
    and is already available with an empty log. For other threads,
    this function will compute their initial states by examining the
    log for a corresponding spawn event. *)

  Fixpoint initial_thread_pc {F V} (ge: Genv.t F V) i (l : Log) : option val :=
    match l with
      | e :: l' =>
        match initial_thread_pc ge i l' with
          | Some pc => Some pc
          | None => thread_init_pc_of ge i e
        end
      | nil =>
        match decide (i = main_thread) with
          | left _ => Some (symbol_offset ge 1%positive Int.zero)
          | right _ => None
        end
    end.

  Definition initial_regset_state pc :=
    (Pregmap.init Vundef) # PC <- pc # ESP <- Vzero.

  Definition initial_thread_state {F V} (ge: Genv.t F V) i l : option regset :=
    match initial_thread_pc ge i l with
      | Some pc => Some (initial_regset_state pc)
      | None => None
    end.

  (** Before we "return" into a (non-main) thread that is scheduled
    for the first time, the saved context has a slightly different
    format, where the code pointer is stored in [RA]. *)

  Definition initial_regset_kctxt pc :=
    (Pregmap.init Vundef) # RA <- pc # ESP <- Vzero.

  Definition initial_thread_kctxt {F V} (ge: Genv.t F V) i l : option regset :=
    match initial_thread_pc ge i l with
      | Some pc => Some (initial_regset_kctxt pc)
      | None => None
    end.
    
  Definition init_mem_lift_nextblock (m: mem) :=
    match init_log with
      | nil => m
      | _::_ => mem_lift_nextblock m (Pos.to_nat (last_nb init_log) -
                                      Pos.to_nat (Mem.nextblock m))
    end.

\end{lstlisting}

\begin{lstlisting}[language=C]
    Program Instance s_oracle_prf : SingleOracle (single_data := AuxSingleAbstractDataType.single_data) 
                                                 (single_oracle_ops := s_oracle_ops) 
                                                 (threads_conf_ops := s_threads_ops):=
      { 
        has_event := has_event;
        update := update;
        thread_init_dproc := thread_init_dproc;
        state_check := state_check;
        sync_chpool_check := ObjPHBThreadReplayFunction.sync_chpool_check;
        snap_func := snap_func;
        snap_rev_func := snap_rev_func;
        choice_check := ObjPHBThreadReplayFunction.choice_check;
        PHThread2TCompose := PHThread2TComposeData.combine_data;
        prim_thread_init_pc := @prim_thread_init_pc
      }.
\end{lstlisting}

\subsection{Layer on Intermediate Languages in Multithreaded Linking}
\label{chapter:certikos:subsec:layer-on-intermediate-languages-in-multithreaded-linking}

Our intermediate layer definition has a different state definition (not only for the memory and registers, but also for the abstract data); thus we also provide the 
layer that can be used for those intermediate machine models. 
In addition to that, our intermediate machine models has explicit 
transition rules for yield ans sleep. 
They are defined in the lanuage level 

\jieung{Need to mention about few specs - spawn}

\section{Bottom-most Layer of Thread Layer Interface}
\label{chapter:certikos:subsec:phthread}

The bottom most layer definition has the exactly same set of primitives with those in 
the top-most layer definition of CPU-local layers. 

\jieung{Need to mention about few specs - sleep spawn }


\subsection{Connect Layers on Per-CPU Machine with Per-Thread Machine}
\label{chapter:certikos:subsec:multithreaded-connect}

By using the framework discussed in the previous chapter, connecting them to provide the backward simulation proofs is striaghtforward.
It, however, relies on two bg assumptions, 
AbstractRel and AbstractRelT as we have discussed. 

All assumptions need to be addressed correctly.

\subsubsection{AbstractRel}

This provides the relation bewteen PHBThread layer runs with EAsm and PBThread layer runs with LAsm. 

\begin{lstlisting}[language=C]
    Definition pperm_inject (ha_ppermtable : PPermT) (la_ppermtable : PPermT) : Prop := 
      forall i, 
        match ZMap.get i ha_ppermtable, ZMap.get i la_ppermtable with 
          | PGUndef, _ => True
          | PGAlloc, PGAlloc => True 
          | PGHide ho, PGHide lo => ho = lo
          | _, _ => False
        end.
    
    Definition B_GetContainerUsed' (tid: Z) (cid : Z) (big_log: BigLogType) : bool :=
      match big_log with 
      | BigUndef => false
      | BigDef l => B_GetContainerUsed tid cid l
      end.

    Definition relate_AC_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
                        (* I can use the precise definition which I commented out instead of the version 
                                      that contains the True value. But, if I do that, I have to redefine init_dproc
                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
                                      So, for the simplicity, I will use the current version *)
                        if zeq id main_thread 
                        then AC pd =  ZMap.get id (AbstractDataType.AC ladt)
                        else if zlt_lt TOTAL_CPU id num_proc then AC pd = ZMap.get id (AbstractDataType.AC ladt) 
                             else True
                      (* The following things are for thread spawn related_RData.
                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
                                    However, instead of using dummy True, I decided to add the precise value 
                                    to handle the case. This should be much better then the dummy True *)
                      else if zlt_lt TOTAL_CPU id num_proc then AC pd = AC (thread_init_dproc id) else True
      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
      (* I can use the precise definition which I commented out instead of the version that contains the True value.
                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
                    and init_dproc in EAsm and TAsm.
                    So, for the simplicity, I will use the current version *)
      else if zeq id main_thread 
           then (AC pd) = ZMap.get id (AbstractDataType.AC ladt) 
           else if zlt_lt TOTAL_CPU id num_proc then AC pd =  AC (thread_init_dproc id) else True.

    (*
    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
      (forall i, 0 <= i < UCTXT_SIZE -> 
                 i <> U_EIP ->
                 ZMap.get i huctx = ZMap.get i luctx) /\ 
      (exists v, ZMap.get U_EIP luctx = v).
    *)
      
    Definition uctxt_bieq (huctx : UContext) (luctx: UContext) :=
      match ZMap.get U_EIP huctx with 
        | Vint i => if Int.eq i (Int.repr 0) then 
                      (forall i, 0 <= i < UCTXT_SIZE -> 
                                 i <> U_EIP ->
                                 ZMap.get i huctx = ZMap.get i luctx) /\ 
                      (exists v, ZMap.get U_EIP luctx = v)
                    else huctx = luctx
        | Vundef => (forall i, 0 <= i < UCTXT_SIZE -> 
                               i <> U_EIP ->
                               ZMap.get i huctx = ZMap.get i luctx) /\ 
                    (exists v, ZMap.get U_EIP luctx = v)
        | _ => False
      end.

    Definition relate_uctxt_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
      if init sd then if B_GetContainerUsed' id (CPU_ID sd) (big_log sd) then 
                        (* the following cases are necessary to reflects the correct behaviour of the initialization *)
                        (* I can use the precise definition which I commented out instead of the version 
                                      that contains the True value. But, if I do that, I have to redefine init_dproc
                                      related definitions in SingleAbstractDataType and init_dproc in EAsm and TAsm.
                                      So, for the simplicity, I will use the current version *)
                        if zeq id main_thread 
                        then uctxt_bieq (uctxt pd) (ZMap.get id (AbstractDataType.uctxt ladt))
                        (* then uctxt pd =  ZMap.get id (AbstractDataType.uctxt ladt) *)
                        else if zlt_lt TOTAL_CPU id num_proc then  uctxt_bieq (uctxt pd) 
                                                                              (ZMap.get id (AbstractDataType.uctxt ladt))
                             else True
                      (* The following things are for thread spawn related_RData.
                                    I can put dummy True in this 'else' case, and prove the case for thread_spawn. 
                                    However, instead of using dummy True, I decided to add the precise value 
                                    to handle the case. This should be much better then the dummy True *)
                      else if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True
                      (* else  if zlt_lt TOTAL_CPU id num_proc then uctxt pd = uctxt (thread_init_dproc id) else True *)
      (* the following cases are necessary to reflects the correct behaviour of the initialization *)
      (* I can use the precise definition which I commented out instead of the version that contains the True value.
                    But, if I do that, I have to redefine init_dproc related definitions in SingleAbstractDataType 
                    and init_dproc in EAsm and TAsm.
                    So, for the simplicity, I will use the current version *)
      else if zeq id main_thread 
           then  uctxt pd = ZMap.get id (AbstractDataType.uctxt ladt)
           else if zlt_lt TOTAL_CPU id num_proc then  uctxt pd = uctxt (thread_init_dproc id) else True.

    Definition relate_SyncChanPool_per_pd (id : Z) (sd : sharedData) (pd: privData) (ladt : AbstractDataType.RData) :=
      if (init sd) then 
        (* check only and only if the current thread is protected by acquire_lock *)
        (* it will consider the current channel / do not care about other channels *)
        if B_inLock (CPU_ID sd) (big_log sd) then 
          if zeq id (proc_id sd) 
          then syncchpool pd = AbstractDataType.syncchpool ladt
          else True (* don't care about other's syncpool *) 
        else match (big_log sd) with 
               | BigDef nil => (* if we never call lock at all the value should be initialized value
                                                      - need this one in sched_init function proof *)
                 syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef)
               | BigDef _ => True
               | _ => False (* if the system is initialized, this case should not happen *)
             end
      (* initial state need to be matched for all threads *)
      (* case analysis is required for sched_init  - look at the difference between 
         main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
      else if zeq id main_thread  
           then syncchpool pd = (ZMap.init SyncChanUndef)
           else syncchpool pd = real_syncchpool (ZMap.init SyncChanUndef).

    Record E2PBThreadGenPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
           (ladt : AbstractDataType.RData) :=
      mkE2PBThreadGenPerDInv {

          dirty_page_per_thread_inv:
            forall res i, ZMap.get i (pperm pd) = PGUndef -> ZMap.get res (HP pd) = ZMap.get res (FlatMem.free_page i (HP pd))
          
        }.

    Record relate_RData_per_pd  (id : Z) (kctxt_val : KContext) (sd : sharedData) (pd : privData)
           (ladt : AbstractDataType.RData) :=
      mkrelate_RData_per_pd {
          (* for shared data parts - it's duplicated, but ok *)
          vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
          CR3_re: CR3 sd = AbstractDataType.CR3 ladt;
          pg_re:  pg sd =  AbstractDataType.pg ladt;
          nps_re: nps sd = AbstractDataType.nps ladt;
          init_re: init sd = AbstractDataType.init ladt;
          lock_re: lock sd = AbstractDataType.lock ladt;
          
          CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
          cid_re: if init sd
                  then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
                  else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
                       (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
                        then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
                        else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
          idpde_re: idpde sd = AbstractDataType.idpde ladt;
          kctxt_re: kctxt_val= ZMap.get id (AbstractDataType.kctxt ladt);
          big_log_re: big_log sd = AbstractDataType.big_log ladt;
          big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;

          (* flatmem - may need an extra relation to prove the equality for load, store, and copy. 
                     - See E2PBThreadGenDef.v file *)
          (* flatmem_re: FlatMem.flatmem_inj (HP pd) (AbstractDataType.HP ladt); *)
          flatmem_re: forall v ofs TY,
                        ZMap.get ((v * PgSize + ofs mod PgSize) / PgSize) (pperm pd) = PGAlloc ->
                        ofs mod 4096 <= 4096 - size_chunk TY ->
                        (align_chunk TY | ofs mod PgSize) -> 
                        FlatMem.load TY (HP pd) (v * PgSize + ofs mod PgSize) =
                        FlatMem.load TY (AbstractDataType.HP ladt) (v * PgSize + ofs mod PgSize);
          
          (* except the running thread, all other threads should have the default value 
           - necessary for yield and sleep case *)
          ikern_re: if zeq id (proc_id sd) then ikern pd = AbstractDataType.ikern ladt else ikern pd = true;

          (* except the running thread, all other threads should have the default value 
           - necessary for yield and sleep case *)
          ihost_re: if zeq id (proc_id sd) then ihost pd = AbstractDataType.ihost ladt else ihost pd = true;
          
          (* main_thread is (CPU_ID adt + 1) now. The constraint - 
             all ID in the full_thread_list should satisfy the following constraint:
             (forall l, proc_id (uRData l) /in full_thread_list) /\ 
             (forall i, i /in full_thread_list -> i = i = main_thread \/ TOTAL_CPU < i < num_proc) *)
          AC_re: relate_AC_per_pd  id sd pd ladt;
           
          (* we assume that ti will be setted as a default value when the kernel 
             exit to the user process (by trapout) - for the precise implementation, we may need to 
             change the definition of trapout? *)
          ti_re: if zeq id (proc_id sd) then ti pd = AbstractDataType.ti ladt else  ti pd = init_trap_info;

          (* may need an extra relationship in here for mutex property? *)
          pperm_re: pperm_inject (pperm pd) (AbstractDataType.pperm ladt);
          
          (* case analysis is required for sched_init  - look at the difference between 
             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
          PT_re: if init sd 
                 then if zeq id (proc_id sd) then PT pd = AbstractDataType.PT ladt else PT pd = 0
                 else if zeq id main_thread then PT pd = -1 else PT pd = 0;

          (* ptpool initialization is not setting def val for all i. So I will keep the 
             whole ptpool in each pd, but will check each entry of each thread's ptpool for simulation *)
          (* only need to check the ptpool for each thread *)
          (* case analysis is required for sched_init  - look at the difference between 
             main_init_priv_adt and nomain_init_priv_adt in singleprocessor/AuxSingleAbstractData.v file *)
          (* main_thread is 0 now, but need to change it later as (CPU_ID adt) + 1 *)
          ptp_re: if init sd 
                  then ZMap.get id (ptpool pd) = ZMap.get id (AbstractDataType.ptpool ladt)
                  else if zeq id main_thread then ptpool pd = (AbstractDataType.ptpool ladt) 
                       else ptpool pd = CalRealPT.real_pt (AbstractDataType.ptpool ladt);

          (* except the running thread, all other threads should have the default value  - necessary for yield and sleep case *)
          ipt_re: if zeq id (proc_id sd) then ipt pd = AbstractDataType.ipt ladt else ipt pd = true;

          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)
          intr_flag_re: if zeq id (proc_id sd) then intr_flag pd = AbstractDataType.intr_flag ladt else intr_flag pd = true;

          (* we may be able to use dev_handling_cid in intr_flag and in_intr too. But, the current version may be fine now *)
          (* except the running thread, all other threads should have the default value - necessary for yield and sleep case *)          
          in_intr_re: if zeq id (proc_id sd) then in_intr pd = AbstractDataType.in_intr ladt else in_intr pd = false;

          (* from com1_re to drv_serial_re ----
             for the simplicity, I assume that main_thread = dev_handling_cid. 
             If we change the number of main_thread as (CPU_ID adt) + 1, then, this assumption doesn't 
             geneate any nonsensical cases. I can remove this assumption (main_thread = dev_handling_cid), 
             but, then, I need an another case analysis for init_dproc in (EAsm.v and TAsm.v files) 
             to handle them *)
          com1_re: if zeq id dev_handling_cid then com1 pd = AbstractDataType.com1 ladt else True;

          console_re: if zeq id dev_handling_cid then console pd = AbstractDataType.console ladt else True;

          console_concrete_re: if zeq id dev_handling_cid 
                               then console_concrete pd = AbstractDataType.console_concrete ladt else True;

          ioapic_re: if zeq id dev_handling_cid 
                     then ioapic pd = AbstractDataType.ioapic ladt else True;

          lapic_re: if zeq id dev_handling_cid 
                    then lapic pd = AbstractDataType.lapic ladt else True;

          curr_intr_num_re: if zeq id dev_handling_cid 
                            then curr_intr_num pd = AbstractDataType.curr_intr_num ladt else True;

          drv_serial_re: if zeq id dev_handling_cid 
                         then drv_serial pd = AbstractDataType.drv_serial ladt else True;

          (* concept: ok. I'll not care the actual match state of syncchpool except the case 
             when we call acquire_lock, which we have to match the syncchpool with thread-machine with 
             CPU-machine *)
          (* we can optimize this definition 
             - e.g. we can check only one syncchan value related to the lock id. Then, I may be able to 
               remove some definitions. 
           *)
          syncchpool_re: relate_SyncChanPool_per_pd id sd pd ladt;
          uctxt_re: relate_uctxt_per_pd id sd pd ladt;

          ept_re: if zeq id vm_handling_cid
                  then ept pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.ept ladt)
                  else True;
          vmcs_re: if zeq id vm_handling_cid
                   then vmcs pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmcs ladt)
                   else True;
          vmx_re: if zeq id vm_handling_cid
                  then vmx pd = ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.vmx ladt)
                  else True;

          inv_re: E2PBThreadGenPerDInv id kctxt_val sd pd ladt
        }.

    Record E2PBThreadGenEmptyPerDInv (id : Z) (kctxt_val : KContext) (sd : sharedData) (ladt : AbstractDataType.RData) :=
      mkE2PBThreadGenEmptyPerDInv {

        }.


    Record E2PBThreadGenSharedDInv (kctxt_pool : KContextPool) (sd : sharedData) (ladt : AbstractDataType.RData) :=
      mkE2PBThreadGenSharedDInv {

          dirty_page_shared_inv:
            forall res i, ZMap.get i (AbstractDataType.pperm ladt) = PGUndef ->
                          ZMap.get res (AbstractDataType.HP ladt) = ZMap.get res (FlatMem.free_page i (AbstractDataType.HP ladt));
          
          init_big_log_inv: init sd = false -> big_log sd = BigUndef;
          init_pperm_inv: init sd = false -> AbstractDataType.pperm ladt = ZMap.init PGUndef;
          init_uctxt_inv: init sd = false -> AbstractDataType.uctxt ladt = ZMap.init (ZMap.init Vundef);
         
          syncchpool_inv:  
              BigLogThreadConfigFunction.B_inLock (CPU_ID sd) (big_log sd) = false ->
              BigLogThreadConfigFunction.B_GetlastPush (CPU_ID sd) (big_log sd) 
              = AbstractDataType.syncchpool ladt;
          
          container_used_inv :
            forall tid, In tid full_thread_list -> B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) 
                                                   = cused (ZMap.get tid (AbstractDataType.AC ladt));

          uctxt_used_inv :
            forall tid, B_GetContainerUsed' tid (CPU_ID sd) (big_log sd) = false ->
                        ZMap.get tid (AbstractDataType.uctxt ladt) = ZMap.init Vundef;

          
          valid_AT_log_inv: valid_AT_log_type_B (big_log sd); 
          valid_TCB_log_inv: valid_TCB_log_type_B (big_log sd);
          big_oracle_inv: valid_big_oracle (big_oracle sd);

          valid_B_Cal_AT_log_inv: forall i l atable, 
                                    ZMap.get i (AbstractDataType.pperm ladt) <> PGUndef ->
                                    (AbstractDataType.big_log ladt) = BigDef l ->
                                    B_CalAT_log_real l = Some atable ->
                                    ZMap.get i atable = ATValid true ATNorm
        }.

    Record E2PBThreadGenSharedMemInv (pdpool: ZMap.t (option privData)) :=
      mkE2PBThreadGenSharedMemInv {
          
          pperm_disjoint: 
            forall i j pd pd',
              i <> j ->
              ZMap.get i pdpool = Some pd ->
              ZMap.get j pdpool = Some pd' ->
              (forall j, ZMap.get j (pperm pd) <> PGUndef ->
                         ZMap.get j (pperm pd')= PGUndef)
        }.

    Record relate_RData (kctxt_pool : KContextPool)  (sd : sharedData)  (pdpool: ZMap.t (option privData))
           (ladt : AbstractDataType.RData) :=
      mkrelate_RData {
          
          sh_vmxinfo_re: vmxinfo sd  = AbstractDataType.vmxinfo ladt;
          sh_CR3_re: CR3 sd= AbstractDataType.CR3 ladt;
          sh_pg_re:  pg sd =  AbstractDataType.pg ladt;
          sh_nps_re: nps sd = AbstractDataType.nps ladt;
          sh_init_re: init sd = AbstractDataType.init ladt;
          sh_lock_re: lock sd = AbstractDataType.lock ladt;
          
          sh_CPU_ID_re: CPU_ID sd = AbstractDataType.CPU_ID ladt;
          sh_cid_re: if init sd
                     then (ZMap.get (CPU_ID sd) (cid sd)) = (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt))
                     else (ZMap.get (AbstractDataType.CPU_ID ladt) (AbstractDataType.cid ladt)) = 0 /\
                          (if zle_lt 0 (CPU_ID sd) TOTAL_CPU
                           then (ZMap.get (CPU_ID sd) (cid sd)) = ((CPU_ID sd) + 1)
                           else (ZMap.get (CPU_ID sd) (cid sd)) = 0);
          sh_idpde_re: idpde sd = AbstractDataType.idpde ladt;
          sh_kctxt_re: kctxt_pool = (AbstractDataType.kctxt ladt);
          sh_big_log_re: big_log sd = AbstractDataType.big_log ladt;
          sh_big_oracle_re: big_oracle sd = AbstractDataType.big_oracle ladt;
          
          per_data_re: forall i,
                         match ZMap.get i pdpool with 
                           | Some pd => relate_RData_per_pd i (ZMap.get i kctxt_pool) sd pd ladt
                           | _ => E2PBThreadGenEmptyPerDInv i (ZMap.get i kctxt_pool)  sd ladt
                         end;
          
          sh_shared_inv_re: E2PBThreadGenSharedDInv kctxt_pool sd ladt;
          
          sh_mem_inv_re: E2PBThreadGenSharedMemInv pdpool 
                                                    
        }.
\end{lstlisting}

\subsubsection{AbstractRelT}

This provides the relation bewteen PHThread layer runs with Hasm and PHBThread layer runs with TAsm. 

\begin{lstlisting}[language=C]

    Definition combine_data (kctxtOpt : option KContext) (sd : sharedData) (pd: privData) : AbstractDataType.RData :=
      {|
        AbstractDataType.CPU_ID:= CPU_ID sd;
        AbstractDataType.MM:= MM sd;
        AbstractDataType.MMSize:= MMSize sd;
        AbstractDataType.vmxinfo:= vmxinfo sd;

        AbstractDataType.CR3:= CR3 sd;

        AbstractDataType.ti:= ti pd;

        AbstractDataType.pg := pg sd;
        AbstractDataType.ikern:= ikern pd;
        AbstractDataType.ihost:= ihost pd;

        AbstractDataType.HP:= HP pd;

        AbstractDataType.cid := cid sd;
        AbstractDataType.multi_log:= ZMap.init MultiUndef;
        AbstractDataType.multi_oracle:= multi_oracle_init8;
        AbstractDataType.lock:= lock sd;
        
        AbstractDataType.AC:= ZMap.set (ZMap.get (CPU_ID sd) (cid sd)) (AC pd) (ZMap.init Container_unused); 

        AbstractDataType.AT:= (ZMap.init ATUndef);
        AbstractDataType.ATC:=  (ZMap.init ATCUndef);
        AbstractDataType.nps:= nps sd;
        AbstractDataType.init:= init sd;
        AbstractDataType.pperm:= pperm pd;

        AbstractDataType.PT:= PT pd;
        AbstractDataType.ptpool:= ptpool pd;
        AbstractDataType.idpde:= idpde sd;
        AbstractDataType.ipt:= ipt pd;
        AbstractDataType.LAT:= ZMap.init LATCUndef;
        AbstractDataType.smspool:=  ZMap.init (ZMap.init SHRDUndef);

        (* special treatment for kctxt *)
        AbstractDataType.kctxt:= match kctxtOpt with 
                                 | Some kctxt_val =>  ZMap.set (ZMap.get (CPU_ID sd) (cid sd)) kctxt_val 
                                                               (ZMap.init (Pregmap.init Vundef))
                                 | _ => (ZMap.init (Pregmap.init Vundef))
                                 end;
        
        AbstractDataType.sleeper:= init_sleeper;
        AbstractDataType.tcb:= ZMap.init TCBUndef;
        AbstractDataType.tdq:= ZMap.init TDQUndef;
        AbstractDataType.abtcb:= ZMap.init AbTCBUndef;
        AbstractDataType.abq:=  ZMap.init AbQUndef;
        AbstractDataType.syncchpool:= syncchpool pd;
        AbstractDataType.buffer:= buffer pd;
        
        AbstractDataType.big_log:= big_log sd;
        AbstractDataType.big_oracle:= big_oracle sd;
        
        AbstractDataType.uctxt:= (ZMap.set (ZMap.get (CPU_ID sd) (cid sd)) (uctxt pd)  (ZMap.init (ZMap.init Vundef)));
        
        AbstractDataType.ept:= (ZMap.set (CPU_ID sd) (ept pd) (ZMap.init (ZMap.init EPML4EUndef)));
        
        AbstractDataType.vmcs := (ZMap.set (CPU_ID sd) (vmcs pd) 
                                           (ZMap.init (VMCSValid Vzero Vzero (ZMap.init Vundef))));
        
        AbstractDataType.vmx := (ZMap.set (CPU_ID sd) (vmx pd) (ZMap.init (ZMap.init Vundef)));

        AbstractDataType.ts:= 0;

        AbstractDataType.com1:= com1 pd;
        AbstractDataType.drv_serial:= drv_serial pd;
        AbstractDataType.console_concrete:= console_concrete pd;
        AbstractDataType.console:= console pd;
        
        AbstractDataType.ioapic:= ioapic pd;
        AbstractDataType.lapic:= lapic pd; 
        AbstractDataType.tf:= tf pd;
        AbstractDataType.tf_reg:= tf_reg pd;
        AbstractDataType.curr_intr_num:= curr_intr_num pd;
        AbstractDataType.intr_flag:= intr_flag pd;
        AbstractDataType.saved_intr_flags:= saved_intr_flags pd;

        AbstractDataType.in_intr:= in_intr pd;
        AbstractDataType.i_dev_serial:= i_dev_serial pd;

        AbstractDataType.kbd:= kbd_init;
        AbstractDataType.kbd_drv:= kbd_drv_init
      |}.
\end{lstlisting}

\begin{lstlisting}[language=C]

  Section MATCH.
    Set Printing All.

    Record PHThread2TGenInv (kctxt_val : KContext) (hadt : AbstractDataType.RData) (l : Log) (pd : dproc) :=
      { 
        CPU_ID_inv: (AbstractDataType.CPU_ID hadt) = GlobalOracle.current_CPU_ID /\
                    CPU_ID (update init_shared_adt l) = GlobalOracle.current_CPU_ID;
        
        valid_big_oracle_inv: valid_big_oracle (AbstractDataType.big_oracle hadt) /\
                              valid_big_oracle (big_oracle (update init_shared_adt l))
      }.
    
    Record relate_RData (kctxt_val : KContext) (hadt : AbstractDataType.RData) (l : Log) (pd : dproc) :=
        mkrelate_RData {
            flatmem_re: (AbstractDataType.HP hadt) = (HP pd);
            vmxinfo_re: AbstractDataType.vmxinfo hadt = vmxinfo (update init_shared_adt l);
            CR3_re:  AbstractDataType.CR3 hadt = CR3 (update init_shared_adt l);
            ikern_re: AbstractDataType.ikern hadt = ikern pd;
            pg_re: AbstractDataType.pg hadt = pg (update init_shared_adt l);
            ihost_re: AbstractDataType.ihost hadt = ihost pd;
            AC_re: ZMap.get (ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt))
                            (AbstractDataType.AC hadt) = AC pd;
            ti_re: AbstractDataType.ti hadt = ti pd;
            
            nps_re: AbstractDataType.nps hadt = nps (update init_shared_adt l);
            init_re: AbstractDataType.init hadt = init (update init_shared_adt l);

            pperm_re: AbstractDataType.pperm hadt = pperm pd;
            PT_re: AbstractDataType.PT hadt = PT pd;
            ptp_re: AbstractDataType.ptpool hadt = ptpool pd;
            idpde_re: AbstractDataType.idpde hadt = idpde (update init_shared_adt l);
            ipt_re: AbstractDataType.ipt hadt = ipt pd;

            CPU_ID_re: AbstractDataType.CPU_ID hadt = CPU_ID (update init_shared_adt l);
            cid_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt)
                    = ZMap.get (CPU_ID (update init_shared_adt l)) (cid (update init_shared_adt l));
            lock_re: AbstractDataType.lock hadt = lock (update init_shared_adt l);

            com1_re: AbstractDataType.com1 hadt = com1 pd;
            console_re: AbstractDataType.console hadt = console pd;
            console_concrete_re: AbstractDataType.console_concrete hadt = console_concrete pd;
            ioapic_re: AbstractDataType.ioapic hadt = ioapic pd;
            lapic_re: AbstractDataType.lapic hadt = lapic pd;
            intr_flag_re: AbstractDataType.intr_flag hadt = intr_flag pd;
            curr_intr_num_re: AbstractDataType.curr_intr_num hadt = curr_intr_num pd;
            in_intr_re: AbstractDataType.in_intr hadt = in_intr pd;
            drv_serial_re: AbstractDataType.drv_serial hadt = drv_serial pd;

            kctxt_re: ZMap.get (ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt)) 
                               (AbstractDataType.kctxt hadt) = kctxt_val;
            uctxt_re: ZMap.get (ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.cid hadt))
                               (AbstractDataType.uctxt hadt) = uctxt pd;

            syncchpool_re: AbstractDataType.syncchpool hadt = syncchpool pd;

            big_log_re: AbstractDataType.big_log hadt = big_log (update init_shared_adt l);
            big_oracle_re: AbstractDataType.big_oracle hadt = big_oracle (update init_shared_adt l);
            
            ept_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.ept hadt) = ept pd;
            vmcs_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.vmcs hadt) = vmcs pd;
            vmx_re: ZMap.get (AbstractDataType.CPU_ID hadt) (AbstractDataType.vmx hadt) = vmx pd;
            
            inv_re: PHThread2TGenInv kctxt_val hadt l pd
          }.
                                                       
  End MATCH.

\end{lstlisting}


\subsection{Connecting Multithreaded Theorem}
\label{chapter:certikos:subsec:connecting-multithreaded-theroem}

\begin{lstlisting}[language=C]
  Theorem SingleCore_backward_simulation:
    forall (s: stencil) (CTXT: LAsm.module) (ph: AST.program fundef unit)
           (Hs: genv_next s = init_nb)
           (Hph: noglobvar ph) (* NB: decidable *)
           (Hmakep: make_program (module_ops:= LAsm.module_ops) s CTXT (phbthread <@$\oplus$@> L64) = OK ph),
      backward_simulation
        (HAsm.semantics (phthread  <@$\oplus$@>  L64) ph)
        (LAsm.semantics (lcfg_ops := LC (pbthread <@$\oplus$@> L64)) ph).
  Proof.
\end{lstlisting}


%
%\subsection{Layer Refinement for Thread Linking}\label{subsec:concrete-impl}
%
%From Sec.~\ref{subsec:lowlevelasm} to Sec.~\ref{subsec:hasm} ,
%we show the whole process to 
%build a thread-local layer interface
%that tackles 
%multiple challenges stated in Sec.~\ref{subsec:fulleasm}.
%However, introducing this interface does not mean that all about building thread-local layers and 
%linking multiple thread-local layers are straightforward. 
%When looking at the refinement theorems in previous sections,
%some are purely logical and only depend on machine model levels, 
%but two of them, Theorem~\ref{theorem:easm_refine_lasm} and Theorem~\ref{theorem:hasm-refines_tasm} 
%are relying on the abstract relation between two layers. 
%To prove them, we have to introduce the instance of $\mathrm{PH}$ which satisfies both 
%$\absrel(\simrel(st_{\EAsmM{}}, st_{\AsmLM}), \mathrm{PH}, \CSched)$ and 
%$\absrelt(\simrel(st_{\AsmHM}, st_{\TAsmM{}}), \TSched, \mathrm{PH})$.
%This instantiation also includes how we define concrete implementations of
%abstract definitions that we have introduced in our multiple machine models. 
%In this sense, we introduce a concrete layer $\TLink$, an instance of $\mathrm{PH}$
%to give the evidence for the abstract definition in those two refinement theorems.
%
%Instantiating $\TLink$ contains multiple challenges, too.
%We first need to divide $adt$ in $\AsmLM$ $\AsmHM$  into two separate data types, $\dshare$ and $\dproc$, and
%define specifications  $(\spec^{_{def}}_{_{id}})$  for all primitives (except $\yield$ and $\sleep$) 
%and memory access semantics based on the  
%newly defined data types. 
%Obviously, some data structures, such as a memory page permission table or an IPC (inter process communication) channel, 
%cannot be trivially divided into into multiple thread-wise data structures.
%In this sense, dividing the whole data structure of concurrent system requires a deep knowledge about how the system works,
%and requires an amount of effort. 
%
%In addition, proving concrete implementations for all abstract definitions that we have introduced to model multiple intermediate machines
%is an another step of works in this phase. 
%For example, $\updatefun$ should have concrete definitions for the primitives that raise events
%and the behavior of the function have to be consistent with the specifications of those primitive 
%in terms of updating shared data states. 
%Also, $\initdproc$ needs to search a proper thread-create event 
%and construct a valid initial private data for each thread.
%This behavior also keeps a consistent behavior with that of thread creation in CPU-local machine in 
%$\CSched$. 
%
%When looking at the details of $\absrelt$, which relies on $\simrel(st_{\AsmHM}, st_{\TAsmM{}})$,
%most cases in the simulation relation are straightforward because 
%the relation is between two thread-local machines even though their machine models are different. 
%With the given relation, providing the evidence of $\absrelt$ consists of 
%1) all primitive specifications in $\TSched$ on $\AsmHM$ is consistent with the all primitive specifications in 
%$\TLink$ on $\TAsmM{}$, and
%2) all primitive can generate a proper event in $\TAsmM{}$. 
%
%However, $\absrel$ with $\simrel(st_{\EAsmM{}}, st_{\AsmLM})$ contains a plethora of challenges and corner cases. 
%Defining a simulation relation between the shared data in $\EAsmM{}$ with the corresponding data in $\AsmLM$ is simple. 
%On the other hand, in several cases in the private data, defining a simulation relation 
%contains a lot of sophisticated cases because here is the place that we actually link per-thread data structures as 
%a single per CPU data structures.
%For example, to divide user memory to each thread successfully, 
%exclusiveness property of our memory page allocation mechanism should be guaranteed and proved. 
%To guarantee the consistent behavior between 
% $\EAsmM{}$ and $\AsmLM$ in user context values, our simulation relation
%has to distinguish the case when the thread is not created yet and the case after it is created.
%This implies that we have to prove several additional lemmas for all primitives 
%including  disjoint property of user memories, 
%and correctness of thread-local behavior in thread creation and IPC, etc.
%With those auxiliary lemmas and simulation relation, proving the evidence of $\absrel$ consists of 
%1) all primitive specifications in $\TLink$ on $\EAsmM{}$ with all threads on CPU $c$ are consistent with  all primitive specifications in $\CSched$ on $\AsmLM$ with CPU $c$, and
%2) all events have consistent behaviors with corresponding primitive specifications in terms of shared data updating.
%
%By introducing evidences of those two abstract relations, $\absrel$ and $\absrelt$, we finally achieve an instance for a thread-local layer interface, and link multiple thread-local layers to refine it into a single CPU-local layer.
%This separation between a machine level and an actual implementation level not only makes us to enable our thread linking but also
%gives us generality and scalability 
%of our thread-linking framework.
%$\CSched$ and $\TSched$ layers contain more than $35$ primitives. 
%If we prove the refinement property for all primitives in all different machine level refinement theorems, 
%the proof size will become much bigger than now and 
%easily become unmanageable even though we use an interactive theorem prover, Coq, to prove them. 
%However, thanks to our decoupling in our modeling and proofs, we can successfully prove these all related proofs about thread linking with reasonable efforts.
%In addition to that,
%if we want to add more primitives in $\CSched$  and $\TSched$, we do not need to prove the whole refinement and linking theorems 
%that we have stated in previous sections. 
%All those theorems will remain as same, and
%the thing that we only have to change is updating $\absrel$ and $\absrelt$ instances according to the newly added data structures and primitives.
