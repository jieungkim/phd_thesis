\section{Certified Abstraction Layers}
\label{chapter:ccal:sec:cal}


Building certified software in a layered approach was already addressed in the previous work by Gu \etal~\cite{deepspec},
but the work does not address handling concurrent programs in it.
However, this approach, Certified Abstraction Layers ($\calname$), works as a basis of our concurrent layer framework.
It provides us to build and verify the (sequential) system by dividing it into modular layers, 
proving the correctness of each layer independently, and connecting the proofs of all layers in the system to show the correctness of the system's end-to-end behavior via \textit{contextual refinement} between layers. 
It only supports sequential program verification but works as a basis of our concurrent certified abstraction layers.

$\calname$ is a predicate over two layers with a context program, 
``$\ltyp{L_{\codeinmath{low}}}{R}{\codeinmath{Prog}}{L_{\codeinmath{high}}}$'', 
and a mechanized proof object (written in $\coq$) for the predicate where layer $L_{\codeinmath{low}}$ and $L_{\codeinmath{high}}$ are state machines, \code{Prog} is a program written in C and/or Assembly, $R$ is a relation between states of two layers.
Informally, the predicate implies that 
a layer $L_{\codeinmath{low}}$ contextually refines the higher layer $L_{\codeinmath{high}}$ with the relation $R$
 if each state transition made by $L_{\codeinmath{high}}$ based on any context program \code{Ctxt} (when \code{Prog} = \code{M} $\oplus$ \code{Ctxt}, where $\oplus$ computes the union of implementation modules and contexts) corresponds to (with the relation $R$)  a sequence of 
 state transitions by $L_{\codeinmath{low}}$ which has the context \code{M} and  \code{Ctxt}.
 Formally, it is defined as a forward simulation~\cite{Lynch95,leroy09,Milner71,Park81} with the (simulation) relation $R$
 and  $\ltyp{L_{\codeinmath{low}}}{R}{\codeinmath{M} \oplus \codeinmath{Ctxt}}{L_{\codeinmath{high}}}'$ is stated as
$$\forall\ \codeinmath{Ctxt},\ \sem{L_{\codeinmath{low}}}{\codeinmath{M}_{\codeinmath{high}} \oplus \codeinmath{Ctxt}} \refines_{R} \sem{L_{\codeinmath{high}}}{\codeinmath{Ctxt}},$$
where $\refines_{R}$ is a refinement relation with $R$, and $\sem{L}{\cdot}$ denotes a  behavior of the layer machine based on $L$.


Contextual refinement, the underlying technique of $\calname$, is powerful since layers can be verified only once individually, and those layers can be linked together.
 When the stack is extended with a new verified layer on top, 
 the inter-layer contextual refinement proofs can be reused with an updated context to include the new layer continuously. 
For instance, if we add a new layer $L_{\codeinmath{top}}$ on top of verified layers $L_{\codeinmath{mid}}$ and $L_{\codeinmath{btm}}$, 
we need one new proof that shows $L_{\codeinmath{mid}}$ contextually refines $L_{\codeinmath{top}}$, but we can reuse the proof for $L_{\codeinmath{btm}} \refines_{R} L_{\codeinmath{mid}}$ without requiring any modification to the proof thanks to the characteristic of the contextual refinement. After the proof of $L_{\codeinmath{mid}} \refines{cr} L_{\codeinmath{top}}$, we are automatically guaranteed that $L_{\codeinmath{btm}}$ contextually refines all the way up to $L_{\codeinmath{top}}$ as follows:
$$
\forall\ \codeinmath{Ctxt},\ \sem{L_{\codeinmath{btm}}}{\codeinmath{M}_{\codeinmath{mid}}\oplus (\codeinmath{M}_{\codeinmath{top}}\oplus \codeinmath{Ctxt})} \refines_{R}  \sem{L_{\codeinmath{mid}}}{\codeinmath{M}_{\codeinmath{top}} \oplus \codeinmath{Ctxt}} \refines_{R'} \sem{L_{\codeinmath{top}}}{\codeinmath{Ctxt}}. 
$$ 
where $R$ is the relation between states of $ L_{\codeinmath{btm}}$ and $L_{\codeinmath{mid}}$ and $R'$ is the relation between states of 
 $ L_{\codeinmath{mid}}$ and $L_{\codeinmath{top}}$.


Each layer in $\calname$ is internally composed of the C implementation, specifications, and proofs.
To develop a layer $L_k$, 
the developer writes 
1) source code written in C and/or Assembly; 
2) high-level and  low-level specifications written in $\coq$, which specify how the code changes abstract state and memory, respectively; 
3) the auto-generated AST ($\clight$) of C source code using the tool in $\compcert$; 
and writes three proofs: 
1) $p_k$, a proof that the generated code refines the low-level specification; 
2) $r_k$, a proof that the low-level specification refines the high-level specification; and 
3) $R_{k-1,k}$, a proof using $p_k$ and $r_k$ to verify that $L_{k-1}$ contextually refines $L_{k}$. 
The proofs $p_k$ and $r_k$ guarantee that the C code (\ie , its verified $\coq$ representation) is correct as defined by the specifications.
 With the contextual refinement proof $R_{k-1, k}$, we are assured that the C code in $L_k$ never uses the code in $L_{k-1}$ in an undefined way; 
 calls to C functions in $L_{k-1}$ always return defined results to $L_k$; and variables 
 used and allocated in each layer have their memory locations and are safely accessed.
 This process will remain as same after we extend $\calname$ to support concurrency.
