\section{Certified Abstraction Layers}
\label{chapter:ccal:sec:cal}

Certified Abstraction Layers ($\calname$)~\cite{deepspec} provides us to build and verify the system by dividing it into modular layers, 
proving the correctness of each layer independently, and connecting the proofs of all layers in the system to show the correctness of the system's end-to-end behavior via \textit{contextual refinement} between layers. 
It only supports sequential program verification but works as a basis of our concurrent certified abstraction layers.

$\calname$ is a predicate over two layers with a context program, 
``$\ltyp{L_{\codeinmath{low}}}{R}{\codeinmath{Prog}}{L_{\codeinmath{high}}}$'', 
and a mechanized proof object (written in $\coq$) for the predicate where layer $L_{\codeinmath{low}}$ and $L_{\codeinmath{high}}$ are state machines, \code{Prog} is a program written in C and/or Assembly, $R$ is a relation between states of two layers.
Informally, the predicate implies that 
a layer $L_{\codeinmath{low}}$ contextually refines the higher layer $L_{\codeinmath{high}}$ with the relation $R$
 if each state transition made by $L_{\codeinmath{high}}$ based on any context program \code{Ctxt} (when \code{Prog} = \code{M} $\oplus$ \code{Ctxt}, where $\oplus$ computes the union of implementation modules and contexts) corresponds to (with the relation $R$)  a sequence of 
 state transitions by $L_{\codeinmath{low}}$ which has the context \code{M} and  \code{Ctxt}.
 Formally, it is defined as a forward simulation~\cite{Lynch95,leroy09,Milner71,Park81} with the (simulation) relation $R$
 and  $\ltyp{L_{\codeinmath{low}}}{R}{\codeinmath{M} \oplus \codeinmath{Ctxt}}{L_{\codeinmath{high}}}'$ is stated as
$$\forall\ \codeinmath{Ctxt},\ \sem{L_{\codeinmath{low}}}{\codeinmath{M}_{\codeinmath{high}} \oplus \codeinmath{Ctxt}} \refines_{R} \sem{L_{\codeinmath{high}}}{\codeinmath{Ctxt}},$$
where $\refines_{R}$ is the refinement relation with $R$, and $\sem{L}{\cdot}$ implies  a  behavior of the layer machine based on $L$.


Contextual refinement, the critical technique of CAL, is powerful since layers can be verified only once individually, and those layers can be linked together.
 When the stack is extended with a new verified layer on top, 
 the inter-layer contextual refinement proofs can be reused with an updated context to include the new layer continuously. 
For instance, if we add a new layer $L_{\codeinmath{top}}$ on top of verified layers $L_{\codeinmath{mid}}$ and $L_{\codeinmath{btm}}$, 
we need one new proof that shows $L_{\codeinmath{mid}}$ contextually refines $L_{\codeinmath{top}}$, but we can reuse the proof for $L_{\codeinmath{btm}} \refines_{R} L_{\codeinmath{mid}}$ without requiring any modification to the proof thanks to the characteristic of the contextual refinement. After the proof of $L_{\codeinmath{mid}} \refines{cr} L_{\codeinmath{top}}$, we are automatically guaranteed that $L_{\codeinmath{btm}}$ contextually refines all the way up to $L_{\codeinmath{top}}$ as follows:
$$
\forall\ \codeinmath{Ctxt},\ \sem{L_{\codeinmath{btm}}}{\codeinmath{M}_{\codeinmath{mid}}\oplus (\codeinmath{M}_{\codeinmath{top}}\oplus \codeinmath{Ctxt})} \refines_{R}  \sem{L_{\codeinmath{mid}}}{\codeinmath{M}_{\codeinmath{top}} \oplus \codeinmath{Ctxt}} \refines_{R'} \sem{L_{\codeinmath{top}}}{\codeinmath{Ctxt}}. 
$$ 
where $R$ is the relation between states of $ L_{\codeinmath{btm}}$ and $L_{\codeinmath{mid}}$ and $R'$ is the relation between states of 
 $ L_{\codeinmath{mid}}$ and $L_{\codeinmath{top}}$.


Each layer in $\calname$ is internally composed of the C implementation, specifications, and proofs.
To develop a layer $L_k$, 
the developer writes 
1) source code written in C and/or Assembly; 
2) high-level and  low-level specifications written in $\coq$, which specify how the code changes abstract state and memory, respectively; 
3) the auto-generated AST ($\clight$) of C source code using the tool in $\compcert$; 
and writes three proofs: 
1) $p_k$, a proof that the generated code refines the low-level specification; 
2) $r_k$, a proof that the low-level specification refines the high-level specification; and 
3) $R_{k-1,k}$, a proof using $p_k$ and $r_k$ to verify that $L_{k-1}$ contextually refines $L_{k}$. 
The proofs $p_k$ and $r_k$ guarantee that the C code (\ie , its verified $\coq$ representation) is correct as defined by the specifications.
 With the contextual refinement proof $R_{k-1, k}$, we are assured that the C code in $L_k$ never uses the code in $L_{k-1}$ in an undefined way; 
 calls to C functions in $L_{k-1}$ always return defined results to $L_k$; and variables 
 used and allocated in each layer have their memory locations and are safely accessed.
 This process will remain as same after we extend $\calname$ to support concurrency.

%
%Consequently, proving the contextual refinement relation for each pair of layers in the 
%stack guarantees the functional correctness of the entire system by connecting all the layers in the software stack:
%all layers from $L_{\codeinmath{btm}}$ to $L_{\codeinmath{top}}$ function correctly independently and together.
% With the help of the verified $\compcertx$\ compiler, the correctness of system continues to hold even after the C code is compiled into assembly. 
%To build an application on top of a verified system, we simply add layers corresponding to the application on top of $L_{\codeinmath{top}}$. The application uses $L_{\codeinmath{top}}$ as its bottom layer for verification and is oblivious to the layers underneath.
%The contextual refinement relation between $L_{\codeinmath{top}}$ and the application guarantees 
%that the application uses the underlying system (from $L_{\codeinmath{btm}}$ to $L_{\codeinmath{top}}$) correctly. 
%
%%
%%Such \textit{co-verification} of the application and the system is critical, but often overlooked and considered difficult.
%Without co-verification, the application and the system can be verified independently but still be incorrect as a whole, since the application can abuse the system interface or take actions based on wrong assumptions~\cite{shimlayer}. For example, for the same write interface, the system and the application may have different address bounds and the application can write beyond the system's address limit. Another example involves slightly different definitions for correctness conditions: a storage system may interpret durability as ``flushing to local disk'', while the application may expect durability from the storage system to mean ``stored on a backup machine''; both can be verified correct, yet the combination will be incorrect. Such mismatches can neutralize the verification effort. Contextual refinement not only guarantees that the application uses the system interface correctly but also guarantees that the application's assumptions about the interface are valid. 
