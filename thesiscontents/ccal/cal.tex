\section{Certified Abstraction Layers}
\label{chapter:ccal:sec:cal}

Certified Abstraction Layers (CAL)~\cite{deepspec} is a framework to build and verify sequential programs in a layered approach. 
It provides us to build and verify the system by dividing it into modular layers, proving the correctness of each layer independently, 
and proving the end-to-end behavior of the system via \textit{contextual refinement} between layers.
It also works as a basis of our concurrent certified abstraction layers.

In CAL, each layer $L$ is a state machine which has its corresponding implementation $M$ and an execution environment context $Ctxt$. 
The context $Ctxt$ is a program that can run on the state machine. 
Informally, a layer $L_{low}$ contextually refines the higher layer $L_{high}$ if each state transition made by $L_{high}$ based on any context $Ctxt$ corresponds to a sequence of state transitions by $L_{low}$ which has the context $Ctxt$ and $L_{high}$'s implementation $M_{high}$. We can formally represent contextual refinement $L_{low} \sqsubseteq_{cr} L_{high}$ as verifying the following: 
$$\forall Ctxt, L_{low} (M_{high} \oplus Ctxt) \sqsubseteq L_{high} (Ctxt),$$
where $\sqsubseteq$ is the refinement relation and $\oplus$ computes the union of implementation modules and contexts.

Contextual refinement is powerful since layers can be verified only once independently; and layers can be linked by verifying that each layer contextually refines the layer above it for an arbitrary context.
 When the stack is extended with a new verified layer on top, the inter-layer contextual refinement proofs can be reused with an updated context to include the new layer. For example, if we add a new layer $L_{top}$ on top of verified layers $L_{mid}$ and $L_{btm}$, we need one new proof that shows $L_{mid}$ contextually refines $L_{top}$, but we can reuse the proof for $L_{btm} \sqsubseteq_{cr} L_{mid}$ without requiring any modification to the proof because the proof holds ``for all" context $t$. After the proof of $L_{mid} \sqsubseteq_{cr} L_{top}$, we are automatically guaranteed that $L_{btm}$ contextually refines all the way up to $L_{top}$ as follows:
$$
\forall Ctxt, M_{btm} (i_{mid}\oplus (M_{top} \oplus Ctxt)) \sqsubseteq L_{mid} (M_{top} \oplus Ctxt) \sqsubseteq L_{top} (Ctxt). 
$$

Internally, each layer is composed of the C implementation, specifications, and proofs.
To develop a layer $L_k$, the developer writes source code in C; the high-level and the low-level specifications in Coq, which specify how the code changes abstract state and memory, respectively; auto-generates the Coq representation of C source code using CompCertX~\cite{deepspec}; and writes three proofs: 1) $p_k$, a proof that the generated code refines the low-level specification; 2) $r_k$, a proof that the low-level specification refines the high-level specification; and 3) $R_{k-1,k}$, a proof using $p_k$ and $r_k$ to verify that $L_{k-1}$ contextually refines $L_{k}$. The proofs $p_k$ and $r_k$ guarantee that the C code (i.e., its verified Coq representation) is correct as defined by the specifications. With the contextual refinement proof $R_{k-1, k}$, we are assured that the C code in $L_k$ never uses the code in $L_{k-1}$ in an undefined way; calls to C functions in $L_{k-1}$ always return defined results to $L_k$; and variables used and allocated in each layer have their own memory locations and are safely accessed.


Consequently, proving the contextual refinement relation for each pair of layers in the stack guarantees the functional correctness of the entire system: all layers from $L_{btm}$ to $L_{top}$ function correctly independently and together. With the help of the verified CompCertX compiler, the correctness of system continues to hold even after the C code is compiled into assembly. 
To build an application on top of a verified system, we simply add layers corresponding to the application on top of $L_{top}$. The application uses $L_{top}$ as its bottom layer for verification and is oblivious to the layers underneath. The contextual refinement relation between $L_{top}$ and the application guarantees that the application uses the underlying system (from $L_{btm}$ to $L_{top}$) correctly. 


Such \textit{co-verification} of the application and the system is critical, but often overlooked and considered difficult.
Without co-verification, the application and the system can be verified independently but still be incorrect as a whole, since the application can abuse the system interface or take actions based on wrong assumptions~\cite{shimlayer}. For example, for the same write interface, the system and the application may have different address bounds and the application can write beyond the system's address limit. Another example involves slightly different definitions for correctness conditions: a storage system may interpret durability as ``flushing to local disk'', while the application may expect durability from the storage system to mean ``stored on a backup machine''; both can be verified correct, yet the combination will be incorrect. Such mismatches can neutralize the verification effort. Contextual refinement not only guarantees that the application uses the system interface correctly but also guarantees that the application's assumptions about the interface are valid. 
