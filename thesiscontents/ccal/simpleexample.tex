\section{Fun-Lift and Log-Lift}
\label{chapter:ccal:sec:example}

This section revisits the example in Section~\ref{chapter:ccal:sec:ccal-overview} to show two common patterns 
when building layers using the CCAL toolkit, Fun-Lift and Log-Lift. 
We assume that all layers are built upon the bottom layer of the CPU-local layer interface
$\PLayer{\PBoot}{c}{\oracle}$.

\begin{figure}[t]
\lstinputlisting [language = C, multicols=2] {source_code/ccal/ticket_lock.c}
\caption{Pseudocode of ticket lock using $\push/\pull$.}
\label{fig:exp:real_ticket_lock}
\end{figure}




A spinlock enforces mutual exclusion by restricting CPU access to
a memory location $b$. Therefore, lock operations can be viewed
as ``safe'' versions of $\cpush/\cpull$ primitives.
For example, when the lock acquire  for $b$ succeeds,
the corresponding shared memory is guaranteed
to be ``free'', meaning that it is safe to 
pull the contents to the local copy at this point (line 4 in Fig.~\ref{fig:exp:real_ticket_lock}).
Therefore, as can be seen in Fig.~\ref{fig:exp:real_ticket_lock},
the $\acq/\rel$ functions invoke the $\push/\pull$ primitives.

To map the previous ticket lock example with $\cpush$ and $\cpull$ primitives in the layer $\PBoot[c]$, 
the ticket lock implementation in Figure~\ref{fig:chapter:ccal:sec:ccal-overview:ticket_lock_example} need to be slightly changed, and
Figure~\ref{fig:exp:real_ticket_lock} shows the ticket lock implementation with proper $\cpush$ and $\cpull$ primitive calls in it.
Note that query points are denoted as ``$\intp$'' in pseudocode.

\para{Bottom Interface $\PBoot[c]$.}
We begin with the CPU-local interface $\PBoot[c]$ extended with shared primitives
$\codeinmath{FAI\_t}$, $\codeinmath{get\_n}$, and $\codeinmath{inc\_n}$.
These primitives directly manipulate the lock state $\codeinmath{t}$
(next ticket) and $\codeinmath{n}$ (now serving ticket)
via x86 atomic instructions. 

\begin{figure}[t]
\lstinputlisting [language = Caml] {source_code/ccal/lock.v}
\caption{Pseudocode of ticekt lock specifications in Coq.}
\label{fig:exp:tlock}
%\end{wrapfigure}%
\end{figure}
Each of them generates a corresponding event in the 
log. As an example, the specification of $\codeinmath{FAI\_t}$ is shown in Fig.~\ref{fig:exp:tlock},
where the replay function $\replay_{\codeinmath{ticket}}$ calculates  the lock state.
 
\para{Fun-Lift to $L_\codeinmath{lock\_low}[c]$.}
We have shown how to establish the strategy simulation
for this low-level interface $L_\codeinmath{lock\_low}[c]$ (i.e.\, $L_1'[c]$, see Sec.~\ref{sec:informal}).
Note that $\ssem{\codeinmath{acq}}{L_\codeinmath{lock\_low}[c]}$ contains extra silent moves (e.g.\, assigning $\codeinmath{myt}$, line 2 in Fig.~\ref{fig:exp:real_ticket_lock}) compared with $\strat{\codeinmath{acq}}'[c]$.
The simulation relation 
$R_\codeinmath{lock}$ not only states the equality between logs but also maps the lock
state in the memory to the ones calculated by $\replay_{\codeinmath{ticket}}$.
Here we must also handle potential \emph{integer overflows} for $\codeinmath{t}$ and $\codeinmath{n}$.
We can prove that, as long as the total number of CPUs (i.e.\, $\#CPU$) in the machine is less than $2^{32}$ (determined by $\codeinmath{uint}$), the mutual exclusion property will not be violated  even with overflows. 
Based on the CPU-local layer, we first verify that the C implementations of 
the ticket lock satisfy the $\acq$ and $\rel$ specifications,
which are defined in terms of logs with low-level events
related to $\codeinmath{t}$ and $\codeinmath{n}$.
Thus, we can build $\ltyp{\PLayer{\PBoot}{c}{}}{R_\codeinmath{lock}}{(\modulef{\acq}
\oplus \modulef{\rel})}{\PLayer{L_\codeinmath{lock\_low}}{c}{}}$
using the \textsc{Fun} rule,
where the simulation relation $R_\codeinmath{lock}$ maps the lock
fields in the memory to the ones calculated by $\replay_{\codeinmath{ticket}}$.

\para{Log-Lift to $L_\codeinmath{lock}[c]$.}
We then lift the $\acq$ and $\rel$ primitives to an atomic interface, meaning that each
invocation produces exactly one event in the log (see Sec.~\ref{sec:informal}).
These atomic lock interfaces (or strategies) are similar to $\cpull/\cpush$ specifications,
except that the former ones are \emph{safe} (i.e.\, will not get stuck).
This safety property can be proved using rely conditions $L_\codeinmath{lock}[c].\Rely$ saying that,
for any CPU $c'\neq c$, its $c'.\acq$ event must be followed by a sequence of its own events (generated in the critical state)
ending with $c'.\rel$. The distance between $c'.\acq$ and $c'.\rel$ in the log is less than some number $n$.

By enforcing the fairness of the scheduler in rely conditions, saying that any CPU can be scheduled
within $m$ steps, we can show the liveness property (i.e., starvation-freedom): the while-loop in $\codeinmath{acq}$ terminates
in ``$n \times m \times \#CPU$'' steps.
