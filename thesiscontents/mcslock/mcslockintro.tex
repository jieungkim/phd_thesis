
In this chapter, I show how we provide the toolkit to build abstraction layers for concurrent programs with fine-grained locking. 
We first describe a framework to build 
abstraction layers for sequential machines 



extend our engine to support verification of concurrent programs with fine-grained locking. As illustrated in Chapter 5, our definition of certified abstraction layers does not directly work with concurrent programs, as the contextual refinement between the specification and implementation would not hold due to the arbitrary interleaved executions with other devices/CPUs. This is because the way we specify the function does not take into account the potential change to the (shared) abstract states and memory due to the interleavings. On the other hand, it is definitely not practical to encode all possible ways of the state changes from interleaved executions in the specifications themselves.
Thus, we need a way to effectively represent the shared states among programs on different CPUs, and the non-deterministic accesses to these shared states. We would also want to reuse all the techniques that we have built for verification of sequential programs. Recall that we have successfully handled some limited form of concurrency between the devices and a sequential program in Chapter 5. There, we have developed a new machine model, where the devices are treated as if they do not execute together with the CPU, and only try to replay the states of a device when we disable and enable the interrupts on that device. These two are considered as valid synchronization points because we do not access the states of the device when the interrupt of the device is enabled, and we can recompute the current states of the device solely by applying the device model to the list of external events we observe on that device.
This is clearly restricted to the limited form of concurrency in consideration, and cannot be directly applied to the reasoning of an arbitrary concurrent program. Yet, the general idea is still
155
valid, and we have indeed extended this line of the idea to a concrete framework that is suitable to reason about arbitrary concurrent programs with fine-grained locking in modular ways. By the modular reasoning of concurrent programs, we would expect to reason about each program running on a CPU or thread separately, by making valid assumptions to the rest of programs and outside world, and in the end, link these individual proofs formally to reach a final conclusion about the entire program when they run altogether concurrently. In Chapter 5, we still use the abstract states to model the shared states (the states of devices), which, at synchronization points, get computed by applying the effect of external events on the currently shared states. Naively applying this would cause the discrepancy when the current thread uses the abstract states to represent the shares states, while the rest of the world uses the events. Instead, we always use the list of events to represent the shared states among threads and processes. In this model, modifying shared states can be specified simply as appending a new corresponding event to the event list, and this list can be synchronized by appending the list of events generated by the rest of the world at every carefully chosen synchronization points. The shared states can be derived from the list of events by replaying the effects of each event in the list from an initial state. We attach such replay function for each shared state and related events.
Recall that in the sequential world, the task of layer based verification is to prove the contextual refinement between the concrete function implementation manipulating concrete in-memory data and the abstract high-level specification described in terms of the corresponding abstract states. In this case, the context would be the user program, other kernel or hypervisor functions, etc. In the concurrent world, we also have the programs running on other CPUs/threads, in parallel with the current function being verified. Thus, in this case, the task involves proving the contextual refinement between the function implementation operating on the shared memory and abstract states, and the abstract high-level atomic specification that triggers an atomic high-level event. In the next section, we present this new framework in more detail.