\section{Witness Passing}
\label{chapter:witnesspassing:sec:witness-passing}

Generic specifications provide a template for a leader-based distributed system and hide unnecessary details from users. they also provide a guideline for proving functional correctness when connecting  those specifications with
low-level implementations.
With those specifications,  we model a global state of a distributed system as a network history, which we can refer to the status of other nodes.
However, a network history generated by those generic specifications contains low-level details in it.
It includes errors in the message or discarded operations due to races between multiple proposers.
In this sense, a network history is not a concise and efficient form to represent a distributed system. 
Therefore, having a more precise, 
locally built, and globally consistent data structure to aid the safety proof of a distributed system is desired. Hence, we propose a \textit{witness}.

A witness is a logical data structure that continually grows to contain a global
history of the distributed system state changes that are meaningful to the
latest state. A witness increases by being passed between nodes through a network.
Information in a witness is never replaced or deleted, but a witness can be discarded if the corresponding operation is associated with fails.
We first formally define witnesses as they are used in the template functions
and then show how we integrate them into the specifications described in Section~\ref{chapter:witnesspassing:sec:specs-for-leader-based-system}.

%While our template functions mainly use witnesses to verify
%linearizability of state changes and the leader election by composing the 
%witnesses for commit operations and leaders, the underlying systems can
%build their own witnesses to verify system-specific properties (\eg, immutability
%of $\paxos$ in Section~\ref{chapter:witnesspassing:sec:global-local-reasoning}).


\begin{figure}
\raggedright
\noindent\fbox{basic definitions:}  \\
$$
\begin{array}{llll}
\accsset & := & \set{\nodeid} & \mbox{(All voters)}\\
\isquorums (ca: \accsset) (v: \voters) &:& \mathbb{B} & \mbox{(Quorum)} \\
\end{array}
$$
\raggedright
\noindent\fbox{witness definitions:}  \\
$$
\begin{array}{llll}
\voters & := & \set{\nodeid} & \mbox{(All supportive voters)}\\
\witness & :=  & ( \dstate, \updatefunc, \voters) & \mbox{(Witness Element)}\\
\ldrwitness &: & lst \ \witness   & \mbox{(Uncommitted witness)}\\
\ldrwitness &: & lst \ \witness   & \mbox{(Committed witness)}\\
\witnesstree &: &  (\ldrwitness , \ldrwitness) & \mbox{(Witness)}\\
\end{array}
$$
%\textbf{Uncommitted witness}  \\
%$$
%\begin{array}{llll}
%\ldrwitness &:=&  \set{\termnum \mapsto list\ (\dstate, \voters, \accsset)} & \\
%\end{array}
%$$
%\textbf{Committed witness}  \\
%$$
%\begin{array}{llll}
%\opwitness &:=& \set{\termnum \mapsto list\ (\dstate, \updatefunc, \voters, \accsset)}& 
%\end{array}
%$$
\caption{Witness Definition for Distributed Systems.}
\label{fig:chapter:witnesspassing:witness-definition}
\end{figure}

\subsection{Witness Definitions} 
\label{chapte:witnesspassing:subsec:witness-definition}

A witness ($\witnesstree$) contains all logical information that is sufficient for us to deduce the current status and the history of the associated distributed object. 
While all nodes in a system create information added to a witness, a witness construction only
happens at requester sides. Witness-related definitions are outlined in
Figure~\ref{fig:chapter:witnesspassing:witness-definition}.
Reconfiguration of a set of nodes in a system is currently out of scope, so we assume that information for all voters ($\accsset$) and a quorum definition ($\isquorums$) is fixed.

Each element in a witness contains three parts, a local node state ($\dstate$), an update function associated with the update ($\updatefunc$), and a piece of evidence that a proposer collects to build the element. 
The top-level definition of our witness is a pair that consists of two witness lists--one is for committed operations and the other is for uncommitted operations.
The process of building a witness is modular and simple. A requester sends
requests and approvers send back acknowledgments with existing witnesses that
show how they reached their latest state.
The requester can construct a new witness and concatenate it with the
received witness without having to inspect it.
The new composite witness is then sent back to the approvers at the point where
 the approvers' states are updated.


%
%Each element in the witness election function ($\ldrwitness$) contains a
%
%
%
% ($\termnum$) to a set of witness elements.
%Each element contains a list of local node state ($\dstate$), node ids
%of all of the voters in the leader election ($\accsset$), node ids of the voters who voted
%for the requester ($\voters$), and a function to determine the success of the
%election ($\isquorums_{ldr}$), which makes a decision by checking for the existence of a
%quorum. The necessary quorum size for a successful election varies
%by protocol; e.g., Raft requires $F + 1$ votes out of $2F + 1$
%nodes while the Lamport lock needs $N$ votes out of $N$ nodes.
%
%The witness for the commit function ($\opwitness$) describes how the distributed
%object has evolved from the initial to the latest state by keeping a
%history of all intermediate values of $\sigma$ and the update function
%$\updatefunc$ that is applied for each update. $\opwitness$ also contains
%the other fields in $\ldrwitness$; however, the necessary quorum size for $\isquorums_{op}$
%can be different than that for $\isquorums_{ldr}$. For example,
%two-phase commit as described in Figure~\ref{fig:chapter:witnesspassing:process-flow} uses
%a membership service for leader election, but relies on resource managers to
%commit data.
%
%Two quorum functions ($\isquorums_{ldr}$ and $\isquorums_{op}$), which determine whether the leader 
%election and operation are successful, generalize how leader-based distributed 
%systems make atomic state transitions. We make the assumption that the underlying
%protocol allows only one quorum that allows the state change for an operation 
%that multiple nodes may try to execute concurrently. This is one of the key
%requirements that a system must meet to use our proof template.
%
%The process of building a witness is modular and simple. A requester sends
%requests and approvers send back acknowledgements with existing witnesses that
%show how they reached their latest state.
%The requester can simply construct a new witness and concatenate it with the
%received witness without having to inspect it.
%The new composite witness is then sent back to the approvers at the point where
%the approvers' state is updated.

\subsection{Specifications with Witness} 
\label{chapter:witnesspassing:subsec:specifications-with-witness}

\begin{figure}
\raggedright
\noindent\fbox{state definition with witness:}\\
$$
\begin{array}{ll}
\dstate_\witness:= (\dstate \times \witnesstree)  & \mbox{(Local state)} \\
\gstate_\witness := \set{\nodeid \mapsto \dstate_\witness} & \mbox{(Global state)}\\
\packet_\witness:= \packet~\vert~(\packet \times  \witnesstree) & \mbox{(Network event)}\\
{\networklog}_{\witness}:= \mbox{list}\ \packet_\witness & \mbox{(Network log)}\\
\replay_\witness : {\networklog}_{\witness} \rightarrow  \gstate_\witness& \mbox{(Log replay function)}\\
\end{array}
$$

\raggedright
\noindent\fbox{auxiliary abstract definitions for witness building:} \\
$$
\begin{array}{llll}
find\_vtr_{ldr} &:& \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid} & \mbox{(Find voters for a leader election)}\\
extract\_wit_{ldr} &:& \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \witnesstree & \mbox{(Copy witness from received packets)}\\
find\_vtr_{op} &:& \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid} & \mbox{(Find voters for a commit operation)}\\
insert\_qrm_{uc} &:& \witness \networklog \rightarrow  \set{\nodeid} & \mbox{(Build quorum for uncommitted elements)}\\
f_{q} &:&  \isquorums & \mbox{(Quorum definition)}\\
\end{array}
$$
\raggedright
\noindent\fbox{auxiliary function to insert evidence into uncommitted witness elements:}\\
$$
\begin{array}{l}
insert\_qrm_{wl}\ (wl : \text{lst } \witness)\ (qrm:  \set{\nodeid}) :=\\
\ \ \ \  \text{\textbf{match }} wl \text{\textbf{ with}} \\ 
\ \ \ \  \ \ \vert \ \text{nil} \Rightarrow \text{nil} \\
\ \ \ \  \ \   \vert \ \text{hd::tl} \Rightarrow 
 \text{\textbf{ let }} tl_{q} :=  insert\_qrm_{wl} \text{\textbf{ in }} 
insert\_qrm_{uc}(hd, qrm)::tl_{q}  \\
\ \ \ \ \text{\textbf{end}} \\
\end{array}
$$
\raggedright
\noindent\fbox{witness building routine in ${\replay}_{\witness}$:}  \\
$$
\begin{array}{ll}
\ldrwcons \ (rn: \termnum) \ (l_{pre}\ l_{rcv}: \networklog) := \\
\ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}\
  \text{Some}\ (extract\_wit_{ldr} \ rn \ l_{pre} \ l_{rcv})\   \mbox{\textbf{else}} \  \text{None}.\\
\\
\opwcons\ (rn: \termnum)\ (vn :\seqnum)\ (ds : \dsvalue)\ (f: \updatefunc)\ (w :\witnesstree)\ (l_{pre}\ l_{rcv}: \networklog) := \\
 \ \ \ \ \mbox{\textbf{let}}\ (w_c, w_{uc}) := w\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{op} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}  \\
\ \ \ \ \ \  \mbox{\textbf{let}}\ w_c' := w_c \doubleplus w_{uc} \doubleplus ((rn, f\ vn \ ds), f, vtr)::\text{nil} \  \mbox{\textbf{in}} \ (w_c',  \text{nil})\\
\ \ \ \ \mbox{\textbf{else}}  \ w.\\
\end{array}
$$
%$$
%\begin{array}{ll}
%
%find\_ca_{op} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
%find\_vtr_{op} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
%find\_ca_{ldr} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
%find\_vtr_{ldr} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
%\\
%\conwcons \ (nid : \nodeid)\ (rn: \termnum)\  (w_l :\witness_{ldr})\ (w_o : \witness_{op})\ (l_{pre}\ l_{rcv}: \networklog)\\ (f_{q} :  \isquorums_{op}) := \\
%\ \ \ \ \mbox{\textbf{let}}\ ca := (find\_ca_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
%\ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
%\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}  \\
%\ \ \ \ \ \ \mbox{\textbf{match}} \ w_l[rn] \ \mbox{\textbf{with}} \\
%\ \ \ \ \ \ \ \ \vert~nil \Rightarrow w_o \\
%\ \ \ \ \ \ \ \  \vert~((rn', \_, \_), \_, \_, \_ )::\_  \Rightarrow w_o / \langle w_o[rn] := w_o[rn'] \rangle \\
%\ \ \ \ \ \ \mbox{\textbf{end}}\\
%\ \ \ \ \  \mbox{\textbf{else}} \ w_o.
%\\
%\ldrwcons \ (nid : \nodeid)\ (rn: \termnum)\ (w_l :\witness_{ldr})\ (w_o : \witness_{op})
%(l_{pre}\ l_{rcv}: \networklog)\\  (f_{q} :  \isquorums_{ldr})\ (f_{o} :  \isquorums_{op}) := \\
% \ \ \ \ \mbox{\textbf{let}}\ ca := (find\_ca_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
% \ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
%\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}  \\
%\ \ \ \ \ \ \mbox{\textbf{let}}\ l := l_{rcv}~\doubleplus~l_{pre} \ \mbox{\textbf{in}} \\
%\ \ \ \ \ \ \mbox{\textbf{let}}\ w_l' := w_l/\langle w_l[rn]  := ((\replay(l)[nid]),f, vtr, ca, f_{q}) ::w_l[rn])  \rangle \ \mbox{\textbf{in}}\\
%\ \ \ \ \ \  \mbox{\textbf{let}}\ w_o' := \conwcons\  nid\ rn\ w_l\ w_o \ l_{pre} \ l_{rcv} \ f_o \ \mbox{\textbf{in}}\  (w_l', w_o')\\
%%\ \ \ \ \ \ \ \ \ \ \mbox{\textbf{match}} \ w_l[rn] \ \mbox{\textbf{with}} \\
%%\ \ \ \ \ \ \ \ \ \ \vert~nil \Rightarrow  (w_l', w_o)\\
%%\ \ \ \ \ \ \ \ \ \ \vert~((rn', \_, \_), \_, \_, \_ )::\_  \Rightarrow (w_l', w_o / \langle w_o[rn] := w[rn'] \rangle \\
%%\ \ \ \ \ \ \ \ \ \ \mbox{\textbf{end}} \\ 
%\ \ \ \ \mbox{\textbf{else}}  \ (w_l, w_o). 
%\\
%\opwcons (nid : \nodeid) \ (rn: \termnum)\ (f: \updatefunc)\ (w :\witness_{op})
% (l_{pre}\ l_{rcv}: \networklog)\\ (f_{q} :  \isquorums_{op}) := \\
%\ \ \ \ \mbox{\textbf{let}}\ ca := (find\_ca_{op} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
%\ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{op} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
%\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}  \\
%\ \ \ \ \ \  w/\langle w[rn] := ((\replay(l_{rcv}~\doubleplus~l_{pre})[nid]),f, vtr, ca, f_{q}) ::w[rn])  \rangle\\
%\ \ \ \ \mbox{\textbf{else}}  \ w. \\
%\end{array}
%$$
\caption{Witness Construction Functions.}
\label{fig:chapter:witnesspassing:witness-construction}
\end{figure}



Based on the witness definition, we extend our state definitions of
leader-based systems to utilize witnesses and discuss routines to construct
witnesses (Figure~\ref{fig:chapter:witnesspassing:witness-construction}).

Each node's local state is extended to store its own witness ($\dstate_\witness)$.
A global state definition with witnesses is also updated accordingly.
To pass witnesses from one node to another,
network events must also contain the associated witness in addition to usual events.
When a leader election function or a commit operation function successfully updates a local state of a distributed node, the associated witness should be
attached to the new state. To do so, a log replay function should internally call a witness building routine ($\ldrwcons$ or $\opwcons$) at the end of two generic functions.

Figure~\ref{fig:chapter:witnesspassing:witness-construction} shows methods for constructing witnesses.
At the end of $\ldrfunction$, $\ldrwcons$ first constructs information about voters ($vtr:\voters$) and, if the requester succeeds in becoming a leader,
it chooses the witness from the received network event. 
Witness building in a leader election does not need to know 
all details about distributed object manipulations.
It only needs to copy one witness from voters of the election.
However, the mutual exclusiveness of the leader election guarantees the consistency of distributed object manipulations via a leader election when generic functions guarantee a 
 certain property described in the Section~\ref{chapter:witnesspassing:sec:prove-safety-with-witness}. 
 
A witness update function, $\opwcons$, is a analogous function for $\opfunction$.
A leader starts from a witness with the complete history.
Upon a successful call to $\opfunction$, the leader creates a new witness by flushing the uncommitted witness and 
adding a witness entry, which also contains an update function $f$ that is to be used
to update the existing state.

%Then $\conwcons$ is called against
%the nodes that process the commit operation to gather the witness for
%$\witnesstree$.
%$\conwcons$ copies the witnesses from the previous term into the current one and flush uncommitted witnesses because the proposer collects collect sufficient evidence that those uncommitted witnesses are written in the quorum.  



Witnesses are stored in each local state and are communicated over the network.
This means failed communications can
cause specific nodes to fall behind with updating their witnesses.
However, as long as the system operates without violating the failure 
assumptions, the system state eventually becomes consistent and reasoning 
about the protocol is not affected by outdated nodes.

Witnesses also impose multiple invariants in them.
For example, all elements inside witnesses 
always contain valid voters and candidates that satisfy a quorum as follows:


\begin{theorem}[Witness Invariant]\label{thm:witness-invariant}
Assume that for a network log $l$, the resulting state of replaying the log $l$ 
	is $gst$, which can be represented as $\replay_\witness(l) = gst$
For all $nid$, if $gst[nid] = (\_, \_, \_, w)$ and $w = (w_c, \_)$, then $w_c$ satisfies the following properties with the quorum definition, ($f_q : \isquorums$):
$$\forall\ vtr\ , \ ( \_, \_, vtr) \in w_c \rightarrow f_q(ca, vtr) = true$$
\end{theorem}

\begin{proof}
The proof is straightforward with the witness construction definition.
\end{proof}

\begin{theorem}[Specification Refinement]\label{theorem:chapter:witnesspassing:spec-refine}
With the refinement relation $R$ between $\dstate$ and $\dstate_\witness$, 
the template functions satisfy the following properties:
1) $\ldrfunction  \sqsubseteq_{R} {\ldrfunction}_{\witness} $; 
2) $\ldrhfunction  \sqsubseteq_{R} {\ldrhfunction}_{\witness} $; 
3) $\opfunction  \sqsubseteq_{R} {\opfunction}_{\witness} $; and
4) $\ophfunction  \sqsubseteq_{R} {\ophfunction}_{\witness}$.
\end{theorem}

\begin{proof}
The proof is straightforward. 
Since both $\dstate$ and $\dstate_\witness$ contain the same fields aside from
the witnesses, the refinement relation $R$ for each field will be an identity relation.
Thus, the simulation proof for these fields is straightforward. 
The witness can be easily constructed from the witness construction functions
in Figure~\ref{fig:chapter:witnesspassing:witness-construction}, which do not touch fields other
than the witness. 
Hence, proving the refinement relation between the two specifications is
straightforward.
\end{proof}

Similarly, proving that providing generic specifications for distributed
systems imply providing generic specifications with witnesses for a distributed system is also straightforward.


