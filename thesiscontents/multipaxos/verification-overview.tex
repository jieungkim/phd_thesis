\section{WormSpace Verification}
\label{sec:formal_verification}

\lstdefinelanguage{mycoq}
{morekeywords={let, in, Function, replay_log, WOR_write, if, then, else},
sensitive=false,
morecomment=[s]{(*}{*)},
morestring=[b]",
}

$\wormspace$ acts as a foundation for verifying distributed systems. 
We verify $\wormspace$ once and reuse its proof for verifying three applications (\ie, WormPaxos, WormLog, and WormTX)
built on top while  hiding the complexity of distributed protocol verification. 	
To do so, we extend the Certified Concurrent Abstraction Layer ($\ccalname$)  in Chapter~\ref{chapter:ccal}, 
modeling an asynchronous network of distributed nodes in order to verify $\wormspace$. 
We apply $\ccalname$ beyond a single system verification for the first time and link the proof of $\wormspace$, 
$\wormspace$ applications and a verified OS. 

\subsection{Layer Structure for Verification}

$\wormspace$ consists of two separate stacks of verification layers, the client library (17 layers) and the wormserver (2 layers), over a common set of base functionalities (5 layers). While the number of layers may seem excessive, it matches a conventional software stack designed for modularity: each layer is a C component implementing some interface. A simplified layer diagram is shown in Figure~\ref{fig:layerdiagram}.

\begin{figure}
\centering
\includegraphics{figs/multipaxos/layer_diagram.pdf}
\caption{Layer Diagram: client and server stacks are combined as a distributed system in the ghost layer and the distributed nature is invisible from the $\WOR$ layer.}
%\footnote{
%A set of base layers offer common functionalities to the client library and the wormserver stacks: 
%the bottom layer provides an interface to the TCB, including network communication functions and a small number of system calls, 
%while the data layer implements various data structures over the trusted primitives.
%Above, the server stack includes layers for the $\paxos$ acceptor logic and the WormServer code. 
%The client stack includes layers for the $\paxos$ proposer logic, a wormclient layer that issues individual $\paxos$ proposals, 
%the WOR abstraction, the WOS abstraction, and the $\wormspace$ API.
%Applications such as WormPaxos and WormLog are built on top of the client library.}
\label{fig:layerdiagram}
\end{figure}


Both stacks share a common set of base layers: 
the bottom layer provides an interface to the trusted computing base (TCB), 
including network communication functions and a small number of system calls. Above this bottom layer, 
we introduce a data layer which implements various data structures over the trusted primitives. 
Above the data layer, the client and server stacks diverge. 
The server stack includes $\paxos$ acceptor layers and the wormserver code above it.
The client stack includes layers for $\paxos$ proposer logic and a wormclient layer that issues individual $\paxos$ proposals.

The ghost layer horizontally composes the two stacks and proves properties across multiple wormservers and clients.
The ghost layer includes a global state transition system that can reason all concurrent client and server interactions based on a network model. 
Safety properties of $\paxos$ are proved in this layer.
The contextual refinement proof between the ghost layer and the composition of wormserver and wormclient provides a powerful guarantee 
for  the layers built on top of the ghost layer. 
Any layer that the ghost layer contextually refines is guaranteed to be correct with respect to both client and server layers. 
It is guaranteed that any concurrent behaviors of distributed nodes using the client and server layers are correct. 
Verified distributed protocol properties hold in higher layers while complex proofs are encapsulated in the ghost layer.

Providing functional correctness for the high-level API of $\wormspace$ as well as its applications
above the ghost layer is as easy as verifying a sequential program.
For example, the top-level specification for a write in $\wormspace$ is simply translating the global address to a segment address and offset and 
passing the captureID (cid) to call the lower-level write which is already proved safe under concurrent distributed accesses:
\begin{lstlisting}
Function WormSpace_write (addr: Z) (val: Payload) (node_id: Z) (adt: EnvVars) : option (EnvVars * Z) :=
    let segment:= addr / WOS_SIZE in 
    let offset := addr mod WOS_SIZE in
    WOR_write segment offset val cid adt.
\end{lstlisting}
 We verify the $\WOR$ abstraction, the WOS abstraction, and the WormSpace API.
 The client stack can be extended to applications such as WormPaxos, WormLog, and WormTX. 
%In the rest of this section we detail our verification effort.

\subsection{Network Model}
\label{subsec:network_modeling}

It is possible that treating distributed systems as concurrent programs with one shared resource, network, which is
a logically linearized sequence of network operations (\ie, we call it the global network log);
thus we employ $/ccalname$ (in Section~\ref{chapter:ccal:subsec:concurrent-layer-with-environment})
to model a real-world network and to prove distributed properties about the system
by providing non-block network read and write primitives in our TCB. 
Among them, two basic primitives, $\codeinmath{send\_msg}$ and $\codeinmath{recv\_msg}$, 
manipulate the modeled network state. 
Using those two primitives enables each distributed node  extracts its local interaction with the network from the log, 
and then the log is used to reason about the interaction between nodes.

In our model, we depart from single-node concurrency verification by modeling the network as unreliable (but non-Byzantine). 
In our model, $\codeinmath{send\_msg}$ simply creates a $\codeinmath{send}$ event in the log, 
while $\codeinmath{recv\_msg}$ creates either $\codeinmath{timeout}$ (this models dropped packet) or $\codeinmath{recv}$ 
events in an arbitrary future location (this models packet delays) than the$\codeinmath{send}$ event in the log. 
In between a pair of $\codeinmath{send}$ and $\codeinmath{timeout/recv}$, 
any other nodes can freely record their operations (this models packet reordering). 
A \textsc{recv} after a \textsc{send} does not necessarily mean that the $\codeinmath{recv}$ event received the value sent by this $\codeinmath{send}$. 
The actual value can be a duplicate message from a previous send (this models duplicate packets).

However, network communication patterns can be complex when a client interacts with multiple wormservers in a one-to-many request pattern.
Abstraction and contextual refinement can help us manage this complexity without reducing the fidelity of verification.
Accordingly, we create a network log layer with simpler semantics, and prove that the original log refines the simplified log.
The simplified log coalesces broadcasts and receptions into singleton events and eliminates duplicates simplifying global property proofs.
\begin{figure}
\begin{center}
\includegraphics[width=0.98\textwidth]{figs/multipaxos/wormspace_network_refine}
\end{center}
\caption{Network Refinement in $\wormspace$}
\label{fig:chapter:multipaxos:network-refinement}
\end{figure}
Figure~\ref{fig:chapter:multipaxos:network-refinement} illustrates the reduction process.


$\wormspace$ code is designed to tolerate an unreliable (but non-Byzantine) network. For example, the code always receives packets in a loop to filter out duplicate packets and waits for timeout for lost packets. Such communication patterns become more complex when a client interacts with multiple wormservers in a one-to-many request pattern.

Preserving such complexity is necessary to model the real network and to verify what the C code actually does, but when it comes to proving the global property of the system, some of the details can be abstracted out.
Therefore, we apply the layered approach on the network model

is created after proving the functional correctness of the original log layer that exposes \textit{SEND/TIMEOUT/RECV} primitives.


The simplified log coalesces these primitives used for broadcast and broadcast responses into singleton send and recv events.

\begin{figure}

\begin{lstlisting}[language=C]
Function WOR_ghost_write (addr: Z) (val: Payload) (cid: Z)
 (adt: EnvVars) : option (EnvVars * Z) :=
  // get net log from Env context
  let net_l := adt.net_l
  // get current node id 
  let nid := get_node_id adt in 
  // replay the net log; get the local node state; and check if the node is in a writable status 
  if (can_write ((replay_log(net_l))[nid]) addr val cid)
  then
    // log write intent with a ghost msg to the net log 
    let net_l<@$_1$@> := (ghost_write nid addr val cid) :: net_l in
    // broadcast msgs and collect acks: 
    // reflect behaviors of other nodes to add send/recv events by this and other nodes to the net log 
    let net_l<@$_2$@> := bcast_n_recv nid addr val cid net_l<@$_1$@> adt in
    // replay the net log to compute global state; 
    // get node's local state; and check the quorum status 
    let result := is_qrm ((replay_log(net_l<@$_2$@>))[nid]) addr in
    // log the result using a ghost msg to the net log
    let net_l<@$_3$@> := (ghost_result nid result) :: net_l<@$_2$@> in
    // return the updated net log and the result 
    (adt{net_l := net_1<@$_3$@>}, result)
  else None.
\end{lstlisting}

\caption{A Simplified Log Construction Function Example: It logs local and network events of a node to the network log and calls the log replay function to check state changes.}
\label{fig:spec}
\end{figure}

\subsection{Proving Global Properties}
\label{subsec:safety_verification}

%Verifying a distributed system requires more than a functional correctness proof: a collection of individually verified nodes should be verified as a whole to prove that a global property holds. We design and verify a global state transition system and verify the global properties of $\wormspace$ based on the transition system.
	The global state transition system in the ghost layer models a distributed system with multiple concurrent $\paxos$ clients and acceptors from the viewpoint of the global network to enable the distributed protocol verification. It includes (network) log construction functions, a (network) log replay function, and a global state. The log construction function models how each client/server operation affects the network; it governs the communication pattern of each node in the network log to define the $\paxos$ protocol. The log replay function constructs the global state, which is a snapshot of the entire distributed system state or a combination of $\paxos$-related states in all nodes, by interpreting network events in the network log. Log construction and replay functions are derived from wormclient and wormserver specifications and their refinement relations for the derivation are verified. 
%The global state transition system consists of the global network log, global states, (network) log construction functions, and a (network) log replay function. The global state is a combination of $\paxos$-related states in all nodes. The log construction and the log replay functions are derived from wormclient/wormserver specifications to reason about the system from a global network's point of view. The former models how each client/server operation affects the network; it governs the communication pattern of clients and servers in the network log to define the $\paxos$ protocol. The latter, by interpreting the network log, constructs the global state. 
%The global state transition system consists of the global network log, global states, (network) log construction functions, and a (network) log replay function. The global state is a combination of $\paxos$-related states in all nodes. The log construction and the log replay functions are derived from wormclient/wormserver specifications to reason about the system from a global network's point of view. The former models how each client/server operation affects the network; it governs the communication pattern of clients and servers in the network log to define the $\paxos$ protocol. The latter, by interpreting the network log, constructs the global state. 

Log construction functions interact with the network log and the global state to introduce new network events in the network log. To record local state changes of a node which do not involve network operations, ghost messages are written to the network log. Log construction functions use the log replay function to learn and use state changes incurred by other concurrent nodes and itself (Figure~\ref{fig:spec}).


%Our global state transition system is modeled using global states, which are $\paxos$ related local states of all nodes in $\wormspace$, and state transition functions, which wormclient/wormserver functions refine. By combining the global state and the state transition function with the network model, we have a complete model of a distributed system containing multiple $\paxos$ clients and acceptors.

%Global state transition system includes a \textit{network log replay function} which governs the state transition rules. Based on the network log, the log replay function uses a state transition function that is relevant to a network event and changes affected node states in the global state. The log replay function and the global state gives enough information about the entire system to verify the properties of $\wormspace$.


The global state transition system includes a \textit{network log replay function}, which can reason about all state transitions in the distributed system. The log replay function maps a network event in the network log with the state transition function to reconstruct the global state. Figure~\ref{fig:spec} shows a simplified specification of a write function in the ghost layer that updates the global state and writes and reads the network log. Based on this global view of the system, we verify the properties of $\wormspace$.


%Based on the network log, the log replay function uses a state transition function that is relevant to a network event and changes affected node states in the global state. Based on such global behavior of the system we verify the properties of $\wormspace$.

The log replay function by itself can replay all behaviors and state changes of a distributed system step by step from the global network log. Based on this capability we prove the $\paxos$-based safety/immutability property of $\wormspace$:

\begin{theorem}
 Once a value is written to a $\WOR$, the value in the $\WOR$ never changes.
 \end{theorem}


\noindent To prove Theorem 1, we prove the following key lemma: 
\\
\textit{\textbf{Lemma 1.} Given a valid network log $\ell$, if there exists a $\paxos$ round $n$ where a value $v$ is successfully written to a $\WOR$ $r$, any following write to $r$ in $\paxos$ rounds $n' > n$ in the log $\ell$
can only attempt to write $v' = v$.}

\noindent\\
	The valid network log is the log that preserves verified invariants such as communication patterns derived from log construction functions.
Lemma 1 is proved by induction on writes in the log using other supporting lemmas: e.g., $n'$ is unique and is monotonically increasing, the $\paxos$-phase-1a/capture at round $n'$ on $r$ returns the written value $v$, etc.
Based on Theorem 1, the immutability and uniqueness of WOS allocation (including leader/sequencer election for WormPaxos/WormLog) and WOS trim are easily verified. 




\subsection{Top-Level Theorem of WormSpace}
	The top-level theorem that we prove for $\wormspace$ is, \\
%\begin{theorem}
%	$\forall t, L_{TCB} (I_{All} \oplus t) \sqsubseteq L_{WormSpace} (t)$,  
%\end{theorem}
%\begin{theorem}
%	$\forall t, L_{WormSpace} (I_{WormPaxos} \oplus t) \sqsubseteq L_{WormPaxos} (t)$, 
%\end{theorem} 
%\begin{theorem}
%	$\forall t, L_{WormSpace} (I_{WormLog} \oplus t) \sqsubseteq L_{WormLog} (t)$,
%\end{theorem}
\textit{\textbf{Theorem 2.} $\forall t, L_{TCB} (i_{AllWormSpace} \oplus t) \sqsubseteq L_{WormSpace} (t)$}, \\
%where $t$ is the context and $i_{AllWormSpace}$ is the implementation of all $\wormspace$ layers combined. The contextual refinement proof between all adjacent layers are used as lemmas. Theorem 2 guarantees the correctness of the code and verified $\paxos$ properties in the ghost layer hold in $\wormspace$. 
where $t$ is the context and $i_{AllWormSpace}$ is the implementation of all $\wormspace$ layers combined. The contextual refinement proof between all adjacent layers are used as lemmas to guarantee the correctness of the entire code. Theorem 2 also guarantees that the verified $\paxos$ properties in the ghost layer hold for the $\wormspace$ implementation.



%We proved the essential safety properties of the $\paxos$-based $\wormspace$: as long as the majority of wormservers are responsive (i.e., the failure assumption for the $\paxos$ protocol holds), a value can be written only once to a $\WOR$, the written value never changes, and a $\WOR$ is always accessible (available). Based on the $\WOR$ proof, the immutability of WOS allocation and trim are easily verified.
%As explained earlier, proved global properties are preserved in any layer above the WorHelper layer for free.
%>>>>>>> b5d710d4940308a845a5cf5251204226185451f7


\subsection{Reusability and Linking}
\label{subsec:proof_effort}

Because the ghost layer encapsulates the distributed nature of $\wormspace$, the verification of WormPaxos, WormLog, and WormTX does not have to reason about complex $\paxos$ proofs. % is as easy as proving non-distributed code.
The verification of any additional distributed protocols above $\wormspace$ reuses the same network model, but requires a new ghost layer. Protocols at different levels of the stack are independently verified within separate ghost layers; invariants of interfaces to the protocol and contextual refinement proofs guarantee non-interference among protocols. 

The top-level theorems that we prove for WormPaxos, WormLog, and WormTX are in the same format:\\
\textit{\textbf{Theorem 3.} $\forall t, L_{WormSpace} (i_{WormApp} \oplus t) \sqsubseteq L_{WormApp} (t)$},\\
where WormApp can be one of WormPaxos, WormLog, and WormTX.
%\textit{\textbf{Theorem 4.} $\forall t, L_{WormSpace} (i_{WormLog} \oplus t) \sqsubseteq L_{WormLog} (t)$}, \\
%\textit{\textbf{Theorem 5.} $\forall t, L_{WormSpace} (i_{WormTX} \oplus t) \sqsubseteq L_{WormTX} (t)$}. \\
By reusing Theorem 2 and transitively combining it with Theorems 3, applications are guaranteed to be correct with respect to all layers of $\wormspace$ and to encapsulate verified $\paxos$ properties. Similarly, Theorem 2 can be reused to verify any system in Section(background) to guarantee $\WOR$ semantics, if we use $\wormspace$ as a building block. 


To enable end-to-end verification of $\wormspace$, WormPaxos, WormLog, and WormTX, we link $\wormspace$ to $\certikos$. The linking requires contextual refinement proof between two interfacing layers.
%which requires low effort with the help of the $\ccalname$ proof templates. 
When linking independently developed and verified software pieces together, it is important to check that the specification exposed by the lower layer matches the expectations of the higher layer. Since $\wormspace$ and its applications were co-designed, such a consistency check was unnecessary, but linking $\wormspace$ to $\certikos$ required careful consistency checks. Once we link $\wormspace$ with $\certikos$ the correctness of $\wormspace$ and the applications is guaranteed from the bottom-level ($L_{x86asm}$) of the OS without any side-effects~\cite{shimlayer}; this verifies and guarantees,


%To enable end-to-end verification of $\wormspace$, WormPaxos, WormLog, and WormTX, we link $\wormspace$ to $\certikos$, and WormPaxos, WormLog, and WormTX to $\wormspace$. The linking requires contextual refinement proof between two interfacing layers which requires low effort with the help of the $\ccalname$ proof templates. When linking independently developed and verified software pieces together, it is important to check that the specification exposed by the lower layer matches the expectations of the higher layer. Since $\wormspace$ and its applications were co-designed, such a consistency check was unnecessary, but linking $\wormspace$ to $\certikos$ required extra steps to check such consistency. Once we linked $\wormspace$ with $\certikos$ the correctness of $\wormspace$ and the applications is guaranteed from the bottom level ($L_{x86asm}$) of the OS without any side-effects~\cite{shimlayer}; this verifies and guarantees,\\

\noindent\textit{\textbf{Theorem 4.} $\forall t, L_{x86asm} (i_{\certikos} \oplus i_{WormSpace} \oplus i_{WormApp} \oplus t) \\
\null$\qquad\qquad\quad\quad$ \sqsubseteq L_{WormApp} (t)$}. 
	
The extensibility of $\wormspace$ verification to applications and the OS is difficult for other verified systems~\cite{ironfleet, hyperkernel} to achieve. Especially, it is unnatural and difficult to support contextual refinement, which is based on high-order logic, when the verification tool is based on a SMT solver or first-order logic (e.g., Dafny~\cite{dafny} and Z3~\cite{moura08}). 

