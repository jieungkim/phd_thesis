
\section{Certified Abstraction Layers}

Our CCAL toolkit follows the layer-based compositional proof approach proposed by Gu \etal~\cite{deepspec}.
They proposed certified abstraction layers (CAL) for sequential programs and 
verified certified system software to show the applicability of the approach.
CAL has many different aspects with
 hoare-style program verification~\cite{hoare69,reynolds02,boogie05,nanevski06}.

First, CAL proves a contextual correctness property by using the termination-sensitive forward simulation 
techniques~\cite{Lynch95,compcert}, 
which is stronger than simple partial or total correctness properties guaranteed by Hoare logic style verification.
Besides, Its overlay interface of a certified object thoroughly disables 
the concrete memory block (of the object)  for the future usage 
and replaces the memory with an abstract state;
this abstract state is suitable for high-level reasoning such as proving security properties and progress properties (when it is extended to support
concurrency as CCAL does). 
It also differs from ghost or auxiliary states in hoare-style program verification in terms of 
its usage.
The abstract state is a part of an entire state of the transition machine; 
thus it can be used to define the semantics of the overlay abstract machine
as well as the corresponding contextual refinement property.
Lastly,  building layers enable us to provide a new state transition machine and a new programming language that gets close to the specification language. 
Higher layers replace more low-level memory blocks and function implementations with 
the corresponding abstract states and primitives,
and can call primitives at higher abstraction levels while  
supporting general-purpose
programs written in C and assembly.

Those differences are also the same in the comparison between CCAL in Chapter~\ref{chapter:ccal} and 
hoare-sytle program verification. 
When introducing a new concrete concurrent object implementation in our layers, 
we always replace a set of events generated by the object with an atomic event; thus we replace the implementation with an abstract atomic object in its overlay interface. 
In CCAL, 
all shared abstract states are represented as a single global log,
and atomic method calls always have to 
replay the entire global state and find the return value to refer to the current status of shared abstract states.
This global log approach treats all shared atomic objects with a single log.
Thus this  is seemingly an inefficient way of treating multiple shared atomic objects,
but great for providing compositional 
It allows us to apply game semantics ideas, therefore
is required for supporting parallel layer composition.




\section{Linearizability}
Linearizabilty~\cite{herlihy90}  is a well-known safety condition for concurrent objects 
and has been studied for decades. 
Developing concurrent software using a stack of shared atomic objects has since
become the best practice in the system
community~\cite{Herlihy08book,ospp11}. 
The original definition of linearizability instrumented programs
to record a global history of method-invocation and method-return
events. However, that's not a convenient theorem statement when
verifying client code.
In this sense,
Linearizability is considered as a quite 
difficult problem to reason about, and it is until 20 years when 
Filipovic \etal~\cite{filipovic10} showed that linearizability is actually equivalent
to a termination-insensitive version of the contextual refinement.
Followed by that work, methodologies to simplify linearizability have been
proposed mostly in a concurrent programming context~\cite{Elmas10tacas,
Liang13pldi,Gotsman12concur,Viktor10CAV}.
Among them, Gotsman \etal~\cite{Gotsman12concur} showed that the equivalence between linearizability and a termination-insensitive version of the contextual refinement property also
holds for concurrent languages with ownership transfers~\cite{ohearn:concur04}.  
Liang \etal~\cite{liang13,lili16} also showed that linearizability with various
progress properties~\cite{Herlihy08book} for concurrent objects is
equivalent to multiple termination-sensitive versions of the contextual refinement property. 
These results convinced us that 
termination-sensitive (contextual) simulation is the proper property to show
when building certified
concurrent layers as well.

Some
authors have presented mechanized verification of linearizability
(\eg~ \cite{DGLMQueue,DerrickSW11}),
They, however, are not directly on executable
code, but on abstract transition system models.
The formulation in CCAL is closer to Derrick \etal~\cite{DerrickSW11}, who prove a simulation
to a history of single atomic actions modifying abstract state.  
Some mechanized proofs in the distributed system area show 
the linearizability of Raft and
multi-Paxos~\cite{cppraft, ironfleet}.
%
% Linearizability for distributed systems - let's decide weather adding that part or not after finish chapter witnesspassing
Linearizability
and leader-soundness proofs in Chapter~\ref{chapter:witness-passing} build on top of existing work on
linearizability: the key insight for the proof is to base the reasoning on
an atomic step of each operation.  Yet, we generalize the reasoning of linearizability
to the leader-based distributed system and create a reusable proof template.
The template extracts
necessary states from the witness that is created by the lower level
specification of concrete systems
of a generic leader-based distributed system and provides a proof template based on
abstract states which are represented as the witness.
The witness encodes atomic steps backed by a quorum, which approves state
changes, and the validity of the leader who is initiating the atomic actions.
Our template guarantees the linearizability of any leader-based system that
satisfies the constraints of the witness. Using a similar witness structure, our
model automatically verifies the soundness of the leader based on
linearizability of leader election.




\section{Program Logics for Shared-Memory Concurrency}
Multiple program  logics~
\cite{cap10, ohearn:concur04,brookes:concur04,feng07:sagl,vafeiadis:marriage,LRG,verifast,gotsman13,Turon13popl,Turon13icfp,nanevski13,nanevski14,
sergey15,sergey15pldi,pinto14,iris15,civl15,pinto16,xu16}
have been proposed for 
modular verification of shared-memory concurrent programs. 
Among them, most modern separation-style concurrent logics~
\cite{cap10,Turon13popl,sergey15pldi,pinto14,iris15,pinto16} do
not prove the same strong termination-sensitive contextual simulation
properties as our work does,
while very few of them (e.g.,~\cite{pinto16})
can reason about progress properties.
On the other hand,
RGSim~\cite{RGSim} as well as our layered framework prove the same strong contextual simulation properties.

Many of these program logics~\cite{Turon13popl,iris15}, however, support 
higher-order functions 
and sophisticated non-blocking synchronization,
which our work does not address.
Both of which will be
useful for verifying specific concurrent objects within our layered
framework. 
Our use of a global log is similar to the use of compositional
subjective history traces, a history trace specifies past events, proposed by Sergey \etal~\cite{sergey15},
Our environment context, however, can talk about both past and future events rather than only past events.
Total-TaDA~\cite{pinto16} can be used to prove
the total correctness of concurrent programs but it has not been
mechanized in any proof assistant and there is no formal proof that
its notion of liveness is precisely equivalent to Helihy's notion of
linearizability and progress properties for concurrent
objects~\cite{Herlihy08book}. 
Going
beyond safety, one also wants to prove a progress property such as
wait-freedom~\cite{herlihy91:waitfree} or (in our case)
starvation-freedom~\cite{Herlihy08book}.

Two previous works, CIVL~\cite{civl15} and FCSL~\cite{sergey15pldi},
propose the way to build and prove concurrent programs in a \textit{layered} way like CCAL does. 
However, their layers differ from CCAL layers in three aspects;
1) their approaches do not support contextual refinement proofs of linearizability like Filipovic \etal~\cite{filipovic10} and Liang \etal~\cite{liang13} does;
2) they are lack of connections with any verified compilers; and
3) they do address liveness properties as we have shown in MCS lock verification.




\section{Treatment of Parallel Composition}

\para{RGSim and LiLi.}
Building contextual refinement proofs for concurrent programs and supporting parallel composition for concurrent program proofs 
are challenging.
Liang \etal~\cite{RGSim,Liang14lics,lili16, liang:2017} 
proposes several approaches from Rely-Guarantee-based Simulation (RGSim) 
that support parallel
composition and  contextual refinement of concurrent
objects.
The contextual simulation proof between two concurrent layers in CCAL 
is an instance of RGSim variance; the extended version of RGSim by adding auxiliary states including environmental contexts and shared logs. 
They are the main ingredients of our CCAL framework 
to build our new  compositional
layered model.
All existing RGSim systems are limited to reasoning
about atomic objects at one layer.
Since their client program context cannot 
be the method body of another concurrent object, 
they cannot
support the vertical layer composition what our CCAL toolkit supports.
Their recent work \etal~\cite{liang:2017} presents a way for specifying and verifying the progress of concurrent objects with partial methods, but the mechanized proof is out of their research scope. 

LiLi (Linearizability and Liveness) is a program logic based on RGSim
that can
directly prove both the linearizability and starvation freedom (or
deadlock-freedom) properties together. 
Their ``rely'' conditions are specified
over shared states only, so they cannot express temporal properties. 
To prove progress, they have to introduce a separate temporal ``rely''
condition called {\em definite actions}.  This made it difficult to
provide a standalone (total) specification for each lock acquire
method.  Indeed, all examples in their paper are code fragments that
must acquire a lock, then perform critical-section tasks, and then release the
lock. In contrast, our environmental context can specify the full
strategies (i.e., both the past and the future events) of all
environment threads and the scheduler, so we can readily impose
temporal invariants over the environment. Within each thread-modular
layer $L[t]$, we can show that each lock acquire primitive (e.g., for
ticket locks) always returns as long as its environment is cooperative
(\eg~ always releases its acquired lock), even if $t$ itself may not
be cooperative.
In other words, the termination of $t$'s lock acquire
operation does not depend on whether $t$ itself will release the lock
after first acquiring it.

Most concurrent languages use a
parallel composition command $(C_1 \| C_2)$ to create and terminate
new threads.  
Our approach is slightly different from most previous works.
We provide thread spawn and assign every new thread a unique ID $t$,
which is not reusable and must be a member of the full thread-ID domain set $D$.
As we have shown in Chapter~\ref{chapter:linking},
our parallel layer composition happens in specific layers and it is
always done over the whole program $P$ and over
all members of $D$. 
This difference allows us to reason about the current
thread's behaviors over the environment's full strategies (\ie~ both
past and future events).
Our composition treats the semantics for running $P$ over $L[t]$ is still well
defined even if a thread $t$ is never
created, because it will always query its environment context to
construct a global log.

% add View paper %

\para{Extending CompCert and Verified Compilation.} 

Stewart {\etal}~\cite{stewart15} extends the original CompCert compiler~\cite{compcert}  
to support compositional thread-safe compilation of concurrent Clight programs. 
They introduce their interaction semantics, which treats
synchronization
primitive calls as external calls.
They, however, does not support a layered ClightX language as we support in our CompCertX.  
Thus, building concurrent layers is impossible based on their work.
Kang \etal~\cite{hur16} and Ramananandro \etal~\cite{ramananandro:2015} also modified CompCert compiler to support separate compilation and composition, 
but they do not support concurrency.  
Other works on the verified compilation~\cite{Lochbihler10esop, Sevcik11popl, zhao:2013, kang:2018} does not support concurrent and/or compositionality. 


\para{Game Semantics.} 

We have used
game-semantic concepts such as strategies to describe our
compositional semantics, 
but CCAL still uses traditional small-step semantics for its concurrent machine and layer simulation, which differs from 
past works~\cite{ghica08,nishimura13,rideau11,abramsky99}  for concurrency modeling in the game semantics community.
They use games to
define the semantics of a complete language, 
and modeling higher-order sequential features as games is excellent for proving full abstraction. 
However, it is unclear how it is applied to the large-scale verification in the certified software community.


\section{OS Kernel Verification} 

A large body
of recent work including
seL4~\cite{klein2009sel4,klein14},
Verve~\cite{hawblitzel10}, Hyperkernel~\cite{hyperkernel}, and Komodo~\cite{komodo} are 
addressed OS kernel verification.
None of these works, however, do not handle the issues on concurrency with fine-grained locking.
Xu \etal~\cite{xu16} developed a new verification framework by facilitating RGSim
and Feng~\etal's program logic~\cite{feng08:aim} for reasoning
about interrupts;.
They verified many key modules (in C) 
in the $\mu$C/OS-II kernel, but they have not proved
any progress properties or proof linking properties like we do.
Other verified systems~\cite{klein2009sel4,hawblitzel10,ironclad},
are single-threaded, or use a per-core big kernel lock.


The Verisoft team used VCC~\cite{leinenbach09} to verify spinlocks in a
hypervisor by directly postulating a Hoare logic rather than building
on top of an operational semantics for C, and only proved properties
about the low-level primitives rather than the full functionality of
the hypervisor. By contrast, CertiKOS deals with the problem of
formulating a specification in a way that can be used as one layer
inside a large stack of proofs. As for CertiKOS itself, while we
discussed the ``local'' verification of a single module, other papers
explain how to relate the log and context to a more realistic
nondeterministic machine model~\cite{certikos:osdi16}, how to
``concurrently link'' the per-CPU proofs into a proof about the full
system~, and how this extends to multiple threads per
CPU~\cite{concurrency}.
CertiKOS is an end-to-end verified concurrent system showing that its
assembly code indeed ``implements'' (contextually simulates) the
high-level specification.

CertiKOS is an end-to-end verified concurrent system showing that its
assembly code indeed ``implements'' (contextually simulates) the
high-level specification.


\section{Other Work on the MCS Algorithm}





As far as we know, two other efforts apply formal verification methods
to the MCS algorithm.  Ogata and Futatsugi~\cite{ogata:mcs-lock} used the UNITY program logic to 
develop a mechanized proof for the MCS algorithm.
They work, however, is not with executable code, but with an abstract transition system. 
Their correctness proof works by refinement like we do (between a fine-grained
and a more atomic spec) but they directly prove backward
simulation.

One difference is that Ogata and Futatsugi's proof is
done using a weaker fairness assumption. They assume ``every CPU gets
scheduled infinitely often'', while we require a maximum scheduling
period ($F$ in Section~\ref{sec:liveness-atomicity}).  This is because
we write our specification of \lstinline$wait_lock$ as a Coq function
defined by recursion on a natural number, and all Coq functions must
be total. So although our ultimate theorem only states that the method
terminates ``eventually'', as an intermediate lemma we need to prove
an explicit natural number bound on when a given call to
\lstinline$wait_lock$ will finish.  We could avoid this by e.g. using
Coq's facilities to define functions by well-founded recursion, and
making the termination measure $M_i$ take ordinal instead of number
values, but in practice assuming a fixed $F$ seems like a reasonable
model of multi-core concurrency.

The other MCS Lock verification we know of is by Liang and
Feng~\cite{lili16}, who define a program logic LiLi to prove
liveness and linearizability properties and verify the MCS algorithm
as one of their examples.  The LiLi proofs are done on paper, so they
can omit many ``obvious'' steps, and they work with a simple
while-loop language instead of C. Many of the concepts in our proof
are also recognizable in theirs. The state of their concrete
  programs includes a pointer $\mathrm{\texttt{tail}}$ and nodes
  $\mathrm{\texttt{Node}}(\mathrm{\texttt{busy}}, \mathrm{\texttt{next}}, \mathrm{\texttt{ThrdID}})$.
In their invariant and precondition they use specificational variables
$\mathrm{\textit{ta}}$ and $\mathrm{\textit{tb}}$ (like \texttt{la} in
Sec.~\ref{subsec:atomicoperation}), $\mathrm{\textit{tl}}$ and $S$ (like $q$
and $s$ in Sec.~\ref{sec:representation-ghost}). Their
  ``wellformed lock'' predicate $\mathrm{\textsf{lls}}$ includes our
  tail-soundness and next-correctness properties, so in order to prove
  that the invariant is preserved they need essentially the same
  lemmas as in Section~\ref{sec:representation-ghost}. and their
termination measure $f(\mathrm{G})$ includes the length of
$\mathit{tl}$ and the size of $S$ (like $M$ in
Sec.~\ref{sec:liveness-atomicity}. On the other hand, the fairness
constant makes no appearance in $f(\mathrm{G})$, because fairness
assumptions are implicit in their inference rules.

A big difference between our work and LiLi is our emphasis on
modularity.  Between every two lines of code of a program in LiLi, you
need to prove all the different invariants, down to low-level data
representation in memory. The specification takes the form of a single
pre- and post-condition which involves concepts at many level of
abstraction. For example, unfolding the definition of the measure $f$,
we find not only $\mathit{tl}$, but also the tail-pointer $p$, and
eventually the lock-array $\mathit{ta}$. In our development, these
concerns are in different modules which can be completed by different
programmers.  Similarly, we aim to produce a stand-alone specification
of the lock operations. In the LiLi example, the program being
verified is an entire ``increment'' operation, which takes a lock,
increments a variable and releases the lock. The pre/post-conditions
of the code in the critical section includes the low-level
implementation invariants of the lock, and the fact the lock will
eventually be released is proved for the ``increment'' operation as a
whole. Our locks are specified using \emph{bound} numbers, so they can
be used by many different methods.

Apart from modularity, one can see a more philosophical difference
between our CCAL approach and program logics such as LiLi.  Liang
and Feng are constructing a program logic which is tailor-made
precisely to reason about liveness properties under fair
scheduling. To get a complete mechanized proof for a program in that
setting would require mechanizing not only the proof of the program
itself, but also the soundness proof for the logic, which is a big
undertaking. Other parts of the program will favor other kinds of
reasoning, for example many researchers have studied program logics
with inference rules for reasoning about code \emph{using} locks. One
of the achievements of the CertiKOS style of specification is its
flexibility, because the same model---a transition system with data
abstraction and a log of events---works throughout the OS kernel. When
we encountered a feature that required thinking about liveness and
fairness, we were able to do that reasoning without changing the
underlying logical framework.


\section{Distributed system verification}

Approaches to verify distributed systems have been explored actively over the
past few years. IronFleet~\cite{ironfleet} annotates functions with pre- and
post-conditions to automatically prove the correctness of the code with an SMT (satisfiability
modulo theories) solver and proves a refinement relation between the code and
protocol proofs in different layers.

Verdi~\cite{verdi} is a distributed system verification tool chain
where developers specify and implement a system using a functional language
embedded in Coq while assuming a perfect network model. 
The system can then automatically convert
it into a system that handles a more realistic network and failure model,
and provides the refinement property of the system behavior on different network and failure models.
%They facilitate Verdi to verify Raft.~\cite{cppraft} 
%Using the framework, they show the correctness and the linearizability of their own Raft implementation written in Coq.

DISEL~\cite{disel}
studies how to verify and horizontally compose different distributed protocols.
It verifies the protocols in separation and uses send-hooks to restrict the
interference among protocols. Throne assumes a realistic network to begin with
and it not only allows both horizontal and vertical composition of verified distributed
protocols but also supports combined reasoning of protocols by using witnesses.

Taube et al.~\cite{modular} studied adding
decidability for verifying distributed systems using SMT solvers.
The work surrounding SMT solvers has a philosophical difference with our verification approach.
We use high-order logic and CCAL, which have higher expressiveness but less automation,
while SMT-solver-based work requires encoding higher-order concepts into
first-order logic for better automation. While a relatively large portion of the
verification can be automated, the SMT-solver-based approach has some limitations.
For example, certain higher-order properties (e.g. network reduction
in IronFleet) are not always encodable or verifiable in first order logic.


\section{Paxos Verification and Deconstruction}
A huge body of work exists on verifying the Paxos protocol~\cite{paxos}.
Lamport provided a proof sketch at the time of proposing the protocol~\cite{paxosmadesimple}
and Lampson attempted to distill Paxos into its core components by creating a very
high-level Abstract Paxos~\cite{Lampson2001} and showing how variants of
Paxos can be derived from it. Additional efforts were made to divide Paxos
into simpler components~\cite{dpaxos, sdpaxos} to find a reusable framework for
proving its variants. Our witness-based approach also attempts
to find a reusable framework for these proofs, but instead of decomposing Paxos
further, we make the key implicit invariants more explicit by passing around
the information needed to prove them.

Padon et al. verified high-level specifications of many variants of Paxos
and multi-Paxos while proposing a method to specify the protocols using
a decidable first-order logic~\cite{paxosepr}. Verification of Paxos
variants was made possible by reusing the specification and proof of vanilla
Paxos. Throne on the other hand can reuse the proof of a Paxos instance
due to CCAL to prove variants of Paxos using proof objects and verifies both the
C code and the specification of the system based on witness.


Woos et al. presented the verification of Raft~\cite{cppraft}. The properties
verified for Raft includes linearizability and soundness of the leader and
the code written in Coq translates to executable OCaml code. Throne
delegates verification of such Raft properties common to leader-based distributed
systems to the template and the final executable code extracted from
Throne is in assembly, which is generated from CompCert C compiler and is more
optimized than the OCaml code.


Within the category of distributed system verification, there is a significant amount of work focusing specifically on Paxos.
Lamport's first paper on the protocol~\cite{paxos}, and his second attempt to explain it more clearly~\cite{paxosmadesimple}
present the basic algorithm and give paper proofs of the safety properties.
Since then, many variations have been developed such as Disk Paxos~\cite{diskpaxos}, Egalitarian Paxos~\cite{epaxos},
and Vertical Paxos~\cite{vertpaxos}.
Oftentimes, although these variations seem similar to the original protocol, it is not possible to reuse the original
proof of the safety properties and a significant amount of work is required to re-prove them.
Lampson attempted to distill Paxos into its core components by creating a very high-level Abstract Paxos~\cite{Lampson2001}
and showing how other variants can be derived from it.
Some still felt that this did not get at the essence of the algorithm because at least two works since then \cite{dpaxos, sdpaxos}
have studied other ways of dividing Paxos into simpler components such that proofs of the protocol can be made more modular.
Our write-witness-passing approach also attempts to find a reusable framework for these proofs,
but instead of decomposing Paxos further, we make the key implicit invariants more explicit by passing around
the information needed to prove them.

This enables proofs to be done in a thread-local (or node-local) manner using an environment context to
capture the behavior of the rest of the world.
These proofs can then be linked together to obtain a strong correctness theorem for the entire system.

Our witness benefits greatly from using CCAL.
By decomposing distributed systems into layers, we reduce the amount of time and effort needed to
prove functional correctness.
By treating each distributed node as a separate thread, we can use the environment context to
prove properties in a local context.
Combining this with the witness then allows us to bring in information about the global state when necessary.
We also use the environment context to model a realistic, non-deterministic network.
Another advantage afforded by CCAL is that we can lift our safety proofs to higher layers via contextual refinement.
This allows us to implement and verify a system once, and then reuse it as a component in various distributed applications.


\section{Model of leader-based distributed system}
Our distributed system verification focuses on leader-based distributed system model, 
which is based on the two functions,
leader election and update functions, is inspired by CASPaxos~\cite{caspaxos},
which implements an atomic shared object. CASPaxos uses prepare and accept
phases similar to those in Paxos but it can repeatedly apply a compare-and-swap
functions to the stored state instead of setting it just once. While CASPaxos is a system implementation
to atomically update a distributed object, we use the implementation style of
CASPaxos to build a generic specification for leader-based distributed systems.
Our specification also resembles the high-level specification of a state machine
replication protocol, which Lamport generalized~\cite{generalizedconsensus}.
While Lamport mainly models multi-Paxos and consensus,Throne models and
verifies common properties of a generic leader-based distributed system,
which includes multi-Paxos and state machine replication.




