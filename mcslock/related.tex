\section{Related work and conclusions} 
\label{sec:related}

\paragraph{Verified system software}
CertiKOS is an end-to-end verified concurrent system showing that its
assembly code indeed ``implements'' (contextually simulates) the
high-level specification.
Other verified systems~\cite{klein2009sel4,hawblitzel10,hawblitzel:ironclad},
are single-threaded, or use a per-core big kernel lock.
The Verisoft team used VCC~\cite{vcc09} to verify spinlocks in a
hypervisor by directly postulating a Hoare logic rather than building
on top of an operational semantics for C, and only proved properties
about the low-level primitives rather than the full functionality of
the hypervisor. By contrast, CertiKOS deals with the problem of
formulating a specification in a way that can be used as one layer
inside a large stack of proofs. As for CertiKOS itself, while we
discussed the ``local'' verification of a single module, other papers
explain how to relate the log and context to a more realistic
nondeterministic machine model~\cite{certikos16}, how to
``concurrently link'' the per-CPU proofs into a proof about the full
system~\cite{ccal16}, and how this extends to multiple threads per
CPU~\cite{ccal16}.

%
%\paragraph{Other papers on CertiKOS}
%Because this paper focused on a single module of the kernel,
%we discussed the ``local'' aspects: how to formulate the
%specifications of the OS primitives and how to ascribe
%an atomic specification to a concurrent implementation.
%
%As the starting point of this paper, we assumed a C-level model where
%concurrency is handled through an event log, and the log only has to
%be updated from the context at certain points in the program. Gu et
%al.~\cite{certikos16} explain how to relate that model to a more
%realistic machine model where executions of different CPUs can be
%nondeterministically interleaved anywhere (the proof uses a
%backwards-simulation once at the lowest level of verification). The
%different machine model also required support in the correctness
%proofs for the C compiler.~\cite{ccal16}.
%
%We also need to relate the local refinement proofs of one primitive to
%proofs about the whole system. First, the proofs in this paper handle
%code running on a single CPU in isolation, with all the other CPUs
%abstracted away as a concurrent context. We need a ``concurrent
%linking'' theorem saying that this suffices to prove the correctness
%when all CPUs run simultaneously producing a single global
%log. Second, we only proved the correctness of a single layer in
%isolation, but eventually this will be composed with higher
%abstraction layers containing the client code of the lock (``vertical
%composition''), and eventually with user-code running on top of the
%OS. We need a ``contextual refinement'' theorem talking about the
%entire system. And finally, the abstraction level used in this paper
%only talks about inter-CPU concurrency, but to support user-space
%programs, at higher abstraction levels the OS needs to provide
%threading.~\cite{ccal16}

\paragraph{Fine-grained concurrency}
The MCS algorithm uses low-level operations like CAS instead of
locks. There is much research about how to reason about such programs,
more than we have space to discuss here. One key choice is how much to
prove. At least all operations should be
linearizable~\cite{herlihy:linearizability} (a safety property). Some
authors have considered mechanized verification of linearizability
(e.g. \cite{doherty:lock-free,derrick:mechanical-linearizability}),
but on abstract transition system models, not directly on executable
code. The original definition of linearizability instrumented programs
to record a global history of method-invocation and method-return
events. However, that's not a convenient theorem statement when
verifying client code. Our formulation is closer to Derrick et
al~\cite{derrick:mechanical-linearizability}, who prove a simulation
to a history of single atomic actions modifying abstract state.  Going
beyond safety, one also wants to prove a progress property such as
wait-freedom~\cite{herlihy:wait-freedom} or (in our case)
starvation-freedom~\cite{Herlihy08book}.

% Formal proofs have included
% e.g. Jia et al.~\cite{jia:lock-freedom}.  Most such research deals
% with datastructures (sets, queues, etc), but mutexes present one extra
% complication because different clients will hold the lock for
% different amount of times, so we had to introduce bound-numbers to
% give a modular specification.

Liang {\em et al}~\cite{liang13} showed that the linearizability and
progress properties~\cite{Herlihy08book} for concurrent objects is
exactly equivalent to various termination-sensitive versions of the
contextual simulation property. Most modern separation-style
concurrent
logics~\cite{cap10,Turon13popl,sergey15pldi,pinto14,iris15,pinto16} do
not prove the same strong termination-sensitive contextual simulation
properties as our work does, so it is unclear how they can be used to
prove both the linearizability and starvation-freedom properties of
our MCS Lock module.  Total-TaDA~\cite{pinto16} can be used to prove
the total correctness of concurrent programs but it has not been
mechanized in any proof assistant and there is no formal proof that
its notion of liveness is precisely equivalent to Helihy's notion of
linearizability and progress properties for concurrent
objects~\cite{Herlihy08book}. FCSL~\cite{sergey15pldi} attempts to
build proofs of concurrent programs in a ``layered'' way, but it does
not address the liveness properties. Many of these program
logics~\cite{Turon13popl,iris15}, however, support 
higher-order functions which our work does not address.

\paragraph{Other work on the MCS algorithm}
We are aware of two other efforts to apply formal verification methods
to the MCS algorithm.  Ogata and Futatsugi developed a mechanized
proof using the UNITY program logic.~\cite{ogata:mcs-lock} They work
with an abstract transition system, not executable code. Like us,
their correctness proof works by refinement (between a fine-grained
and a more atomic spec) but they directly prove backward
simulation.

One difference is that Ogata and Futatsugi's proof is
done using a weaker fairness assumption. They assume ``every CPU gets
scheduled infinitely often'', while we require a maximum scheduling
period ($F$ in Section~\ref{sec:liveness-atomicity}).  This is because
we write our specification of \lstinline$wait_lock$ as a Coq function
defined by recursion on a natural number, and all Coq functions must
be total. So although our ultimate theorem only states that the method
terminates ``eventually'', as an intermediate lemma we need to prove
an explicit natural number bound on when a given call to
\lstinline$wait_lock$ will finish.  We could avoid this by e.g. using
Coq's facilities to define functions by well-founded recursion, and
making the termination measure $M_i$ take ordinal instead of number
values, but in practice assuming a fixed $F$ seems like a reasonable
model of multi-core concurrency.

The other MCS Lock verification we know of is by Liang and
Feng~\cite{liang:lili}, who define a program logic LiLi to prove
liveness and linearizability properties and verify the MCS algorithm
as one of their examples.  The LiLi proofs are done on paper, so they
can omit many ``obvious'' steps, and they work with a simple
while-loop language instead of C. Many of the concepts in our proof
are also recognizable in theirs. The state of their concrete
  programs includes a pointer $\mathrm{\texttt{tail}}$ and nodes
  $\mathrm{\texttt{Node}}(\mathrm{\texttt{busy}}, \mathrm{\texttt{next}}, \mathrm{\texttt{ThrdID}})$.
In their invariant and precondition they use specificational variables
$\mathrm{\textit{ta}}$ and $\mathrm{\textit{tb}}$ (like \texttt{la} in
Sec.~\ref{subsec:atomicoperation}), $\mathrm{\textit{tl}}$ and $S$ (like $q$
and $s$ in Sec.~\ref{sec:representation-ghost}). Their
  ``wellformed lock'' predicate $\mathrm{\textsf{lls}}$ includes our
  tail-soundness and next-correctness properties, so in order to prove
  that the invariant is preserved they need essentially the same
  lemmas as in Section~\ref{sec:representation-ghost}. and their
termination measure $f(\mathrm{G})$ includes the length of
$\mathit{tl}$ and the size of $S$ (like $M$ in
Sec.~\ref{sec:liveness-atomicity}. On the other hand, the fairness
constant makes no appearance in $f(\mathrm{G})$, because fairness
assumptions are implicit in their inference rules.

A big difference between our work and LiLi is our emphasis on
modularity.  Between every two lines of code of a program in LiLi, you
need to prove all the different invariants, down to low-level data
representation in memory. The specification takes the form of a single
pre- and post-condition which involves concepts at many level of
abstraction. For example, unfolding the definition of the measure $f$,
we find not only $\mathit{tl}$, but also the tail-pointer $p$, and
eventually the lock-array $\mathit{ta}$. In our development, these
concerns are in different modules which can be completed by different
programmers.  Similarly, we aim to produce a stand-alone specification
of the lock operations. In the LiLi example, the program being
verified is an entire ``increment'' operation, which takes a lock,
increments a variable and releases the lock. The pre/post-conditions
of the code in the critical section includes the low-level
implementation invariants of the lock, and the fact the lock will
eventually be released is proved for the ``increment'' operation as a
whole. Our locks are specified using \emph{bound} numbers, so they can
be used by many different methods.

Apart from modularity, one can see a more philosophical difference
between the CertiKOS approach and program logics such as LiLi.  Liang
and Feng are constructing a program logic which is tailor-made
precisely to reason about liveness properties under fair
scheduling. To get a complete mechanized proof for a program in that
setting would require mechanizing not only the proof of the program
itself, but also the soundness proof for the logic, which is a big
undertaking. Other parts of the program will favor other kinds of
reasoning, for example many researchers have studied program logics
with inference rules for reasoning about code \emph{using} locks. One
of the achievements of the CertiKOS style of specification is its
flexibility, because the same model---a transition system with data
abstraction and a log of events---works throughout the OS kernel. When
we encountered a feature that required thinking about liveness and
fairness, we were able to do that reasoning without changing the
underlying logical framework.

\paragraph{Conclusion and Future Work}
Using the ``layers'' framework by Gu et al.~\cite{dscal15} made our
MCS lock proofs modular and reusable.  It also lets us verify the code
from end to end and extract certified executable code.  Those proofs
are also combined with client code using MCS Locks, which shows they
can be used in a large scale system verification without increasing
the complexity dramatically. As far as we know, this is the
  first mechanized MCS Lock proof with modular properties.  In the
future, we are planning to devise generic methods for building
oracles, log replay functions, liveness proofs, and so on. We intend
to generalize the machine model to handle weak memory models instead
of assuming sequential consistency. And we also plan to apply this
approach to other concurrent algorithms.
