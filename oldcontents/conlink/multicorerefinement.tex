
\clearpage

\subsection{Connecting Intermediate Languages}
\label{subsec:connect-intermediate-language}



\begin{figure}
\fbox{valid log and valid oracle:}


%
%  (* eback is always generated by scheduler *) 
%  Definition event_source (e: event) :=
%    match e with
%      | EYIELD i => i
%      | EBACK _ => sched_id
%      | EACQ i _ => i
%      | EREL i _ _ => i
%      | EATOMIC i _ _ => i
%    end.
%

$
\eventsourcefunckwd (ev : \mcevent) : \ztype := 
 \left\{\begin{array}{lr}
\schedid & \text{for } ev = \yieldbackev{\_} \\
i  & \text{for } ev =\yieldev{i}  \vee ev= \acqev{i}{\_} \\
   & \vee ev = \relev{i}{\_}{\_} \vee ev =  \atomicev{i}{\_}{\_}\\
\end{array} \right.
$

%
%  Definition event_des (e: event) :=
%    match e with
%      | EYIELD _ => sched_id
%      | EBACK i => i
%      | EACQ i _ => i
%      | EREL i _ _ => i
%      | EATOMIC i _ _ => i
%    end.
%

$
\eventdesfunckwd (ev : \mcevent) : \ztype := 
 \left\{\begin{array}{lr}
\schedid & \text{for } ev =\yieldev{\_} \\
i & \text{for } ev= \yieldbackev{i} \vee ev = \acqev{i}{\_}\\
   & ev=  \relev{i}{\_}{\_} \vee ev = \atomicev{i}{\_}{\_}\\
\end{array} \right.
$

%
%  Definition get_curid_from_log (start_core : Z) (l : Log) : Z :=
%    match l with
%    | nil => start_core
%    | e::l' => event_des e
%    end.
%

$
\getcuridfromlogkwd (start\_core : \ztype) (l : \mclog): \ztype :=
 \left\{\begin{array}{lr}
start\_core & \text{for }  l = \nulllist \\
\eventdesfuncnoeq{ev} & \text{for } l = \listcons{ev}{\_}\\
\end{array} \right.
$


%   
%    Definition valid_log_check (start_core : Z) (l : Log) :=
%      match l with
%      | nil => True
%      | e::l' =>
%        match e with
%        | EBACK j => lastEvTy l' = Some YIELDTY /\ core_set j = true
%        | EYIELD from => lastEvTy l' <> Some YIELDTY /\ from = get_curid_from_log start_core l' /\ core_set from = true
%        | _ => match l' with
%              | EBACK j'::_ => j' = event_source e /\  core_set j' = true
%              | _ => False
%              end
%        end
%      end.

\begin{mathpar}
\inferrule[valid log check - nil]
{\ }
{\validlogcheck{start\_core}{\nulllist}}

\inferrule[valid check - yieldback]
{ l = \listcons{e}{l'} \\
e = \yieldbackev{j} \\
l' = \listcons{\yieldev{\_}}{\_}\\
j \in \coreset}
{\validlogcheck{start\_core}{l}}

\inferrule[valid check - yield]
{l = \listcons{e}{l'} \\
e = \yieldev{from} \\
l' \neq \listcons{\yieldev{\_}}{\_}\\
\getcuridfromlog{start\_core}{l'}{from} \\
from \in \coreset}
{\validlogcheck{start\_core}{l}}

\inferrule[valid check - other]
{l = \listcons{e}{l'} \\
e \neq \yieldev{\_} \\
e \neq \yieldbackev{\_} \\
l' = \listcons{\yieldbackev{j'}}{\_}\\
\eventsourcefunc{e}{j'} \\
j' \in \coreset}
{\validlogcheck{start\_core}{l}}
\end{mathpar}

%
%    Inductive valid_log : Z -> Log -> Prop :=
%    | valid_log_nil :
%        forall tid, core_set tid = true -> valid_log_check tid nil -> valid_log tid nil
%    | valid_log_cons:
%        forall tid e l, core_set tid = true -> valid_log tid l -> valid_log_check tid (e::l) -> valid_log tid (e::l).
%

\begin{mathpar}
\inferrule[valid log - nil]
{tid \in \coreset\\
\validlogcheck{tid}{\nulllist}}
{\validlog{tid}{\nulllist}}

\inferrule[valid log - cons]
{tid \in \coreset\\
\validlog{tid}{l}\\
\validlogcheck{tid}{\listcons{e}{l}}}
{\validlog{tid}{\listcons{ev}{l}}}
\end{mathpar}


%    (* valid oracle conditions only for hw oracle and single oracle *)
%    (* similar to other valid_oracle conditions, 
%       it is defined as rely-guarantee style *)
%    Definition valid_oracle (start_core : Z) (A: ZSet) (o: Oracle) :=
%      forall l e,
%        valid_log start_core l -> 
%        oget A l o = Some e ->
%        (* thanks to this condition, hw_oracle only generate EBACK event, so 
%           we can use this valid oracle condition both for hw oracle and single oracle *)
%        A (event_source e) = false /\
%        valid_log start_core (e::l).

$
\begin{array}{l}
\validoraclekwd (start\_core : \ztype) (A : \set{\ztype}) (o : \mcoracle{A}{\mclog}{\mcevent}) := \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \\
\hfill \forall\ l \ e .\  \validlog{start\_core}{l} \rightarrow \oget{A}{\mclog}{\mcevent}{l}{o}{e} \rightarrow \\
\hfill \eventsourcefuncnoeq{e} \notin A \wedge \validlog{start\_core}{(\listcons{e}{l})}\\
\end{array}
$

\caption{Valid Log and Valid Oracle}
\label{fig:valid-log-valid-oracle}
\end{figure}




%%%%%%%%%%%%%%
\clearpage

\subsubsection{Oracle Refines Hardware}
\label{subsubsec:oracle-refines-hardware}

\begin{figure}
\fbox{variables for match relation}

$
\begin{array}{lllr}
cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
hw\_o & : & \mcoracle{\coreset}{\mclog}{\mcevent} &  \mbox{(hardware scheduler oracle)}\\
\end{array}
$

\fbox{local match state: $\ztype \rightarrow \ztype \rightarrow \privatestate \rightarrow \localstatekwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[match local neq]
{(curid = i \rightarrow b = \btrue) \\
(curid \neq i \rightarrow b = \bfalse) }
{\matchlocal{curid}{i}{ps}{(\localstate{ps}{b})}}
\end{mathpar}

\fbox{match state : $\mcstatekwd \rightarrow \hstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{(\forall \ i \ ps \ ls \ . \ i \in \coreset \rightarrow \getpstsome{\privatestate}{i}{psp}{ps} \rightarrow\\\\
\getpstsome{\localstatekwd}{i}{lsp}{ls} \rightarrow  \matchlocal{curid}{i}{ps}{ls})\\\\
 l \neq \listcons{\yieldev{\_}}{\_}\\
 curid \in \coreset \\
 \validlog{cpuid}{l} \\
 \getcuridfromlog{cpuid}{l}{curid}}
 {\matchstatehstate{(\mcstate{curid}{lsp}{l})}{(\hstate{curid}{psp}{l})}}
\end{mathpar}

\fbox{hypothesis}

\begin{enumerate}
\item valid$\_$cpuid: $cpuid \in \coreset$
\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\coreset}{hw\_o}$
\item related$\_$hw$\_$step$\_$hw$\_$oracle : \\
$
\begin{array}{l}
\matchstatehstate{(\mcstate{curid}{lsp}{l})}{(\hstate{curid}{psp}{l})} \rightarrow \\
\ \ \ \exists\ ev .\ \oget{\coreset}{\mclog}{\mcevent}{\listcons{\yieldev{curid}}{l}}{hw\_o}{ev} \wedge \\
\ \ \ \ \ \ \forall \ curid'' . \ ev = \yieldbackev{curid''} \rightarrow\\
\ \ \ \ \ \ \ \ \  \forall \ curid' \ ps \ st . \\
\ \ \ \ \ \ \ \ \ \ \ \ \hardwarelocalstep{curid'}{(\localview{ps}{(\listcons{\yieldbackev{curid'}}{\listcons{\yieldev{curid}}{l}})})}{st} \rightarrow\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ curid' = curid'' \\
\end{array}
$
\end{enumerate}

\fbox{top lemmas}

\begin{enumerate}
\item one$\_$step$\_$hw$\_$refines$\_$oracle : \\
$
\begin{array}{l}
\forall \ s_l \ s_l' \ t \ s_h . \ \hardwarestep{curid}{s_l}{t}{s_l'} \rightarrow  \matchstatehstate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_h' . \  \ccplusstep{\oraclestep{hw\_o}{s_h}{t}{s_h'}} \wedge  \matchstatehstate{s_h'}{s_l'}\\
\end{array}
$
\item match$\_$state$\_$implies$\_$one$\_$step: \\
$
\begin{array}{l}
\forall \ curid \ lsp \ l \ curid' \ hsp \ l' . \ \matchstatehstate{(\mcstate{curid}{lsp}{l})}{(\hstate{curid'}{hsp}{l'})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \exists \ curid'' \ lsp' \ l'  . \ \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ccstarstep{\oraclestep{hw\_o}{(\mcstate{curid}{lsp}{l})}{\ccemptytrace}{(\mcstate{curid''}{lsp}{l'})}} \wedge\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ l' = \listcons{\yieldbackev{curid''}}{\listcons{\yieldev{curid}}{l}} \wedge\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ (\forall \ ps  . \ \getpstsome{\localstatekwd}{curid}{lsp}{(\localstate{ps}{\btrue})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \  \ \ \setpst{\localstatekwd}{curid}{(\localstate{ps}{\bfalse})}{lsp}{lsp'} \\
\end{array}
$
\end{enumerate}

\caption{Oracle Refines Hardware}
\label{fig:oracle-refines-hardware}
\end{figure}

\clearpage


\subsubsection{Environmental Refines Oracle}
\label{subsubsec:env-refines-oracle}

\begin{figure}
\fbox{variables for match relation}

$
\begin{array}{lllr}
cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
hw\_o & : & \mcoracle{\coreset}{\mclog}{\mcevent} &  \mbox{(hardware scheduler oracle)}\\
\end{array}
$

\fbox{match state : $\envstatekwd_{[\coreset]} \rightarrow \mcstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{curid \in \coreset \\ 
\validlog{cpuid}{l} \\
l \neq \listcons{\yieldev{\_}}{\_}\\
\getcuridfromlog{cpuid}{l}{curid}\\
(\forall \ ps \ b \ tid  . \ tid \neq curid \rightarrow \getpstsome{\localstatekwd}{tid}{lsp}{(\localstate{ps}{b})} \rightarrow b = \bfalse)\\
(\forall \ ps \ b  . \ \getpstsome{\localstatekwd}{curid}{lsp}{(\localstate{ps}{b})} \rightarrow b = \bfalse \rightarrow \\\\
\exists \ e \ l' . \ l = \listcons{e}{l'} \wedge e = \yieldbackev{curid})} 
{\matchestatestate{(\envstate{\coreset}{curid}{lsp}{l})}{(\mcstate{curid}{lsp}{l})}}
\end{mathpar}


\fbox{hypothesis}

\begin{enumerate}
\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\coreset}{hw\_o }$
\end{enumerate}


\fbox{top lemmas}

\begin{enumerate}
\item one$\_$step$\_$env$\_$refines$\_$oracle : \\
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \envstep{\coreset}{hw\_o }{s_h}{t}{s_h'} \rightarrow  \matchestatestate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \ccplusstep{\oraclestep{hw\_o }{s_l}{t}{s_l'}} \wedge  \matchstatehstate{s_h'}{s_l'}\\
\end{array}
$
\end{enumerate}

\caption{Environmental Refines Oracle}
\label{fig:env-refines-oracle}
\end{figure}

\clearpage

\subsubsection{Environmental Refines Environmental}
\label{subsubsec:env-refines-emv}

\begin{figure}

\fbox{auxiliary function - decreasing index:}

\begin{tabular}{l}
$
   \mcmeasurekwd (l : \mclog)  : \nattype :=
     \left\{\begin{array}{lr}
        O & \text{for }  l = \listcons{\yieldev{\_}}{\_} \\
        S \ O & \text{otherwise}\\
        \end{array} \right.$ \\
$ \mcstatemeasurekwd (A : \set{\ztype}) (est : \envstatekwd_{[A]}) : \nattype := \mcmeasurenoeq{l} \ \ \ \ \ \ \ \ \ \ (\text{for } est = \envstate{A}{\_}{\_}{l}) $\\
$ \localstepevkwd (ev : \mcevent : \mathrm{option} \mclog := 
     \left\{\begin{array}{lr}
        \mathrm{Some} \ (\listcons{ev}{\nulllist}) & \text{for }  ev = \acqev{\_}{\_} \\
                                        & \vee  ev= \relev{\_}{\_}{\_} \\
                                        & \vee ev= \atomicev{\_}{\_}{\_} \\
        \mathrm{Some} \ \nulllist & \text{for }  ev = \yieldev{\_} \\
	   \mathrm{None} & \text{otherwise}\\
        \end{array} \right. $ \\
\end{tabular}        
%  Definition measure (l : Log) : nat := 
%    match lastEvTy l with 
%    | Some YIELDTY => O
%    | _ => S O 
%    end.
%  
%  Definition state_measure (A : ZSet) (est : estate (A := A)) :=
%    match est with 
%    | EState _ _ l => measure l 
%    end.
%
%  Definition local_step_ev (ev : event) : option Log := 
%    match ev with 
%    | EACQ _ _ => Some (ev::nil)
%    | EREL _ _ _ => Some (ev::nil)
%    | EATOMIC _ _ _ => Some (ev::nil)
%    | EYIELD _ => Some nil
%    | _ => None
%    end.


\caption{Auxiliary Functions for Refinements between two Environment Machines}
\label{fig:aux-functions-for-env-refines-env}
\end{figure}



\begin{figure}
\fbox{variables for match relation:}

$
\begin{array}{lllr}
cpuid & : & \ztype & \mbox{(starting and the focused CPU of the system)}\\
hw\_o & : & \mcoracle{\coreset}{\mclog}{\mcevent} &  \mbox{(hardware scheduler oracle)}\\
si\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mcevent} &  \mbox{(oracle for a single cpu)}\\
\end{array}
$

\fbox{match state : $\envstatekwd_{[\set{cpuid}]} \rightarrow  \envstatekwd_{[\coreset]}  \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[match state S]
{\mcmeasure{l}{S\ O} \\
curid \in \coreset \\
\validlog{cpuid}{l}\\
\getcuridfromlog{cpuid}{l}{curid}\\
\getpstnoeq{\localstatekwd}{cpuid}{lsp'} = \getpstnoeq{\localstatekwd}{cpuid}{lsp}\\
(curid = cpuid \rightarrow \forall \ ps \ b . \ \getpstsome{\localstatekwd}{cpuid}{lsp}{(\localstate{ps}{b})} \rightarrow\\\\
b = \bfalse \rightarrow \exists \ e \ l' . \ l = \listcons{e}{l'} \wedge e = \yieldbackev{curid})\\\\
(\forall \ tid  . \ tid \neq curid \rightarrow \forall \ ps \ b . \ \getpstsome{\localstatekwd}{tid}{lsp}{(\localstate{ps}{b})} \rightarrow b = \bfalse)\\\\
(curid \neq cpuid \rightarrow l = \listcons{\yieldbackev{\_}}{\_} \rightarrow\\\\
\forall \ ps \ b . \ \getpstsome{\localstatekwd}{curid}{lsp}{(\localstate{ps}{b})} \rightarrow b = \bfalse)\\\\
(curid \neq cpuid \rightarrow l \neq \listcons{\yieldbackev{\_}}{\_} \rightarrow\\\\
\forall \ ps \ b . \ \getpstsome{\localstatekwd}{curid}{lsp}{(\localstate{ps}{b})} \rightarrow b = \btrue)}
{\matchestateestate{\set{cpuid}}{(\envstate{\set{cpuid}}{curid}{lsp'}{l})}{(\envstate{\coreset}{curid}{lsp}{l})}}

\inferrule[match state O]
{\mcmeasure{l'}{O} \\
\getcuridfromlognoeq{cpuid}{l} \in \coreset \\
\validlog{cpuid}{l'}\\
l' = \listcons{\yieldev{curid}}{l} \\ 
curid' = \schedid\\
\getcuridfromlog{cpuid}{l}{curid} \\
\getpstnoeq{\localstatekwd}{cpuid}{lsp'} = \getpstnoeq{\localstatekwd}{cpuid}{lsp}\\
\getpstnone{\localstatekwd}{(\getcuridfromlognoeq{cpuid}{l})}{lsp'}\\
\oget{\set{cpuid}}{\mclog}{\mcevent}{l}{si\_o}{\yieldev{curid}}\\
(\forall \ tid  . \ tid \neq curid \rightarrow \forall \ ps \ b . \ \getpstsome{\localstatekwd}{tid}{lsp}{(\localstate{ps}{b})} \rightarrow b = \bfalse)\\\\
(curid \neq cpuid  \rightarrow \forall \ ps \ b  . \ \getpstsome{\localstatekwd}{curid}{lsp}{(\localstate{ps}{b})} \rightarrow\\\\
b = \bfalse \rightarrow  l = \listcons{\yieldbackev{\_}}{\_})}
{\matchestateestate{\set{cpuid}}{(\envstate{\set{cpuid}}{curid'}{lsp'}{l'})}{(\envstate{\coreset}{curid}{lsp}{l})}}

\end{mathpar}


\fbox{hypothesis}

\begin{enumerate}
\item valid$\_$cpuid: $cpuid \in \coreset$
\item valid$\_$oracle$\_$cond: $\validoraclenoeq{cpuid}{\set{cpuid}}{si\_o}$
\item related$\_$single$\_$oracle$\_$hw$\_$oracle$\_$def : \\
$
\begin{array}{l}
\forall \ l \ ev  . \ \validlog{cpuid}{l} \rightarrow l = \listcons{\yieldev{\_}}{\_} \rightarrow\\
\ \ \ \ \oget{\set{cpuid}}{\mclog}{\mcevent}{l}{si\_o}{ev} \rightarrow \oget{\coreset}{\mclog}{\mcevent}{l}{hw\_o}{ev} \\
\end{array}
$
\item relate$\_$single$\_$oracle$\_$concrete$\_$step$\_$def: \\ 
$
\begin{array}{l}
\forall \ curid' \ curid \ lsp' \ lsp \ l' \ l \ l\_res \ ps \ ev  . \\
\ \ \ \matchestateestate{\set{cpuid}}{(\envstate{\set{cpuid}}{curid'}{lsp'}{l'})}{(\envstate{\coreset}{curid}{lsp}{l})} \rightarrow\\
\ \ \ \getcuridfromlognoeq{cpuid}{l} \neq cpuid \rightarrow \\
\ \ \ \getpstsome{\localstatekwd}{\getcuridfromlognoeq{cpuid}{l}}{lsp}{(\localstate{ps}{false})} \rightarrow \\
\ \ \ \oget{\set{cpuid}}{\mclog}{\mcevent}{l}{si\_o}{ev} \rightarrow \\
\ \ \ \localstepev{ev}{l\_res} \rightarrow l = \listcons{\yieldbackev{\_}}{\_} \rightarrow \\
\ \ \ \exists\ (ps' : \privatestate) . \ \hardwarelocalstep{(\getcuridfromlognoeq{cpuid}{l})}{(\localview{ps}{l})}{(\localview{ps'}{l\_res})} \\
\end{array}
$
\end{enumerate}


\fbox{top lemmas}

\begin{enumerate}
\item one$\_$step$\_$env$\_$refines$\_$oracle : \\
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l. \ \envstep{\set{cpuid}}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchestateestate{\set{cpuid}}{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\exists \ s_l' .\ (\ccplusstep{\envstep{\coreset}{hw\_o}{s_l}{t}{s_l'}} \wedge\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \matchestateestate{\set{cpuid}}{s_h'}{s_l'}) \vee \\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\mcstatemeasurenoeq{\set{cpuid}}{s_h'} < \mcstatemeasurenoeq{\set{cpuid}}{s_h} \wedge t = \ccemptytrace \wedge \\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \matchestateestate{\set{cpuid}}{s_h'}{s_l})\\
\end{array}
$
\end{enumerate}


\caption{Environmental Refines Environmental}
\label{fig:env-refines-env}
\end{figure}


\clearpage


\subsubsection{Single Refines Environmental}
\label{subsubsec:single-refines-emv}

\begin{figure}
\fbox{variables for match relation}

$
\begin{array}{lllr}
cpuid & : & \ztype &  \mbox{(starting and the focused CPU of the system)}\\
\end{array}
$

\fbox{match state : $\singlestatekwd \rightarrow \envstatekwd_{[cpuid]} \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{\getpstsome{\localstatekwd}{cpuid}{lsp}{ls}}{\matchsinglestatestate{\set{cpuid}}{(\singlestate{curid}{ls}{l})}{(\envstate{\set{cpuid}}{curid}{lsp}{l})}}
\end{mathpar}

\fbox{top lemmas}
\begin{enumerate}
\item one$\_$step$\_$single$\_$refines$\_$env : \\
$
\begin{array}{l}
\forall \ si\_o \ s_h \ s_h' \ t \ s_l . \ \singlestep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchsinglestatestate{\set{cpuid}}{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \ccplusstep{\envstep{\set{cpuid}}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchsinglestatestate{\set{cpuid}}{s_h'}{s_l'}\\
\end{array}
$
\end{enumerate}

\caption{Single Refines Environment}
\label{fig:single-refines-env}
\end{figure}

\clearpage

\subsubsection{Big Refines Single}
\label{subsubsec:big-refines-single}

\begin{figure}
\fbox{variables for match relation}

$
\begin{array}{lllr}
cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
si\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mcevent} &  \mbox{(oracle for a single cpu)}\\
\end{array}
$

\fbox{match state : $\envstatekwd_{[\coreset]} \rightarrow \mcstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{ s_h = s_l \\
s_h = \singlestate{tid}{(\localstate{ps}{b})}{l} \\
\validlog{cpuid}{l} \\
l \neq \listcons{\yieldev{\_}}{\_}\\
\getcuridfromlog{cpuid}{l}{cpuid}\\
(b = \bfalse \rightarrow \exists \ e \ l' . \ l = \listcons{e}{l'} \wedge e = \yieldbackev{cpuid})}
{\matchbsstatesstate{s_h}{s_l}}
\end{mathpar}


\fbox{hypothesis}

\begin{enumerate}
\item valid$\_$cpuid: $cpuid \in \coreset$
\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\set{cpuid}}{si\_o }$
\end{enumerate}


\fbox{top lemmas}

\begin{enumerate}
\item start$\_$step$\_$get$\_$env$\_$log: \\
$\begin{array}{l}
\forall \ n \ l \ res \ l' \ ps \ curid . \ cpuid \neq curid \rightarrow \yieldbackfunc{n}{cpuid}{l}{res}{si\_o}{l'} \rightarrow\\
\ccstarstep{\singlestep{cpuid}{si\_o}{(\singlestate{curid}{ps}{(\listapp{res}{l})})}{\ccemptytrace}{(\singlestate{cpuid}{ps}{(\listapp{l'}{l})})}}\\ 
\end{array}
$
\item one$\_$step$\_$big$\_$refines$\_$single : \\
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlebigstep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchbsstatesstate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s\_l' . \  \ccplusstep{\singlestep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchbsstatesstate{s_h'}{s_l'}\\
\end{array}
$
\end{enumerate}

\caption{Big Refines Single}
\label{fig:big-refines-single}
\end{figure}

\clearpage

\subsubsection{Big2 Refines Big}
\label{subsubsec:bigtwo-refines-big}

\begin{figure}
\fbox{match state : $\rstatekwd \rightarrow \singlestatekwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[match state]
{\ }
{\matchrstatesinglestate{cpuid}{(\rstate{ps}{l})}{(\singlestate{cpuid}{(\localstate{ps}{true})}{l}}}
\end{mathpar}


\fbox{hypothesis}

\begin{enumerate}
\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\coreset}{hw\_o }$
\end{enumerate}


\fbox{top lemmas}

\begin{enumerate}
\item one$\_$step$\_$big2$\_$refines$\_$big : \\
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlebigtwostep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchrstatesinglestate{cpuid}{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s\_l' . \  \ccplusstep{\singlebigstep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchrstatesinglestate{cpuid}{s_h'}{s_l'}\\
\end{array}
$

\end{enumerate}

\caption{Big2 Refines Big}
\label{fig:bigtwo-refines-big}
\end{figure}

\clearpage


\subsubsection{Split Refines Big2}
\label{subsubsec:split-refines-bigtwo}

\begin{figure}

\fbox{match state : $\srstatekwd \rightarrow \rstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{l' = \listapp{al}{l}}
{\matchsrstaterstate{(\srstate{ps}{l}{al})}{(\rstate{ps}{l'})}}
\end{mathpar}


\fbox{top lemmas}

\begin{enumerate}
\item single$\_$local$\_$imply$\_$env:\\
$
\begin{array}{l}
\forall \ cpuid \ l \ ps \ ps' .\ \singlelocalstep{cpuid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hardwarelocalstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{\nulllist})}\\
\end{array}
$
\item single$\_$log$\_$imply$\_$env:\\
$
\begin{array}{l}
\forall \ cpuid \ l \ l' \ ps \ ps' .\ \singlelogstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{l'})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \hardwarelocalstep{cpuid}{(\localview{ps}{l})}{(\localview{ps'}{l'})}\\
\end{array}
$
\item one$\_$step$\_$split$\_$refines$\_$big2 : \\
$
\begin{array}{l}
\forall \ cpuid \ si\_o \ s_h \ s_h' \ t \ s_l . \ \singlesplitstep{cpuid}{si\_o}{s_h}{t}{s_h'} \rightarrow  \matchsrstaterstate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \ccplusstep{\singlebigtwostep{cpuid}{si\_o}{s_l}{t}{s_l'}} \wedge  \matchsrstaterstate{s_h'}{s_l'}\\
\end{array}
$
\end{enumerate}

\caption{Split Refines Big2}
\label{fig:split-refines-bigtwo}
\end{figure}


\clearpage

\subsubsection{Reorder Refines Split}
\label{subsubsec:reorder-refines-split}

\begin{figure}
\fbox{auxiliary function}
%  Definition valid_cache_log_members (tid : Z) (l : Log) :=
%    forall ev, In ev l -> event_source ev <> tid \/ GetEvTy ev = YIELDTY.
\begin{mathpar}
\inferrule[nil]
{ \ }
{\validcachelogmembers{cpuid}{\nulllist}}

\inferrule[nonil]
{ev \in l\\
(\eventsourcefuncnoeq{ev} \neq cpuid \vee ev = \yieldev{\_})}
{\validcachelogmembers{cpuid}{l}}
\end{mathpar}

\fbox{variables for match relation}

$
\begin{array}{lllr}
cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
si\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mcevent} &  \mbox{(oracle for a single cpu)}\\
re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(oracle for a single cpu - reordered)}\\
\end{array}
$

\fbox{match state : $\rstatekwd \rightarrow \srstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{ ps_h = ps_l \\
l_h = l_l \\
\validlog{cpuid}{(\listapp{al}{l_l})}\\
\getcuridfromlog{cpuid}{\listapp{al}{l_l}}{cpuid}\\
l_h \neq \listcons{\yieldev{\_}}{\_} \\
(al = \nulllist \vee (\exists \ ev \ al' . \ al = \listcons{ev}{al'} \wedge ev = \yieldbackev{cpuid}))\\
\validcachelogmembers{cpuid}{al}}
{\matchrstatesrstate{(\rstate{ps_h}{l_h})}{(\srstate{ps_l}{l_l}{al})}}
\end{mathpar}


\fbox{hypothesis}

\begin{enumerate}
\item valid$\_$oracle$\_$def: $\validoraclenoeq{cpuid}{\set{cpuid}}{si\_o }$
\item YieldBack$\_$consistence$\_$with$\_$reorder$\_$o :\\
$
\begin{array}{l}
\forall \ ps_h \ l_h \ ps_l \ l_l \ al.\ \matchrstatesrstate{(\rstate{ps_h}{l_h})}{(\srstate{ps_l}{l_l}{al})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \validlog{cpuid}{(\listcons{\yieldev{cpuid}}{\listapp{al}{l_l}})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \exists\ l_1. \ \yieldbackfunc{\timebound}{cpuid}{\listcons{\yieldev{cpuid}}{\listapp{al}{l_l}}}{\nulllist}{si\_o}{l_1} \wedge \\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \forall \ l_1' .\  \oget{\set{cpuid}}{\mclog}{\mclog}{l_h}{re\_o}{l_1'} \rightarrow \\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ l_1' = \listapp{l_1}{\listcons{\yieldev{cpuid}}{al}} \\
\end{array}
$
\end{enumerate}


\fbox{top lemmas}

\begin{enumerate}
\item one$\_$step$\_$reorder$\_$refines$\_$split : \\
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlereorderstep{cpuid}{re\_o}{s_h}{t}{s_h'} \rightarrow  \matchrstatesrstate{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' .\ \singlesplitstep{cpuid}{si\_o}{s_l}{t}{s_l'} \wedge  \matchrstatesrstate{s_h'}{s_l'}\\
\end{array}
$
\end{enumerate}

\caption{Reorder Refines Split}
\label{fig:reorder-refines-split}
\end{figure}


\clearpage

\subsubsection{Reorder Refines Reorder}
\label{subsubsec:reorder-refines-reorder}



\begin{figure}

%  Fixpoint reduce_log (l: Log) :=
%    match l with
%      | nil => nil
%      | e :: l' =>
%        match log_event_source e with
%          | None => (reduce_log l')
%          | _ => e :: (reduce_log l')
%        end
%    end.

\fbox{auxiliary function}

$
\mcreducelogfunckwd (l : \mclog) : \mclog := 
 \left\{\begin{array}{lr}
\nulllist & \text{for } l = \nulllist \\
\listcons{ev}{l_r'} & \text{for } l = \listcons{ev}{l'} \wedge \mcreducelogfunc{l'}{l_r'}\\
&\wedge(ev \neq \yieldev{\_} \wedge ev \neq \yieldbackev{\_})\\
%& (ev = \acqev{\_} \vee ev = \relev{\_}{\_}{\_} \vee ev = \atomicev{\_}{\_}{\_})\\
l_r' & \text{for } l = \listcons{ev}{l'} \wedge \mcreducelogfunc{l'}{l_r'}\\
&\wedge (ev = \yieldev{\_} \vee ev = \yieldbackev{\_})\\
\end{array} \right.
$


\fbox{variables for match relation}

$
\begin{array}{lllr}
cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
hi\_re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(oracle for a single cpu - simplified)}\\
lo\_re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(oracle for a single cpu - reordered)}\\
\end{array}
$

%\fbox{match state : $\rstatekwd \rightarrow \rstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{\mcreducelogfunc{l}{l'}}
{\matchrrstaterrstae{(\rstate{ps}{l'})}{(\rstate{ps}{l})}}
\end{mathpar}


\fbox{hypothesis}

\begin{enumerate}
\item relate$\_$reorder$\_$oracle$\_$def: \\
$
\begin{array}{l}
\forall \ ps \ l.\ \matchrrstaterrstae{(\rstate{ps}{(\mcreducelogfuncnoeq{l})}}{(\rstate{ps}{l})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \forall \ l_h. \ \oget{\set{cpuid}}{\mclog}{\mclog}{(\mcreducelogfuncnoeq{l})}{hi\_re\_o}{l\_h} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists \ l. \ \oget{\set{cpuid}}{\mclog}{\mclog}{l}{lo\_re\_o}{l\_l} \wedge \mcreducelogfunc{l\_l}{l\_h} \\
\end{array}
$
\end{enumerate}


\fbox{top lemmas}

\begin{enumerate}
\item one$\_$step$\_$reorder$\_$refines$\_$reorder : \\
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singlereorderstep{cpuid}{hi\_re\_o}{s_h}{t}{s\_h'} \rightarrow \matchrrstaterrstae{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \singlereorderstep{cpuid}{lo\_re\_o}{s_l}{t}{s\_l'} \wedge  \matchrrstaterrstae{s_h'}{s_l'}\\
\end{array}
$
\end{enumerate}

\caption{Reorder Refines Reorder}
\label{fig:reorder-refines-reorder}
\end{figure}


\clearpage

\subsubsection{Separate Refines Reorder}
\label{subsubsec:separate-refines-reorder}

\begin{figure}

\fbox{auxiliary function}
%
%  Fixpoint remove_cache_event (l: Log) (tid: Z) :=
%    match l with
%      | nil => nil
%      | e :: l' =>
%        if zeq tid (event_source e) then l
%        else remove_cache_event l' tid
%    end
%

$
\removecacheeventkwd (l : \mclog) (cpuid : \ztype): \mclog := 
 \left\{\begin{array}{lr}
\nulllist & \text{for } l = \nulllist \\
\listcons{ev}{l_r'} & \text{for } l = \listcons{ev}{l'}  \wedge \eventsourcefunc{e}{cpuid}\\
    &  \wedge \removecacheevent{l'}{cpuid}{l_r'}\\
l_r' & \text{for } l = \listcons{ev}{l'}  \wedge \eventsourcefuncnoeq{e}\neq {cpuid}\\
    &  \wedge \removecacheevent{l'}{cpuid}{l_r'}\\
\end{array} \right.
$


\begin{mathpar}
\inferrule[valid log']
{\mcreducelogfunc{l}{l}}
{\validlogprim{l}}
\end{mathpar}
%
%  Definition valid_log' (l : Log) : Prop :=
%    l = reduce_log l.
%
%  Definition valid_oracle' (tid: Z) (o : Oracle (OracleProp := re_op)) :=
%    forall l l', 
%      valid_log' l ->
%      oget (s_set tid) l o = Some l' ->
%      (forall e, In e l' -> event_source e <> tid) /\
%      valid_log' l'.
%  
%

$
\begin{array}{l}
\validoracleprimkwd (cpuid: \ztype) (o : \mcoracle{\set{cpuid}}{\mclog}{\mclog}) := \\
\ \ \ \ \forall \ l \ l' . \ \validlogprim{l} \rightarrow \oget{\set{cpuid}}{\mclog}{\mclog}{l}{o}{l'} \rightarrow\\
\ \ \ \ \ \ \ \ (\forall \ e . e \in l' \rightarrow \eventsourcefuncnoeq{e} \neq cpuid) \wedge \validlogprim{l'}\\
\end{array}
$

\fbox{variables for match relation}

$
\begin{array}{lllr}
cpuid & : & \ztype & \mbox{(starting CPU of the system)}\\
sep\_o & : & \mcoracle{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd} &  \mbox{(separate log type oracle)}\\
re\_o & : & \mcoracle{\set{cpuid}}{\mclog}{\mclog} &  \mbox{(reordered log oracle)}\\
\end{array}
$

\fbox{match logs : $\ztype \rightarrow \separatelogkwd \rightarrow \mclog \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match log]
{\getseparatelog{id_{prim}}{l_{sep}}{l_{h}}\\
\loggetatom{l_{glob}}{id_{prim}}{l_l}\\
\separatelogtwolog{l_h}{id_{prim}}{\removecacheeventnoeq{l_l}{curid}}}
{\mcmatchlogs{curid}{l_{sep}}{l_{glob}}}
\end{mathpar}

\fbox{match state : $\ztype \rightarrow \spstatekwd \rightarrow \rstatekwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[match state]
{\validlogprim{l_{glob}}\\
\mcmatchlogs{curid}{l_{sep}}{l_{glob}}}
{\matchspstaterstate{curid}{(\spstate{ps}{l_{sep}})}{(\rstate{ps}{l_{glob}})}}
\end{mathpar}

\fbox{hypothesis}

\begin{enumerate}
\item valid$\_$oracle$'\_$def: $\validoracleprim{cpuid}{re\_o }$
\item relate$\_$separate$\_$oracle$\_$reorder$\_$oracle$\_$def:\\
$
\begin{array}{l}
\forall \ ps \ l_{sep} \ l_{glob} \ id  \ l_{id} \ l_{id}' \ e .\ \matchspstaterstate{curid}{(\spstate{ps}{l_{sep}})}{(\rstate{ps}{l_{glob}})} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \getseparatelog{id}{l_{sep}}{l_{id}} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \oget{\set{cpuid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}{(id, l_{id}, e)}{sep\_o}{l_{id}'} \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   \exists \ l_{glob}' .\ \oget{\set{cpuid}}{\mclog}{\mclog}{l_{glob}}{re\_o}{l_{glob}'} \wedge \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \loggetatom{\listapp{l_{glob}'}{l_{glob}}}{id}{\separatelogtwolognoeq{\listapp{l_{id}'}{l_{id}}}{id}} \\
\end{array}
$
\end{enumerate}


\fbox{top lemmas}

\begin{enumerate}
\item one$\_$step$\_$separate$\_$refines$\_$reorder : \\
$
\begin{array}{l}
\forall \ s_h \ s_h' \ t \ s_l . \ \singleseparatestep{cpuid}{sep\_o}{s_h}{t}{s_h'} \rightarrow  \matchspstaterstate{cpuid}{s_h}{s_l} \rightarrow \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \exists\ s_l' . \  \singlereorderstep{cpuid}{re\_o}{s_l}{t}{s_l'} \wedge  \matchspstaterstate{cpuid}{s_h'}{s_l'}\\
\end{array}
$
\end{enumerate}

\caption{Separate Refines Reorder}
\label{fig:separate-refines-reorder}
\end{figure}
