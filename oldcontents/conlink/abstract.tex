Concurrent programs are in common these days because 
multicore hardware and multithreaded programming become 
ubiquitous. 
They, however, are known to be difficult to get right 
and debug 
because multiple instances of 
the program running on different cores and/or threads 
provide the number (usually unbounded) of interleavings. 

The number of Interleavings is also a burden in
concurrent program verification,
and 
compositionality is the most promising approach to fight 
the case explosion due to interleavings.
To make it possible, 
the concurrent program verification should 
be divided as two parts;
1) the proof of a single instance of the program 
 (\textit{i.e.} the instance runs on one CPU or one thread);
 and 2) 
 the linking proof of them to show 
that the composition of those proof instances and  
the composition correctly reflects 
the concurrent program running on the 
multicore and/or multithreaded environment.

Several previous works~\jieung{need cite} 
provides multiple kinds of approaches to handle 
one or both challenges 
and one recent work 
provides the idea 
to handle both problems.
They, however, 
do not provide 
how 
the machine checked proof object 
for large scaled concurrent program 
work. 

Thus, this paper focus on the realistic issue of 
providing composition in concurrent program verification. 
We define (sequential consistency) multicore machine model that are reusable for multiple 
machines (such as ARM and x86), 
and introduce several intermediate languages 
to connect them with the assembly machine of the variance of  \compcertkwd .
We also provide unbounded multithreaded machine model and introduce the per-thread machine model 
based on it, which can use \compcertkwd \ compiler as well as be able to allocate 
dynamic private datum for all threads.
As far as we know, this is the first attempt to address composition of concurrent programs with s
machine checked proofs in detail. 


%
% concurrent 
%
%This paper aims to 
%provide the proof 
%
%but does not shows 
%how building the practical and feasible proof linking framework works. 
%
%Thus, 
%this paper focus on how to practically connect 
%the program running on concurrent environment 
%to the collection of program instances with 
%a partial subset of participants of the system. 




%The work, however, 
%omits how linking works in detail
%for large scaled program verification
%that uses practical 
%machine model in it. 




%
% to verify concurrent 
%
%
%programs with 
%focusing on a single instance of concurrent 
%program (\textit{i.e.} the instance runs on one CPU or one thread)
%and hiding the communication with other instances by 
%providing proper assumptions. 
%Some of them also provide 
%how multiple proof instances can be linked with others. 
%
%Both of them are important parts of concurrent program verification 
%and the recent work~\jieung{ccal cite}
%provides the way 
%to build a large-scaled certified concurrent program 
%via layered structure. 
%The program 
%
%However, 
%providing the evidence that 
%multiple instances in concurrent programs are also important to 
%guarantee correctness of the concurrent program. 
%
%One recent work 
%
%
%
%hiding number of inte
%
%
%
%In this sense, 
%verification is highly desirable to guarantee high-assurance
%concurrent programs. 
%Several previous works~\jieung{need cite} 
%provides multiple kinds of approaches to verify concurrent 
%programs. 
%Some of them are focus on single instance of concurrent 
%program with the proper assumptions of the environment,
%others are focus on the whole concurrent program at once. \jieung{is it true?}
%
%To build the large-scaled verified concurrent program, 
%the first method is required since it can hide details of interleaving.  
%
%
%
%For those programs, verification is desirable due to the difficulty of 
%getting right and debugging. 
%However,  verification of concurrent programs is known to be extremely difficult. 
%Besides the challenges regards the sequential program verification, 
%it adds the need to consider the environment of the program, 
%which provides the number of interleavings. 
%
%To reduce the complexity due to interleavings, 
%multiple methodologies~\jieung{need cites}  focus on a single instance of 
%concurrent program (\textit{i.e.} one thread) with 
%the proper modeling of other instances in the whole environment.
%Among them, few works also provide a way to reason about the correctness of
%a large scaled concurrent programs.
%
%The recent work~\jieung{ccal cite} 
%shows that the verified practical sized concurrent program is feasible. 
%It provides the way to build certified concurrent layers and also provides the high-level overview 
%of combining multiple instances of concurrent programs. 
%the paper, however, does not show how multiple instance of programs can be linked together.
%
%
%\ignore{
%The verification of concurrent programs contains two parts.
%It first requires the program logic and the tool that can verify each instance of concurrent programs separately. 
%For this purpose, several approaches~\jieung{need cites}  are proposed during several decades.
%This certified single instance usually relies on a set of assumptions related to 
%other instances of the whole concurrent environment. 
%Thus the second part of the verification, which we focus on this paper, is 
%providing the formal connection between the collection of the concurrent program instances and 
%the single instance of the 
%}

%
%This paper shows that how multiple instances of practical concurrent system can be linked together. 
%
%
%
%
%
%
%In this paper, we present detailed machine model for 
%This paper shows how the proofs in the single core machine can be combined 
%sudo-x86 non deterministic machine model that uses the similar that of instructions in CompCert X86 assembly. 
%
%Similar to the multicore case, we present the machine model for multithreaded programs, and shows how we 
%propose per-thread machine with providing formal linking proofs   
%
%
%
%%Software verification is desirable and necessary to achieve the high assurance systems which are safety critical, such as 
%%avionic, health, and self-driving systems. 
%%The software verification itself is known as a costly work, and 
%%Modern programs usually run on the environment that contains multiple sources of interleavings.
%Among them, multicore and multithreaded environment are prevalent and common in most system software including operating systems, which are the basis of complex software stacks. 


%
%However, concurrent program verification also requires us to 
%provide the evidence that the assumptions about the concurrent environment (e.g. multicore / multithreaded / device drivers) 
%
%
%During several decades, 
%concurrent software verification is considered
%as an important problem as well as a challenging problem. 
%Despite of the important of the topic, however, 
%large scale concurrent software verification is considered as an challenging problems. 
%
%Multiple previous works~\jieung{need cites} handle 




%
%
%Providing the justification of the correctness for the program running on those concurrent environments are notoriously hard. 
%In addition to that, providing that the single instance of object fields
%	