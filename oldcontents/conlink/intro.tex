\section{Introduction}
\label{sec:intro}

%%% Outline
%% structure 
%% 1. concurrent verification is done in several works 
%% 2. how about showing the non-deterministic full machine model refines  ... 
%% 3. For example CCAL provide a useful tool for building concurrent abstraction layer 
%% 3-1. building layers is feasible 
%% 3-2. However proving the refinement between concurrent machine model and the per-instance machine model 
%%
%% 3-3. Based on the CCAL, we show how we build the linking for them 
%% 3-3-1. Multicore Linking 
%% 3-3-1-1. t provides the universal abstract semantics for multicore non-deterministic machine (with sequential consistency)
%% 3-3-1-2. it provides detailed refinement between those abstract functions 
%% 3-3-1-3. it provides the concrete instance of those proofs by connecting them with the lowest layer of CompCertX layer 
%% 3-3-2. Multithreaded Linking 
%% 3-3-3-1. It provides the CompCert Assembly machine models for CompCertX to build per-thread machine models 
%% 3-3-3-2. it provides the refinement between those machine models (parameterized by any kinds of Layers with the guarantee about the certain properties) 
%%                 - that allows us to allocate the proper dynamic initial state for each thread / invariant preserving in the initial state / using the same compiler with 
%%                    CompCertX                    
%% 3-3-3-3. it provides the actual proofs using the example in the certified layers (the language and the proofs are parameterized by the concrete layer definition)
%%                  - shows the identity of the private state change while  sleep and yield 
%%                  - mutual exclusion of user memory regions 
%%                  - mutual exclusion of other private states  






%
%Dependencies due to shared data
%•
%Subtle effects of synchronizations
%•
%Often manually parallelized
%–
%Difficult to debug
%•
%too many 
%interleavings
%of threads
%•
%hard to reproduce bugs
%
%
%
%

%%% concurrent program verification is necessary 
The prevalence of shared-memory multicore machine 
brings the eminent changes in the  software. 
With the machine, achieving higher performance on a single computer than before 
becomes possible, 
but it requires us to facilitate 
concurrency, running multiple threads on multiple cores.
Concurrency, however, 
brings the whole new challenges in terms of software correctness. 
They are well known 
to be difficult to get right and to debug because 
of their intrinsic characteristic, numerous number (usually unbounded) of interleavings among multiple components of the system. 
Testing is also not a promising way to provide the high-assurance of those programs. 
Due to a plethora of possible interleavings, 
reproducing a bug is unfeasible unless testers knows the 
precise interleaving order of them. 
In this sense, 
Building reliable concurrent programs 
needs verification of them, which formally shows that those programs correct reflects the 
desirable behavior (\textit{i.e.,} are stated in their specifications) 
without missing any single interleaving cases. 

%%% Composition is required
The concurrent program verification requires compositional reasoning in its essence,
since it provides an isolation of each instance of concurrent program
(on a single core or a single thread) separately  
 in its verification
without directly considering complex interleaving 
with other components in the system. 
This feature is crucial in some sorts 
of concurrent programs such as 
operating systems, libraries, or application interfaces
because the
proof of them 
are usually need to be parameterized by 
other programs running on them. 
In those cases, composition and proof isolation 
give  an enough power 
to state and prove the correctness property 
of those programs upon any arbitrary context programs run with the targeted programs. 

%%%% several previous works and machine checkable proof  

In this sense, 
multiple previous works handle compositional reasoning about concurrent programs.
There are two traditional different approaches,
rely-guarantee~\jieung{cite rely guarantee} and separation logic~\jieung{CSL cite separation logic  - need to refer View for citation},
and many other approaches that stem from either or both of them
\jieung{SAGL (2007) / Bornat-at (2005) RGSep (2007) Gotsman-al (2007) RSL (2013) Deny Guarantee (2009) LRG (2009) RGSim (2012) Liang-Feng (2013) 
Lili (2016) / Iris (2015) Iris 2.0 (2016) FCSL (2014) (SCSL (2013) FTCSL (2015) CoLoSL (2015) CAP (2010)   View paper / CCAL paper / CSpec (MIT)
- Please refer the specification of POSIX File Systems slide}.
In addition, some of them are not only focusing on the functional correctness but also 
shows liveness~\jieung{LiLi}. 
Some, CSpec and CCAL, also provides a verified layered structure to build modular verification, an another important 
feature to build a large scaled program verification in a modular ways.


%%%% several previous works and machine checkable proof  
Bsed on them, few works \jieung{verifying concurrent software using movrs in CSPEC / preemtive kernel verification (Xinyu Feng - CAV), CertiKOS, MCSLock CCAL} 
organizes machine checked proofs 
about concurrent execution. 
Among them, both CSPEC and CertiKOS facilitates layered structures 
for scalable and modular verification and formally connect top level operations into bottom-layer operations.

%%%% CCAL - what is missing 
They, however, overlook the difficulty in one another piece of machine checked concurrent program verification, 
provide the evidence of concurrent linking.
The concurrent linking shows 
the precise evidence of the composition that the underlying logics provide. 
In this sense, 
it requires the definition of 
concurrent machine model that can run multiple instances of concurrent program together (\textit{e.g.,} multicore and multithreaded machine) 
as well as 
the linking proofs between the program runs on top of concurrent machine and the composition of multiple single instances together. 
It also requires the proof that 
shows the single instance of the concurrent program correctly reflects
the program run on the multicore machine model. 

They are necessary to show the full correctness of the program, 
but providing concurrent machine model is bothersome, especially when the model is close to that of bare machines, 
and the proof between it wiith the machine that runs the single instance is also a subtle work.
To handle those challenges,
CCAL slightly mentioned these issues,
but it only carries out
a key idea of
linking without exposing underlying multiple obstacles.  
In this sense, 
providing the information about which steps are necessary for concurrent linking and what kind of things that 
the users have to fill out is desired.
In this sense, the idea in the paper is far from 
the enough idea to achieve how 
concurrent linking can be worked in such 
a large scaled concurrent program. 

\jieung{need to add sentence about CompCertX}


%%%% The contribution of this paper

Therefore, our paper aim to deliver all necessary 
and important ides for concurrent linking,
which includes modeling the generic concurrent machine model, 
necessary information to prove refinements between them, 
and how to connect those concurrent linking with the 
proof layers of concurrent programs in a generic way. 
It is definitely not able to be achieved in a single shot.
We introduce multiple intermediate languages and 
context that users has a responsibility to 
connect the generic concurrent linking proof with 
their one verified programs.
We, in this paper, handle all of them in detail. 
In short, he key contribution of this paper is as follows: 

\begin{itemize}
\item We formally define non-deterministic multicore semantics and multiple intermediate languages that are independent from specific machines (such as x86 or ARM). 
\item We provide the refinement proofs between them that can be used for \compcertkwd-style backward simulation. 
\item We connect those intermediate languages and proofs with the CPU local CCAL layer, that uses \compcertkwd-like sequential x86 assembly model with 
environment context.
\item We provide multithreaded machine model with minimal assumptions about a certain CPU local CCA layer, which implies that the machine model does not stick to the specific layer definition.
\item We provide intermediate languages to introduce per thread machines and refinement proofs among them. 
\item We connect those intermediate languages and refinement proofs with the specific layer definition in CertiKOS, which fully link the layer on per-thread machine with the layer on per-CPU machine.
\end{itemize}

The structure of remaining paper is as follows:
Section~\ref{sec:overview} shows a brief high level idea of CCAL as well as how our linking works. Section~\ref{sec:multicore} shows the details of multicore linking,
and Sect.~\ref{sec:multithreaded} shows the implementation of our intermediate machine models for our multithreaded environment.
Section~\ref{sec:multithreaded-linking-impl} shows how are framework 
can be fitted into the actual concurrent kernel implementations.
Evaluations about our implementation can be found in Sect.~\ref{sec:evaluation} 
and the related work and conclusion is in Sect.~\ref{sec:related}.


%
%
%\begin{figure}
%\caption{Requirements in Concurrent Program Verification}
%\label{fig:concurrent-verification-challenge}
%\end{figure}
%
%However, even with the importance of concurrent program verification and 
%a large body of recent work on shared-memory concurrency verification ~\jieung{cite},
%there are few certified programming tools for a large scale software due to the requirement of multiple challenges described in Fig.~\ref{fig:concurrent-verification-challenge}.
%
%\jieung{ need to site ESOP papers too}
%
%They first have to 
%provide a way to build the software in multiple layers
%that enable us to build a large scale program as a modular way. 
%For example, 
%operating systems can be divided into multiple parts, 
%memory management, process management, and so on.
%
%They also have to provide \jieung{need different word} a methodology to 
%represent the behavior of other components in the concurrent environment. 
%For the program running on multicore environment, 
%the single instance of the program, which is a program runs on top of 
%a single CPU, has to correctly capture the 
%environmental behavior (the behavior of programs on other CPUs). 
%
%In addition to that, 
%providing the end-to-end theorem also requires us 
%to link the multiple proof instances to 
%form a single proof that is based on
%the concurrent environment itself which does not have 
%any environmental contexts at all. 
%In the example of the operating system on multicore environment,
%the end-to-end theorem 
%has to prove that 
%the program running on the single CPU is correctly refined by 
%the whole thread programs running on the multicore machine. 
%
%Previous works, CertiKOS~\jieung{need cite} and Certified Concurrent Abstraction Layer~\jieung{need cite}, 
%tackles all the above examples.  
%CCAL is a tool to build a certified concurrent layers, which provides 
%a way to build concurrent abstraction layers, 
%
%
%
%However, the paper does not handle how the linking process works with the concrete machine models. 
%It briefly mentions the high level idea of linking and the memory extension for linking framework. 
%
%Therefore, this paper aims the gap between the high level perspective of CCAL and the 
%low level details of concurrent proof linking. 
%This low level details contains two parts. 
%First, it requires us to define and build multiple intermediate languages to connect
%the x86 multicoro machine model with the LAsm, which is the machine model for one single CPU. 
%In addition to that, 
%the framework also needs to show the refinement 
%between layers on those intermediate machine models to formally link
%all those proofs together. 
%CCAL also briefly provide the idea of how they implement the practical machine models that can be used with CompCertX.
%However, only providing few details does not provide 
%the  useful information to show how it works with the actual running large scale software.
%Thus, our paper tackles the issues that CCAL overlooked in the paper 
%by providing the formal rules and proofs.
%The key contribution of this paper is as follows: 
%
%\begin{itemize}
%\item We provide the detailed intermediate language semantics for multicore machine model based on CCAL, 
%and instantiate all those intermediate language semantics and refinement proofs 
%to link them with CompCertX with environmental context 
%\item We provide the intermediate machine models to build single threaded machine model from a single CPU machine model. 
%Based on the machine models, we provide the linking theorem in between 
%two abstraction layers, which contains different semantics for software schedulers. 
%\end{itemize}
%
%The structure of remaining paper is as follows:
%Section~\ref{sec:overview} shows a brief high level idea of CCAL as well as how our linking works. Section~\ref{sec:multicore} shows the details of multicore linking,
%and Sect.~\ref{sec:multithreaded} shows the implementation of our intermediate machine models for our multithreaded environment.
%Section~\ref{sec:multithreaded-linking-impl} shows how are framework 
%can be fitted into the actual concurrent kernel implementations.
%Evaluations about our implementation can be found in Sect.~\ref{sec:evaluation} 
%and the related work and conclusion is in Sect.~\ref{sec:related}.
%
%
%
%\ignore{
%Despite the importance of concurrent layers and a large body of recent work on 
%shared-memory concurrency verification, 
%
%
%there are no certified programming tools that can specify, compose, and compile concurrent layers to form a whole system [6]. Formal reasoning across multiple concurrent layers is challenging because different layers often exhibit different interleaving semantics and have a different set of observable events. For example, the spinlock module in Fig. 1 assumes a multicore model with an overlapped execution of instruction streams from different CPUs. This model differs significantly from the multithreading model for building high-level synchro- nization libraries: each thread will block instead of spinning if a queuing lock or a CV event is not available; and it must count on other threads to wake it up to ensure liveness.
%
%
%
%
%many of these abstraction layers also become concurrent in nature. Their interfaces not only hide the concrete data representations and algorithmic de- tails, but also create an illusion of atomicity for all of their methods: each method call is viewed as if it completes in a single step, even though its implementation contains com- plex interleavings with operations done by other threads. Herlihy et al. [19, 20] advocated using layers of these atomic objects to construct large-scale concurrent software systems.
%
%
%The importance of software systems' accuracy is growing rapidly these days. 
%In addition to that, 
%the concurrent environment, including multicore and device drivers, are ubiquitous in modern periods. 
%Therefore, 
%the verification methodology for concurrent programs is critical now. 
%
%In this sense, several previous works propose
%proof logics and tools for that purpose \jieung{need cite}.
%
%However, few of them are working on the linking multiple instances of 
%verified concurrent programs with concrete machine models that can be run 
%on the bare machines. 
%
%One tool, Certified Concurrent Abstraction Layers, 
%provides the tool that can be used for building a practical concurrent programs 
%such as a small operating system or distributed system. 
%It also provides the tool to link the 
%}