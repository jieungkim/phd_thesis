\section{Multicore Linking Machines}
\label{sec:multicore-linking-machine}



\subsection{Hardware Variables, Abstract Syntax and Semantics, and Key Properties}
\label{subsec:hardware-variables-and-its-key-properties}


\noindent\fbox{abstract hardware setting, abstract command definitions:}

$
\begin{array}{lllr}
\privatestate &:& \toptype & \mbox{(private state)}\\
\sharedpiece &:& \toptype  & \mbox{(shared state: }\forall (s_1 \ s_2: \sharedpiece), \set{s_1 = s_2} + \set{s_1 \neq s_2}\mbox{)} \\
\atomicevent &:& \toptype & \mbox{(atomic event: }\forall (e_1 \ e_2: \atomicevent), \set{e_1 = e_2} + \set{e_1 \neq e_2}\mbox{)} \\
\atomiceventidentkwd & : & \atomicevent \rightarrow \primitiveid  & \mbox{(getting identifier of an atomic event)} \\
\coreset & : & \set{\ztype} & \mbox{(set of cores - full core set for the multicore machine)}\\
\schedid & : & \ztype & \mbox{(logical hardware scheduler CPU ID: } \schedid \notin \coreset\mbox{)}\\
\end{array}
$

 $
\begin{array}{lll}
\command &:=& \privatecmdkwd ~\vert~ \atomiccmdkwd\langle id : \ztype, e:\primitiveid\rangle\\
&& \vert~ \acqsharedcmdkwd\langle id : \ztype\rangle~\vert~\relsharedcmdkwd\langle id : \ztype\rangle\\
\mcevent &:=& \yieldevkwd\langle from : \ztype\rangle~\vert~ \yieldbackevkwd\langle to : \ztype\rangle~\vert~ \acqevkwd\langle from : \ztype, id : \ztype\rangle\\
&& \vert~\relevkwd\langle from :\ztype, id : \ztype, d:\sharedpiece\rangle\\
&&\vert~\atomicevkwd\langle from : \ztype, id : \ztype, e:\atomicevent\rangle\\
\mclog & := & \listconstructorkwd\ \mcevent\\
\mcoracle{S : \set{\ztype}}{log : \toptype}{ret: \toptype} & : &  \ztype \rightarrow log \rightarrow ret \\
\ogetkwd_{[S: \set{\ztype}, log : \toptype, ret : \toptype]} & : &   log \rightarrow \mcoracle{S}{log}{ret} \rightarrow ret \\

\end{array}
$


\noindent\fbox{abstract hardware semantics:}

$
\begin{array}{llll}
\programcounterkwd & : &  \privatestate \rightarrow \command \rightarrow \mcprop\\
\privatestepkwd & : & \ztype \rightarrow \privatestate \rightarrow \privatestate \rightarrow \mcprop \\
\getsharedstepkwd & : & \privatestate \rightarrow \sharedpiece \rightarrow \privatestate \rightarrow  \rightarrow \mcprop \\ 
\setsharedstepkwd & :  & \privatestate \rightarrow \optioncmd{\privatestate} \rightarrow \mclog \rightarrow \privatestate \rightarrow \atomicevent \rightarrow \mcprop\\
\atomicstepkwd & : &  \ztype \rightarrow \ztype \rightarrow \privatestate \rightarrow \mclog \rightarrow \privatestate \rightarrow \atomicevent \rightarrow \mcprop  \\
\end{array}
$


\noindent\fbox{properties of abstract hardware semantics:}

\begin{tabular}{l}
$
   \loggetatomkwd(l : \mclog) (eid : \primitiveid) : \mclog :=$\\
$    \left\{\begin{array}{lr}
        \nulllist & \text{for } l = \nulllist \\
       {\listcons{ev}{l'}} & \text{for } l = \listcons{ev}{l'} \wedge \loggetatom{l'}{id}{o}  \wedge eid = eid'\\
                    &   \wedge (ev = \atomicev{\_}{eid'}{\_} \vee ev = \acqev{\_}{eid'}   \vee ev = \acqev{\_}{eid'})  \\
      l' & \text{for } l = \listcons{ev}{l'} \wedge \loggetatom{l'}{id}{o}  \wedge eid = eid'\\
                   & \wedge ((ev = \atomicev{\_ }{eid'}{\_} \vee ev = \acqev{\_}{eid'} \\
                   &  \vee ev = \acqev{\_}{eid'} \wedge eid \neq eid') \vee ev = \_) \\     
        \end{array} \right.
$\\
\end{tabular}

\begin{mathpar}
\inferrule[PC Determ]
{\programcounter{ps}{c_1} \\
\programcounter{ps}{c_2}}{c_1 = c_2}

\inferrule[Private Step Determ]
{\privatestep{n}{ps}{ps_1} \\ 
\privatestep{n}{ps}{ps_2}}{ps_1 = ps_2}

\inferrule[Get Shared Determ]
{\getsharedstep{ps}{sp_1}{ps_1}\\
\getsharedstep{ps}{sp_2}{ps_2}}{sp_1 = ps_2 \wedge ps_1 = ps_2}

\inferrule[Set Shared Determ]
{\setsharedstep{ps}{sp}{ps_1} \\ 
\setsharedstep{ps}{sp}{ps_2}}{ps_1 = ps_2}

\inferrule[Atomic Determ]
{\atomicstep{curid}{id}{ps}{l}{ps_1}{ev_1}\\
\atomicstep{curid}{id}{ps}{l}{ps_2}{ev_2}}{ps_1 = ps_2 \wedge ev_1 = ev_2}

\inferrule[Atomic Valid]
{\atomicstep{i}{eid}{ps}{l}{ps'}{e}\\
\loggetatom{l}{eid}{l''} \\ 
\loggetatom{l'}{eid}{l''}}
{\atomicstep{i}{eid}{ps}{l'}{ps'}{e}}

\end{mathpar}




\subsection{Introduce Multicore Machine}
\label{subsec:multicoremachine}

\noindent\fbox{local view:}

$
\begin{array}{llll}
\ownstatekwd & := & \ofreekwd\langle s : \optioncmd~\sharedpiece\rangle~\vert~\ownkwd\langle i : \ztype\rangle \\
\localviewkwd & := & \localviewconkwd :~\privatestate \rightarrow \mclog \rightarrow \localviewkwd \\
\end{array}
$

\noindent\fbox{calculate owner:}

\begin{tabular}{l}
$
   \calownerkwd(l : \mclog) (i : \primitiveid) : \ownstatekwd :=$\\
   $ \left\{\begin{array}{lr}
        \nulllist & \text{for } l = \nulllist \\
       \ownstate{from} & \text{for } l = \listcons{ev}{l'} \wedge \calowner{l'}{id}{o} \\
                    &\wedge e = \acqev{from}{id'} \wedge id = id' \wedge o =  \ownstate{i}  \\
       \ofreestate{\optionsome \ d} & \text{for } l = \listcons{ev}{l'} \wedge \calowner{l'}{id}{o} \\
                    &\wedge e = \relev{from}{id'}{d}  \wedge id = id' \wedge o = \ownstate{i} \wedge  i = from    \\
       o  & \text{for }  l = \listcons{ev}{l'} \wedge \calowner{l'}{id}{o} \wedge \text{otherwise} \\
        \end{array} \right.
$ \\
\end{tabular}

\noindent\fbox{hardware local step: $\ztype \rightarrow \localviewkwd \rightarrow \localview \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[acqrule]
{ \programcounter{ps}{\acqsharedcmd{id}}\\
\calowner{l}{id}{\ofreestate{d}}\\
\setsharedstep{ps}{d}{ps'}}
{ \hardwarelocalstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listcons{\acqev{curid}{id}}{\nulllist})})}}


\inferrule[relrule]
{  \programcounter{ps}{\relsharedcmd{id}}\\
\calowner{l}{id}{\ownstate{curid}}\\
\getsharedstep{ps}{d}{ps'}}
{ \hardwarelocalstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listcons{\relev{curid}{id}{d}}{\nulllist})})}}


\inferrule[private]
{  \programcounter{ps}{\privatecmdkwd}\\
\privatestep{curid}{ps}{ps'}}
{ \hardwarelocalstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{l})} }

\inferrule[atomic]
{  \programcounter{ps}{\atomiccmd{id}{\atomiceventident{e}}}\\
\atomicstep{curid}{id}{ps}{l}{ps'}{e}}
{ \hardwarelocalstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listcons{\atomicev{curid}{id}{e}}{\nulllist}}))} }

\end{mathpar}

\noindent\fbox{hstate:} 

$
\begin{array}{lll}
%\hstatekwd& := & \hstateconkwd :~ \ztype \rightarrow \set{i \rightarrow \privatestate~\vert~ i \in \coreset} \rightarrow \mclog \rightarrow \hstatekwd\\
\privatestatepool{S : \set{\ztype}} & := &  \ztype \rightharpoonup \privatestate \\
& & \hfill  (\forall i . i \in S \rightarrow \exists . (ps : \privatestate) (i, ps) \in \privatestatepool{S}) \wedge   (\forall j . j \notin S  \rightarrow (j, \_) \in \privatestatepool{S}) \\

\hstatekwd& := & \hstateconkwd :~ \ztype \rightarrow \privatestatepool{\coreset} \rightarrow \mclog \rightarrow \hstatekwd\\
\end{array}
$

\noindent\fbox{getter and setter function:} 

\begin{tabular}{l}
$
   \getpstkwd_{[ltyp: \toptype]} (lsp : \ztype \rightharpoonup ltyp) (curid :\ztype) := \left\{\begin{array}{lr}
      \optionsome\ ps & \text{for } (curid, ps) \in lsp \\
      \optionnone & \text{for } (curid, \_) \notin lsp \\
        \end{array} \right.
$\\
$
   \setpstkwd_{[ltyp: \toptype]} (curid :\ztype) (ps : ltyp) (lsp : \ztype \rightharpoonup \privatestate) := (lsp - \set{(curid, \_)})  \cup \set{(curid, ps)}
$\\
\end{tabular}

\noindent\fbox{hardware step: $(start: \ztype) : \hstatekwd \rightarrow \cctracekwd \rightarrow \hstatekwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule
{ l_0 = \listcons{\yieldbackev{curid'}}{\listcons{\yieldev{curid}}{l}} \\
\getpstsome{\privatestate}{lsp}{curid'}{ps}\\
curid \in \coreset \\
\hardwarelocalstep{curid'}{(\localview{ps}{l0})}{(\localview{ps'}{l'})}\\
\setpst{\privatestate}{curid'}{ps'}{lsp}{lsp'} }
{ \hardwarestep{start}{(\hstate{curid}{lsp}{l})}{\ccemptytrace}{(\hstate{curid'}{lsp'}{(\listapp{l'}{ l_0})}))}}
\end{mathpar}

\subsection{Introduce Hardware Oracle}
\label{subsec:hworacle}

\noindent\fbox{state: }

$
\begin{array}{lll}
\localstatekwd &:=& \localstateconkwd : \privatestate \rightarrow \booltype \rightarrow \localstatekwd\\
\localstatepool{S : \set{\ztype}} & := &  \ztype \rightharpoonup \localstatekwd\\
& & \hfill  (\forall i . i \in S \rightarrow \exists . (ps : \localstatekwd) (i, ps) \in \privatestatepool{S}) \wedge   (\forall j . j \notin S  \rightarrow (j, \_) \in \localstatepool{S}) \\

%\mcstatekwd & := & \mcstateconkwd :~ \ztype \rightarrow \set{i \mapsto \localstatekwd~\vert~ i \in \coreset } \rightarrow \mclog \rightarrow \hstatekwd\\
\mcstatekwd & := & \mcstateconkwd :~ \ztype \rightarrow \localstatepool{\coreset} \rightarrow \mclog \rightarrow \hstatekwd\\
\end{array}
$

\noindent\fbox{oracle step: $(oracle:\mcoracle{\coreset}{\mclog}{\mcevent}) :  \mcstatekwd \rightarrow \cctracekwd \rightarrow \mcstatekwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[progress]
{ \getpstsome{\localstatekwd}{curid}{lsp}{(\localstate{ps}{\bfalse})}\\
\hardwarelocalstep{curid'}{(\localview{ps}{l})}{(\localview{ps'}{l'})}\\
\setpst{\localstatekwd}{curid'}{\localstate{ps'}{\btrue}}{lsp}{lsp'}}
{\oraclestep{oracle}{(\mcstate{curid}{lsp}{l})}{\ccemptytrace}{(\mcstate{curid}{lsp'}{(\listapp{l'}{l})})}}

\inferrule[yield]
{  l_0 = \listcons{\yieldbackev{curid}}{l} \\
l' = \listcons{\yieldev{curid'}}{l_0} \\
\getpstsome{\localstatekwd}{curid'}{lsp}{(\localstate{ps}{\btrue})}\\
\setpst{\localstatekwd}{curid'}{\localstate{ps}{\bfalse}}{lsp}{lsp'}\\
\oget{\coreset}{\mclog}{\mcevent}{l_0}{oracle}{{\yieldbackev{curid}}}}
{\oraclestep{oracle}{(\mcstate{curid}{lsp}{l})}{\ccemptytrace}{(\mcstate{curid}{lsp'}{l'})}}
\end{mathpar}


\subsection{Introduce Partial Machine}
\label{subsec:mc-partial}

\noindent\fbox{environmental state: }

$
\begin{array}{lll}
\localstatekwd &:=& \localstateconkwd : \privatestate \rightarrow \booltype \rightarrow \localstatekwd\\
%\envstatekwd[A : \set{\ztype}]& := & \mcstateconkwd :~ \ztype \rightarrow \set{i \mapsto \localstatekwd~\vert~ i \in A} \rightarrow \mclog \rightarrow \localstatekwd\\
\envstatekwd_{[A : \set{\ztype}]}& := & \mcstateconkwd :~ \ztype \rightarrow \localstatepool{A} \rightarrow \mclog \rightarrow \localstatekwd\\

\end{array}
$

\noindent\fbox{back id function:}

\begin{tabular}{l}
$
\backidkwd (curid : \ztype) (e : \mcevent):= \left\{\begin{array}{lr}
curid' & \text{for } e = \yieldbackev{curid'} \\
\schedid &   \text{for } e =\yieldev{\_} \\
curid & \text{Otherwise}
        \end{array} \right.
 $\\
\end{tabular}


\noindent\fbox{env step: ${}_{[A : \set{\ztype}]} (oracle:\mcoracle{A}{\mclog}{\mcevent}) :  \mcstatekwd_{[A]} \rightarrow \cctracekwd \rightarrow \mcstatekwd_{[A]} \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[progress]
{ \getpstsome{\localstatekwd}{curid}{lsp}{(\localstate{ps}{\bfalse})}\\
\hardwarelocalstep{curid'}{(\localview{ps}{l})}{(\localview{ps'}{l'})}\\
\setpst{\localstatekwd}{curid'}{\localstate{ps'}{\btrue}}{lsp}{lsp'}}
{\envstep{A}{oracle}{(\envstate{A}{curid}{lsp}{l})}{\ccemptytrace}{(\envstate{A}{curid}{lsp'}{(\listapp{l'}{l})})}}

\inferrule[yield]
{  l_0 = \listcons{\yieldbackev{curid}}{l} \\
l' = \listcons{\yieldev{curid'}}{l_0} \\
\getpstsome{\localstatekwd}{curid'}{lsp}{(\localstate{ps}{\btrue})}\\
\setpst{\localstatekwd}{curid'}{\localstate{ps}{\bfalse}}{lsp}{lsp'}\\
\oget{A}{\mclog}{\mcevent}{l_0}{oracle}{\yieldbackev{curid}}}
{\envstep{A}{oracle}{(\envstate{A}{curid}{lsp}{l})}{\ccemptytrace}{(\envstate{A}{curid}{lsp'}{l'})}}

\inferrule[skip]
{  l' = \listcons{e}{l} \\
\getpstnone{\localstatekwd}{curid'}{lsp}\\
\oget{A}{\mclog}{\mcevent}{l}{oracle}{e} \\
\backid{curid}{e}{curid'}}
{\envstep{A}{oracle}{(\envstate{A}{curid}{lsp}{l})}{\ccemptytrace}{(\envstate{A}{curid'}{lsp}{l'})}}
\end{mathpar}

\subsection{Introduce Single Core Machine}
\label{subsec:mc-single}

\noindent\fbox{single state:}

$
\begin{array}{lll}
\singlestatekwd & := & \singlestateconkwd :~ \ztype \rightarrow \localstate \rightarrow \mclog \rightarrow \singlestatekwd\\

\end{array}
$

\noindent\fbox{single step: ${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) :  \singlestatekwd \rightarrow \cctracekwd \rightarrow \singlestatekwd \rightarrow \mcprop$}

\begin{mathpar}

\inferrule[progress]
{ ls = \localstate{ps}{\bfalse} \\
ls' = \localstate{ps'}{\btrue} \\
\hardwarelocalstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{l'})}}
{\singlestep{curid}{oracle}{(\singlestate{curid}{ls}{l})}{\ccemptytrace}{(\singlestate{curid}{ls'}{(\listapp{l'}{l})})}}

\inferrule[yield]
{  l_0 = \listcons{\yieldbackev{curid}}{l} \\
l' = \listcons{\yieldev{curid'}}{l_0} \\
ls = \localstate{ps}{\btrue} \\
ls' = \localstate{ps'}{\btrue} \\
\oget{\set{curid}}{\mclog}{\mcevent}{l_0}{oracle}{\yieldbackev{curid'}}}
{\singlestep{curid}{oracle}{(\singlestate{curid}{ls}{l})}{\ccemptytrace}{(\singlestate{curid'}{ls'}{l'})}}

\inferrule[skip]
{  l' = \listcons{e}{l} \\
curid' \neq curid\\
\oget{\set{curid}}{\mclog}{\mcevent}{l}{oracle}{e} \\
\backid{curid'}{e}{curid_0}}
{\singlestep{curid}{oracle}{(\singlestate{curid'}{ls}{l})}{\ccemptytrace}{(\singlestate{curid_0}{ls}{l'})}}

\end{mathpar}

\noindent\fbox{fairness:}

$
\begin{array}{llll}
\timebound & : & \nattype &\mbox{(time bound for wating scheduling)} \\
\end{array}
$

\noindent\fbox{Yield Back Function:}

\begin{tabular}{l}
$ \yieldbackfunckwd_{(n : \nattype)} (curid : \ztype) (l \ res : \mclog) (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) : \mclog := $\\
$ \left\{\begin{array}{lr}
       \optionnone & \text{for } n  = O \\
       
       \optionsome\ res' & \text{for } n = S\ n' \wedge \oget{\set{curid}}{\mclog}{\mcevent}{\listapp{res}{l}}{oracle}{e}\\ 
                  & \wedge res' := \listcons{e}{res} \wedge \yieldbackfunc{n'}{curid}{l}{res'}{oracle}{r} \\
                  & \wedge e = \yieldbackev{curid'} \wedge curid = curid' \\
        r & \text{for }n = S\ n' \wedge \oget{\set{curid}}{\mclog}{\mcevent}{\listapp{res}{l}}{oracle}{e}\\ 
                  & \wedge res' := \listcons{e}{res} \wedge \yieldbackfunc{n'}{curid}{l}{res'}{oracle}{r} \\
                  & (\wedge e \neq \yieldbackev{curid'} \vee (\wedge e = \yieldbackev{curid'} \wedge curid \neq curid')) \\
          \optionnone  & \text{for }n = S\ n' \wedge \ogetnoeq{\set{curid}}{\mclog}{\mcevent}{\listapp{res}{l}}{oracle} = r \wedge r \neq \optionsome \ e \\
        \end{array}\right .
$\\
\end{tabular}

\noindent\fbox{single big step: ${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) :  \singlestatekwd \rightarrow \cctracekwd \rightarrow \singlestatekwd \rightarrow \mcprop$}

\begin{mathpar}

\inferrule[progress]
{ ls = \localstate{ps}{\bfalse} \\
ls' = \localstate{ps'}{\btrue} \\\\
\hardwarelocalstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{l'})}}
{\singlebigstep{curid}{oracle}{(\singlestate{curid}{ls}{l})}{\ccemptytrace}{(\singlestate{curid}{ls'}{(\listapp{l'}{l})})}}



\inferrule[yield]
{ l_0 = \listcons{\yieldbackev{curid}}{l} \\
 ls = \localstate{ps}{\btrue} \\
ls' = \localstate{ps}{\bfalse} \\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l'}}
{\singlebigstep{curid}{oracle}{(\singlestate{curid}{ls}{l})}{\ccemptytrace}{(\singlestate{curid'}{ls'}{l'})}}

\end{mathpar}

\noindent\fbox{rstate:}
$
\begin{array}{lll}
\rstatekwd & := & \rstateconkwd : \privatestate \rightarrow \mclog \rightarrow \rstatekwd\\
\end{array}
$

\fbox{single big2 step:
$
{}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) :  \rstatekwd \rightarrow \cctracekwd \rightarrow \rstatekwd \rightarrow \mcprop
$}

\begin{mathpar}

\inferrule[progress]
{  l_0 = \listcons{\yieldbackev{curid}}{l} \\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l_1} \\
\hardwarelocalstep{curid}{(\localview{ps}{(\listapp{l_1}{l_0})})}{(\localview{ps'}{l'})}}
{\singlebigtwostep{curid}{oracle}{(\rstate{ps}{l})}{\ccemptytrace}{(\rstate{ps'}{(\listapp{l'}{\listapp{l_1}{l_0}})})}}

\end{mathpar}

\noindent\fbox{single local view:}
$
\begin{array}{lll}
\singlelocalviewkwd & := & \singlelocalviewconskwd : \privatestate \rightarrow \singlelocalviewkwd\\
\end{array}
$

\noindent\fbox{single local step: $\ztype \rightarrow \singlelocalviewkwd \rightarrow \singlelocalviewkwd \rightarrow \mcprop$}

\begin{mathpar}[private]
\inferrule
{\programcounter{ps}{\privatecmdkwd}\\
\privatestep{curid}{ps}{ps'}}
{ \singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
\end{mathpar}

\fbox{single log step: $\ztype \rightarrow \localviewkwd \rightarrow \localviewkwd \rightarrow \mcprop$}
\begin{mathpar}
\inferrule[acquire shared]
{\programcounter{ps}{\acqsharedcmd{id}}\\
\calowner{l}{id}{\ofreestate{d}}\\
\setsharedstep{ps}{d}{ps'}}
{ \singlelogstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listcons{\acqev{curid}{id}}{\nulllist})})}}

\inferrule[release shared]
{\programcounter{ps}{\relsharedcmd{id}}\\
\calowner{l}{id}{\ownstate{curid}}\\
\getsharedstep{ps}{d}{ps'}}
{ \singlelogstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listcons{\relev{curid}{id}{d}}{\nulllist})})}}

\inferrule[atomic]
{  \programcounter{ps}{\atomiccmd{id}{\atomiceventident{e}}}\\
\atomicstep{curid}{id}{ps}{l}{ps'}{e}}
{ \singlelogstep{curid}{(\localview{ps}{l})}{(\localview{ps'}{(\listcons{\atomicev{curid}{id}{e}}{\nulllist})})}}
\end{mathpar}


\noindent\fbox{srstate:}

$
\begin{array}{lll}
\srstatekwd & := & \srstateconkwd : \privatestate \rightarrow \mclog \rightarrow \mclog \rightarrow \srstatekwd \\
\end{array}
$

\noindent\fbox{single split step: ${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mcevent}) :  \srstatekwd \rightarrow \cctracekwd \rightarrow \srstatekwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule
{al_0 = \listcons{\yieldev{curid}}{al}\\
l_0 = \listapp{al_0}{l}\\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l_1}\\
\singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
{\singlesplitstep{curid}{oracle}{(\srstate{ps}{l}{al})}{\ccemptytrace}{(\srstate{ps'}{l}{(\listapp{l_1}{al_0})})}}

\inferrule
{l_0 = \listapp{\listcons{\yieldev{curid}}{al}}{l}\\
\yieldbackfunc{\timebound}{curid}{l_0}{\nulllist}{oracle}{l_1}\\
\singlelogstep{curid}{(\localview{ps}{(\listapp{l_1}{l_0})})}{(\localview{ps'}{l'})}}
{\singlesplitstep{curid}{oracle}{(\srstate{ps}{l}{al})}{\ccemptytrace}{(\srstate{ps'}{(\listapp{l'}{\listapp{l_1}{l_0}})}{\nulllist})}}
\end{mathpar}



\noindent\fbox{single reorder step: ${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\mclog}{\mclog}) :  \srstatekwd \rightarrow \cctracekwd \rightarrow \srstatekwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule
{\singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
{\singlereorderstep{curid}{oracle}{(\rstate{ps}{l})}{\ccemptytrace}{(\rstate{ps'}{l})}}

\inferrule
{\oget{\set{curid}}{\mclog}{\mclog}{l}{oracle}{l_0}\\
\singlelogstep{curid}{(\localview{ps}{(\listapp{l_0}{l})})}{(\localview{ps'}{l'})}}
{\singlereorderstep{curid}{oracle}{(\rstate{ps}{l})}{\ccemptytrace}{(\rstate{ps'}{(\listapp{l'}{\listapp{l_0}{l}})})}}

\end{mathpar}




\noindent\fbox{separate log and sp state:}

$
\begin{array}{lll}
\separateeventkwd & := &\separateacqevkwd\langle from : \ztype\rangle~\vert~\separaterelevkwd\langle from : \ztype, d: \sharedpiece\rangle\\
   & & \vert~\separateatomicevkwd\langle from:\ztype, e:\atomicevent\rangle\\
\separatelogtypekwd & := & \listconstructorkwd\ \separateeventkwd\\
\separatelogkwd & := &   \ztype \rightarrow \separatelogtypekwd \\
\separateoraclelogtypekwd & := & \ztype \times \separatelogtypekwd \times \primitiveid \\
\spstatekwd & := & \spstateconkwd : \privatestate \rightarrow \separatelogkwd \rightarrow spstatekwd \\

\end{array}
$

\noindent\fbox{separate log step: $ \ztype \rightarrow \ztype \rightarrow \localviewkwd \rightarrow \privatestate \rightarrow \separateeventkwd \rightarrow \mcprop$}

\begin{mathpar}
\inferrule[acquire]
{\programcounter{ps}{\acqsharedcmd{id}}\\
\calowner{l}{id}{\ofreestate{d}}\\
\setsharedstep{ps}{d}{ps'}}
{\separatelogstep{curid}{id}{(\localview{ps}{l})}{ps'}{({\separateacqev{curid}})}}

\inferrule[release]
{\programcounter{ps}{\relsharedcmd{id}}\\
\calowner{l}{id}{\ownstate{curid}}\\
\setsharedstep{ps}{d}{ps'}}
{\separatelogstep{curid}{id}{(\localview{ps}{l})}{ps'}{({\separaterelev{curid}{d}})}}

\inferrule[atomic]
{  \programcounter{ps}{\atomiccmd{id}{\atomiceventident{e}}}\\
\atomicstep{curid}{id}{ps}{l}{ps'}{e}}
{\separatelogstep{curid}{id}{(\localview{ps}{l})}{ps'}{({\separateatomicev{curid}{e}})}}
\end{mathpar}


\noindent\fbox{auxiliary functions for the differences of the logs:}

\begin{tabular}{l}
$
   \separateeventtwoeventkwd(ev : \separateeventkwd) (id : \ztype) 
      :=  \left\{\begin{array}{lr}
        \acqev{from}{id} & \text{for } \separateacqev{from}\\
        \relev{from}{id}{d} & \text{for } \separaterelev{from}{d}\\
        \atomicev{from}{id}{e} & \text{for } \separateatomicev{from}{e} \\
        \end{array} \right.
$\\
$
   \separatelogtwologkwd(log : \separatelogtypekwd) (id : \ztype) 
      :=  \left\{\begin{array}{lr}
        \nulllist & \text{for } log = \nulllist \\
        \listcons{e_{sp}}{l_{sp}} & \text{for }  log = \listcons{e}{l} \\
        & \wedge \separateeventtwoevent{e}{id}{e_{sp}}\\
        & \wedge \separatelogtwolog{l}{id}{l_{sp}}\\
        \end{array} \right.
$\\
$
\separateeventtwoidkwd (ev : \separateeventkwd) : \primitiveid :=
 \left\{\begin{array}{lr}
         \acqsharedid& \text{for } \separateacqev{\_}\\
        \relsharedid & \text{for } \separaterelev{\_}{\_}\\
        \atomiceventident{e} & \text{for } \separateatomicev{\_}{e} \\
 \end{array} \right.
$\\
\end{tabular}

$
\begin{array}{lll}
  \getseplogkwd (id :\ztype)(spp : \separatelogkwd)  &:= & slog \hfill{\text{for } (id, slog) \in spp}\\
   \setseplogkwd (id :\ztype) (slog : \separatelogtypekwd) (spp: \separatelogkwd) &:= &(spp - \set{(id, \_)})  \cup \set{(id, slog)}\\
\end{array}
$

\noindent\fbox{single separate step:
${}_{[curid : \ztype]} (oracle : \mcoracle{\set{curid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}) :  \spstatekwd \rightarrow \cctracekwd \rightarrow \spstatekwd \rightarrow \mcprop$
}

\begin{mathpar}
\inferrule[local]
{\singlelocalstep{curid}{(\singlelocalview{ps})}{(\singlelocalview{ps'})}}
{\singleseparatestep{curid}{oracle}{(\spstate{ps}{gl})}{\ccemptytrace}{(\spstate{ps'}{gl})}}

\inferrule[log]
{
\getseparatelog{id}{gl}{l}\\
\oget{\set{curid}}{\separateoraclelogtypekwd}{\separatelogtypekwd}{(id, l, \separateeventtwoidnoeq{e}}{oracle}{l_0} \\
\separatelogtwolog{(\listapp{l_0}{l}}{id}{sl}\\
\separatelogstep{curid}{id}{(\localview{ps}{sl})}{ps'}{e}
\setseplogkwd{id}{(\listapp{\listcons{e}{l_0}}{l})}{gl}{gl'}
}
{\singleseparatestep{curid}{oracle}{(\spstate{ps}{gl})}{\ccemptytrace}{(\spstate{ps'}{gl'})}}

\end{mathpar}
