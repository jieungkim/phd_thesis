\section{Syntax, Semantics for CompCertX and CCAL}

Definitions in here is not the full definition of \compcertx \ (or \compcertkwd). 
They are the minimum definitions that may be required for us to understand the following sections. 


\subsection{Key Definitions for LAsm}
\label{subsec:key-def-for-lasm}

\newcommand{\listlengthkwd}{{\mathrm{len_{lst}}}}

\newcommand{\listlengthnoeq}[1]{{\listlengthkwd({#1})}}
\newcommand{\listlength}[2]{{\listlengthnoeq{#1} = {#2}}}


\newcommand{\ccbyte}{{\mathrm{\texttt{byte}}}}
\newcommand{\ccbytes}{{\listconstructor{\ccbyte}}}
\newcommand{\ccmem}{{\mathrm{\texttt{mem}}}}
\newcommand{\ccprivatemem}{{\ccmem}_{\mathrm{\texttt{p}}}}
\newcommand{\ccsharedmem}{{\ccmem}_{\mathrm{\texttt{s}}}}
%
%\newcommand{\ccprivatememorycpuid}[1]{{\ccmemory}_{\mathrm{\texttt{cpu}}{#1}}}
%


\newcommand{\ccval}{{\mathrm{\texttt{val}}}}
\newcommand{\ccvalintkwd}[1]{{\mathrm{\texttt{Vint}~{#1}}}}
\newcommand{\ccintval}{{\mathrm{\texttt{val}}_{\mathrm{\texttt{int}}}}}
\newcommand{\ccvalptrkwd}[2]{{\mathrm{\texttt{Vptr}~{#1}~{#2}}}}

\newcommand{\ccvundef}{{\mathrm{\texttt{Vundef}}}}
\newcommand{\ccvint}[1]{{\mathrm{\texttt{Vint}}~{#1}}}
\newcommand{\cpuident}{{\mathrm{ID}_\mathrm{cpu}}}


\newcommand{\ccregisterpc}{{\mathrm{\texttt{PC}}}}
\newcommand{\ccregisterebx}{{\mathrm{\texttt{EBX}}}}
\newcommand{\ccregistereax}{{\mathrm{\texttt{EAX}}}}
\newcommand{\ccregister}{{\mathrm{\texttt{reg}}}}

\newcommand{\ccregisterset}{{\rho}}

\newcommand{\absstatekwd}{{\mathrm{\texttt{a}}}}
\newcommand{\ccprivateabsstate}{{\absstatekwd_{\mathrm{\texttt{p}}}}}
\newcommand{\ccsharedabsstate}{{\absstatekwd_{\mathrm{\texttt{s}}}}}
%\newcommand{\ccprivateabsstatecpuid}[1]{{\absstate_{\mathrm{\texttt{cpu}}{#1}}}}
\newcommand{\ccmemloc}{{\mathrm{\texttt{loc}}}}
\newcommand{\ccmemvallength}{{\mathrm{\texttt{vlen}}}}


\newcommand{\cpueventkwd}{{\mathrm{\texttt{ev}}}_{\mathrm{\texttt{CPU}}}}
\newcommand{\cpulogkwd}{{\mathrm{\texttt{log}}_{\mathrm{\texttt{CPU}}}}}


\newcommand{\replayfunckwd}{{\mathbb{R}_\mathrm{cpu}}}
\newcommand{\replayfuncnoeq}[1]{{\replayfunckwd({#1})}}
\newcommand{\replayfunc}[2]{{\replayfuncnoeq{#1} = {#2}}}

\newcommand{\cpuasminst}{{\mathrm{\texttt{x86instr}}}}
\newcommand{\cpuasmfunc}{{\mathrm{\texttt{Func}_{x86}}}}
\newcommand{\cpuasmmodule}{{\mathrm{\texttt{M}_{x86}}}}
\newcommand{\cpuprivatestate}{{\mathrm{\texttt{pst}}_{\mathrm{\texttt{CPU}}}}}
\newcommand{\cpuprivatestatecon}[3]{{({#1}, {#2}, {#3})}}

\newcommand{\cpuprivatestatepool}{{\mathrm{P}_{\cpuprivatestate}}}
\newcommand{\cpustatekwd}{{\mathrm{\texttt{st}}_{\mathrm{\texttt{CPU}}}}}
\newcommand{\cpustatecon}[4]{{({#1}, {#2}, {#3}, {#4})}}

\newcommand{\primitivespeckwd}{\sigma_{p}}

\newcommand{\cpulayerprimdef}{{\mathcal{L}}}

\newcommand{\cpulayerinvariantkwd}{{\mathcal{I}nv}}

\newcommand{\cpurely}[1]{{\mathcal{R}_{\mathrm{\texttt{cpu}[{#1}]}}}}
\newcommand{\cpuguarantee}[1]{{\mathcal{G}_{\mathrm{\texttt{cpu}[{#1}]}}}}

\newcommand{\cpuenvcontextkwd}{{\varepsilon_{\mathrm{\texttt{cpu}}}}}
\newcommand{\cpuenvcontext}[1]{{\varepsilon_{\mathrm{\texttt{cpu}}}({#1})}}

\newcommand{\cpulayerdefkwd}[1]{{\mathrm{\texttt{L}}[{#1}]}}
\newcommand{\cpulayerdefcon}[4]{{({#1}, {#2}, {#3}, {#4})}}

\newcommand{\cpuglobalenv}{{\mathrm{\texttt{Genv}}}}


$
\begin{array}{llll}
%\listlengthkwd & : & \listconstructor{\toptype} \rightarrow \nattype & \mbox{(function for getting the lenght of list)}\\

\ccbyte & := & \set{ v~\vert~ v \in \nattype \wedge v < 2^8} & \mbox{(byte)}\\
\ccintval & := & \set{v ~\vert~ v \in  \ccbytes \wedge \listlength{v}{4}} \\

\ccval & := & \ccvundef~\vert~ \ccvalintkwd{(vi : \ccintval)} ~\vert~\ccvalptrkwd{(bid : \nattype)}{(ofs : \nattype)} & \mbox{(definition of value)} ~\vert~  \\
\cctracekwd &:=& \ccemptytrace~\vert~ \cdots &{\mbox{(\compcertkwd\ trace)}}\\
\primitiveid, \cpuident & : & \nattype & \mbox{(Identifier for pritimives and CPU respectively)} \\
\ccmemloc, \ccmemvallength   & := & \nattype & \mbox{(location  and the length of the value in memory, respectively)} \\
\ccmem & := & \ccmemloc \rightarrow \ccmemvallength \rightarrow \ccval & \mbox{(memory)} \\
\ccprivatemem, \ccsharedmem & : & \ccmem & \mbox{(private memory and  shared memory respectively)}\\
\ccregister & := & \ccregisterpc~\vert~\ccregistereax~\vert~\ccregisterebx~\vert~\ldots & \mbox{(registers)} \\
\ccregisterset & := & \ccregister \rightarrow \ccval & \mbox{(register set definition)}\\
\ccprivateabsstate, \ccsharedabsstate & : & \toptype & \mbox{(private and shared abstract states respectively)} \\
\cpueventkwd & := & \toptype & \mbox{(event for the layer associated with the \textit{n}th layer)}\\
\cpulogkwd & := &   \listconstructor{\cpueventkwd} & \mbox{(log for the layer associated with the \textit{i}th layer)} \\
\replayfunckwd & : & \cpulogkwd \rightarrow \ccsharedabsstate &\mbox{(replay function)} \\
\cpuprivatestate & := & \cpuprivatestatecon{\ccregisterset}{\ccprivatemem}{\ccprivateabsstate} & \mbox{(Private state for each core)}\\
%\cpuprivatestatepool & : & \cpuident \rightharpoonup \cpuprivatestate & \mbox{(Private state Pool)}\\
\cpustatekwd & := & \cpustatecon{\cpuident}{\cpuprivatestate}{\ccsharedmem}{\cpulogkwd} & \mbox{(State Definition)}\\
\cpuasminst & : & \toptype & \mbox{(assembly instructions including function calls and so on)}\\
\cpuasmfunc & : & \listconstructor{\cpuasminst} & \mbox{(Assembly function is a list of instructions)}\\
\cpuasmmodule & : & \primitiveid \rightharpoonup \cpuasmfunc & \mbox{(module is a partial set)}\\

\primitivespeckwd & : & \cpustatekwd \rightarrow \listconstructor{\ccval} \rightarrow \cpustatekwd \rightarrow \ccval \rightarrow \mcprop & \mbox{(specification of primtiives)}\\
\cpulayerprimdef & : & \primitiveid \rightharpoonup \primitivespeckwd & \mbox{(collection of functions)}\\
\cpulayerinvariantkwd & : & \cpustatekwd \rightarrow \mcprop & \mbox{(invariant)} \\

\cpulayerinvariantkwd & : & \cpustatekwd \rightarrow \mcprop & \mbox{(invariant)} \\
\cpurely{(cid : \cpuident)} & : & \cpulayerinvariantkwd & \mbox{(rely invariants)} \\
\cpuguarantee{(cid : \cpuident)} & : & \cpulayerinvariantkwd  & \mbox{(guarantee invariants)} \\
\cpuenvcontextkwd & : & \cpuident \rightarrow (\cpulogkwd \rightharpoonup \cpulogkwd) & \mbox{(environmental context for each layer)}\\
\cpulayerdefkwd{(cid : \cpuident)} & := & \cpulayerdefcon{\cpulayerprimdef}{\cpurely{cid}}{\cpuguarantee{cid}}{\cpuenvcontext{cid}}\\
\cpuglobalenv & : & \set{id~\vert~ id \in \ccmemloc \vee id \in \primitiveid} \rightarrow \mcprop & \mbox{(check validity of memory location or primitive or function id)}\\
\end{array}
$
%
%
%\noindent\fbox{property of those syntax}
%
%$
%\begin{array}{l}
%(disjoint)\\
%\end{array}
%$

\subsection{Semantic Rules for LAsm}
\label{subsec:semantics-for-lasm}

\noindent\fbox{step relation: ${}_{[(cid : \cpuident), (layer : \cpulayerdefkwd{cid})]} (genv: \cpuglobalenv) : \cpustatekwd \rightarrow \cctracekwd \rightarrow \cpustatekwd \rightarrow \mcprop$} 


\noindent\fbox{initial state:}
