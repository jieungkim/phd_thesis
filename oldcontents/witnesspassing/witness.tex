\begin{figure}
{\small
\raggedright
\textbf{Quorum definition}  \\
	\vspace{0.05in}
$
\begin{array}{llll}
\accsset & := & \set{\nodeid} & \mbox{(All voters)}\\
\voters & := & \set{\nodeid} & \mbox{(All supportive voters)}\\
\isquorums_{ldr} (ca: \accsset) (v: \voters) &:& \mathbb{B} & \mbox{(Leader election quorum)} \\
\isquorums_{op} (ca: \accsset) (v: \voters)  &:&  \mathbb{B} &  \mbox{(Commit quorum)}\\
\end{array}
$
\\
	\vspace{0.05in}
\textbf{Leader election witness}  \\
	\vspace{0.05in}
$
\begin{array}{llll}
\ldrwitness &:=&  \set{\termnum \mapsto list\ (\dstate, \voters, \accsset, \isquorums_{ldr})} & \\
\end{array}
$
\\
	\vspace{0.05in}
\textbf{Commit operation witness}  \\
	\vspace{0.05in}
$
\begin{array}{llll}
\opwitness &:=& \set{\termnum \mapsto list\ (\dstate, \updatefunc, \voters,
	\accsset, \isquorums_{op})}& 
\end{array}
$
\\
} % end of \small
\vspace{-1em}
\caption{Witness Definiton}
\label{fig:witness-definition}
\vspace{-1.5em}
\end{figure}

\vspace{-0.5em}

\section{Witness Passing}
\label{sec:witness-passing}

The generic specification provides a template for leader-based distributed
system and hides unnecessary details from users. It also provides a guideline 
for proving functional correctness when connecting the specification with a 
low-level implementation written in C or Assembly.
It, however, needs further items to prove safety properties of distributed 
systems efficiently.  
\sysname{} models the state of the distributed system as a network history, 
which we can refer the status of other nodes.
The network history, however, contains unnecessary events in it due to
the network failure assumptions, packet reordering or duplication, that  
distributed systems consider. Therefore, having a more precise, 
locally built, and globally consistent data structure to aid the safety proof 
of the distributed system is desired. Hence, we propose the witness.   

The witness is a logical data structure that constantly grows to contain a global
history of the distributed system state changes that are meaningful to the
latest state. A witness grows by being passed between nodes through the network.
Information in a witness is never replaced or deleted, but a witness can
be discarded if the operation it is associated with fails.

\ignore{
The witness can be built in a modular way by extending generic specifications, 
especially the log replay function and the network message definition. 
The witness can be used regardless of network failure assumptions because it is
simply an extra ghost information that is attached to messages to help 
verify crucial properties of distributed systems.
}

While \sysname{}'s template functions mainly use witnesses to verify
linearizability of state changes and the leader election by composing the 
witnesses for commit operations and leaders, the underlying systems can
build their own witnesses to verify system-specific properties (e.g. immutability
of Paxos in \pref{sec:background}).

We first formally define witnesses as they are used in the template functions
and then show how we integrate them into the specifications described in \pref{sec:specs-for-leader-based-system}.

\subsection{Witness Definitions} 
\label{subsec:witness-definition}
Witnesses in \sysname{} are associated with the two template functions.
We view the leadership witness $\ldrwitness$ as a history of ownership transfers
of a distributed object and the commit witness $\opwitness$ as
a logical sequence of updates to the object. While the information added to a
witness is created by all nodes in the system, the witness construction only
happens at the requester side. Witness-related definitions are outlined in
\pref{fig:witness-definition}.

The witness for the leader election function ($\ldrwitness$) contains a map
from the term numbers ($\termnum$) to a set of witness elements.
Each element contains a list of local node state ($\dstate$), node ids
of all of the voters in the leader election ($\accsset$), node ids of the voters who voted
for the requester ($\voters$), and a function to determine the success of the
election ($\isquorums_{ldr}$), which makes a decision by checking for the existence of a
quorum. The necessary quorum size for a successful election varies
by protocol; e.g., Raft requires $F + 1$ votes out of $2F + 1$
nodes while the Lamport lock needs $N$ votes out of $N$ nodes.

The witness for the commit function ($\opwitness$) describes how the distributed
object has evolved from the initial to the latest state by keeping a
history of all intermediate values of $\sigma$ and the update function
$\updatefunc$ that is applied for each update. $\opwitness$ also contains
the other fields in $\ldrwitness$; however, the necessary quorum size for $\isquorums_{op}$
can be different than that for $\isquorums_{ldr}$. For example,
two-phase commit as described in \pref{fig:process-flow} uses
a membership service for leader election, but relies on resource managers to
commit data.

$\isquorums_{ldr}$ and $\isquorums_{op}$, which determine whether the leader 
election and operation are successful, generalize how leader-based distributed 
systems make atomic state transitions. We make the assumption that the underlying
protocol allows only one quorum that allows the state change for an operation 
that multiple nodes may try to execute concurrently. This is one of the key
requirements that a system must meet to use \sysname{}'s proof template.

The process of building a witness is modular and simple. A requester sends
requests and approvers send back acknowledgements with existing witnesses that
show how they reached their latest state.
The requester can simply construct a new witness and concatenate it with the
received witness without having to inspect it.
The new composite witness is then sent back to the approvers at the point where
the approvers' state is updated.

\subsection{Specifications with Witness} 
\label{subsec:specifications-with-witness}

\begin{figure}
{\small
\raggedright
\textbf{State definition with witness}\\
	\vspace{0.05in}
$
\begin{array}{ll}
\dstate_\witness:= (\dstate \times \ldrwitness \times \opwitness)  & \mbox{(Local state)} \\
\gstate_\witness := \set{\nodeid \mapsto \dstate_\witness} & \mbox{(Global state)}\\
\packet_\witness:= \packet~\vert~(\packet \times  \witness_{ldr} \times \witness_{op}) & \mbox{(Network event)}\\
{\networklog}_{\witness}:= \mbox{list}\ \packet_\witness & \mbox{(Network log)}\\
\replay_\witness : {\networklog}_{\witness} \rightarrow  \gstate_\witness& \mbox{(Log replay function)}\\
\end{array}
$
\\
	\vspace{0.05in}
\textbf{Witness building routine in} ${\replay}_{\witness}$  \\
	\vspace{0.05in}
$
\begin{array}{ll}

find\_ca_{op} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
find\_vtr_{op} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
find\_ca_{ldr} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
find\_vtr_{ldr} : \termnum \rightarrow \networklog \rightarrow \networklog \rightarrow  \set{\nodeid}\\
\\
\conwcons \ (nid : \nodeid)\ (rn: \termnum)\  (w_l :\witness_{ldr})\ (w_o : \witness_{op})\ (l_{pre}\ l_{rcv}: \networklog)\\ (f_{q} :  \isquorums_{op}) := \\
\ \ \ \ \mbox{\textbf{let}}\ ca := (find\_ca_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}  \\
\ \ \ \ \ \ \mbox{\textbf{match}} \ w_l[rn] \ \mbox{\textbf{with}} \\
\ \ \ \ \ \ \ \ \vert~nil \Rightarrow w_o \\
\ \ \ \ \ \ \ \  \vert~((rn', \_, \_), \_, \_, \_ )::\_  \Rightarrow w_o / \langle w_o[rn] := w_o[rn'] \rangle \\
\ \ \ \ \ \ \mbox{\textbf{end}}\\
\ \ \ \ \  \mbox{\textbf{else}} \ w_o.
\\
\ldrwcons \ (nid : \nodeid)\ (rn: \termnum)\ (w_l :\witness_{ldr})\ (w_o : \witness_{op})
(l_{pre}\ l_{rcv}: \networklog)\\  (f_{q} :  \isquorums_{ldr})\ (f_{o} :  \isquorums_{op}) := \\
 \ \ \ \ \mbox{\textbf{let}}\ ca := (find\_ca_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
 \ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{ldr} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}  \\
\ \ \ \ \ \ \mbox{\textbf{let}}\ l := l_{rcv}~\verb!++!~l_{pre} \ \mbox{\textbf{in}} \\
\ \ \ \ \ \ \mbox{\textbf{let}}\ w_l' := w_l/\langle w_l[rn]  := ((\replay(l)[nid]),f, vtr, ca, f_{q}) ::w_l[rn])  \rangle \ \mbox{\textbf{in}}\\
\ \ \ \ \ \  \mbox{\textbf{let}}\ w_o' := \conwcons\  nid\ rn\ w_l\ w_o \ l_{pre} \ l_{rcv} \ f_o \ \mbox{\textbf{in}}\  (w_l', w_o')\\
%\ \ \ \ \ \ \ \ \ \ \mbox{\textbf{match}} \ w_l[rn] \ \mbox{\textbf{with}} \\
%\ \ \ \ \ \ \ \ \ \ \vert~nil \Rightarrow  (w_l', w_o)\\
%\ \ \ \ \ \ \ \ \ \ \vert~((rn', \_, \_), \_, \_, \_ )::\_  \Rightarrow (w_l', w_o / \langle w_o[rn] := w[rn'] \rangle \\
%\ \ \ \ \ \ \ \ \ \ \mbox{\textbf{end}} \\ 
\ \ \ \ \mbox{\textbf{else}}  \ (w_l, w_o). 
\\
\opwcons (nid : \nodeid) \ (rn: \termnum)\ (f: \updatefunc)\ (w :\witness_{op})
 (l_{pre}\ l_{rcv}: \networklog)\\ (f_{q} :  \isquorums_{op}) := \\
\ \ \ \ \mbox{\textbf{let}}\ ca := (find\_ca_{op} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{let}}\ vtr := (find\_vtr_{op} \ rn \ l_{pre} \ l_{rcv})\  \mbox{\textbf{in}} \\ 
\ \ \ \ \mbox{\textbf{if}} \ f_{q} \ ca \ vtr \ \mbox{\textbf{then}}  \\
\ \ \ \ \ \  w/\langle w[rn] := ((\replay(l_{rcv}~\verb!++!~l_{pre})[nid]),f, vtr, ca, f_{q}) ::w[rn])  \rangle\\
\ \ \ \ \mbox{\textbf{else}}  \ w. \\
\end{array}
$
}% end of \small
\vspace{-1em}
\caption{Witness Construction}
\label{fig:witness-construction}
\vspace{-1em}
\end{figure}


Based on the witness definition, we extend the state definitions of
leader-based systems to utilize witnesses and discuss routines to construct
witnesses (\pref{fig:witness-construction}).

Each node's local state is extended to store leader and commit witnesses ($\dstate_\witness)$.
The definition of the global state with witnesses is also updated accordingly.
In order to pass witnesses from one node to another,
network events must also contain witnesses in addition to the usual events.
When the leader election function or the commit operation function successfully 
updates the local state of the distributed node, the associated witness should be
attached to the new state. To do so, the log replay
function should internally call a witness building routine ($\ldrwcons$ or $\opwcons$) at the end of the
leader election and the commit functions.

\pref{fig:witness-construction} shows methods for constructing witnesses.
At the end of $\ldrfunction$, $\ldrwcons$ first constructs the information about the
voters ($ca:\accsset$) and ($vtr:\voters$) and, if the requester succeeds in becoming the leader,
it attaches this evidence to $\ldrwitness$. Then $\conwcons$ is called against
the nodes that processes the commit operation to gather the witness for
$\opwitness$\footnote{Set of nodes that elect leaders and commit operations
can be different. E.g., if the system uses external membership services,
the set of nodes can be different, whereas multi-Paxos and Raft use an identical
set for both purposes.}.
$\conwcons$ copies the witnesses from the previous term into the current one.

%Up to this point it only
%touches the witness regarding leader election and then as a leader it probes the 
%it extracts the witness, which represents the current state of the system, from 
%the approvers.
%
%The witness building in the leader election does not need to know 
%all details about the distributed object manipulation.
%When the leader has been elected, however, it first needs to build the proper leader witness and 
%also needs to copy the previous witness mapped with the old term number $rn'$ to
% the new term number $rn$. 
% Copying the previous witness does not require calculating all the previous writes. 
% It, however, automatically guarantees the consistency of the distributed object manipulation 
% via leader election when the leader election and the commit operation function guarantees a 
% certain property described in the ~\ref{subsec:prove-safety-with-witness}. 

$\opwcons$ is the analogous function for $\opfunction$.
The leader starts from a witness with the complete history of the system state
that was collected using $\conwcons$ during leader election.
Upon a successful call to $\opfunction$, the leader creates a new witness by
adding a witness entry, which contains the update function $f$ that is to be used
to update the existing state.

Witnesses are stored in the local state, and are communicated over the network.
This means failed communications can
cause certain nodes to fall behind with updating their witnesses.
However, as long as the system operates without violating the failure 
assumptions, the system state eventually becomes consistent and reasoning 
about the protocol is not affected by outdated nodes.

%\begin{figure}
% \includegraphics[scale=0.05]{figs/witness_table.jpg}
%\caption{Witness Example}
%\label{fig:witness-example}
%\end{figure}


%Those witness building functions are write-only functions, 
%which does not remove any previous committed values from the data at all. 
%Figure~\ref{fig:witness-example} shows the witness building example with arbitrary leader
%based protocol. 
%In the example, 
%leader is elected when the term numbers are $1$, $3$, and $7$. 
%The example shows that building the leader election witnesses
%is isolated from the log update via commit functions. 
%The commit witness, however, needs an additional information 
%to connect the previous commit histories that are associated with 
%other term numbers. 
%In this sense, when the new leader is elected with the term number $3$, the new election 
%copies the old committed witnesses associated with $1$ to $3$ without knowing the 
%detail of the commits. 
%Similarly, the election with the term number $7$ also copies the committed 
%witness value from $3$ to the committed witness associated with $7$.
%By doing so, the committed witness value contains all valid committed history 
%in a compositional way. 


%The witness also contains few simple witnesses 
%\jieung{need to change the following ones as a formal rules}

Witnesses impose multiple invariants in them.
For example, all elements inside both leader election and commit operation witnesses 
always contain the valid voters and candidates that satisfy the quorum as follows:
\vspace{-0.2em}

\begin{theorem}[Witness Invariant]\label{thm:witness-invariant}
Assume that for a network log $l$, the resulting state of replaying the log $l$ 
	is $gst$, which can be represented as $\replay_\witness(l) = gst$. 
For all $nid$, if $gst[nid] = (\_, \_, \_, w_l, w_o)$, then $w_l$ and $w_o$ satisfy the following properties:
\begin{enumerate}
\item $\forall\ vtr\ ca\ f_q, \ (\_, vtr, ca, f_q) \in w_l \rightarrow f_q(ca, vtr) = true$
\item $\forall\ vtr\ ca\ f_q, \ (\_, vtr, ca, f_q) \in w_o \rightarrow f_q(ca, vtr) = true$
\end{enumerate}
\end{theorem}
\vspace{-0.2em}

\begin{proof}
The proof is straightforward with the witness construction definition.
\end{proof}
\vspace{-0.2em}

\begin{theorem}[Specification Refinement]\label{thm:spec-refine}
With the refinement relation $R$ between $\dstate$ and $\dstate_\witness$, 
the template functions satisfy the following properties:
1) $\ldrfunction  \sqsubseteq_{R} {\ldrfunction}_{\witness} $; 
2) $\ldrhfunction  \sqsubseteq_{R} {\ldrhfunction}_{\witness} $; 
3) $\opfunction  \sqsubseteq_{R} {\opfunction}_{\witness} $; and
4) $\ophfunction  \sqsubseteq_{R} {\ophfunction}_{\witness}$.
\end{theorem}
\vspace{-0.2em}

\begin{proof}
Proof is straightforward. 
Since both $\dstate$ and $\dstate_\witness$ contain the same fields aside from
the witnesses, the refinement relation $R$ for each field will be identity.
Thus, the simulation proof for these fields are straightforward. 
The witness can be easily constructed from the witness construction functions
in \pref{fig:witness-construction}, which do not touch fields other
than the witness. 
Hence, proving the refinement relation between the two specifications is
straightforward.
\end{proof}

Similarly, proving that providing a generic specification for distributed
systems implies providing a generic specification with witnesses for distributed
system is also straightforward.


