
\begin{figure*}
\includegraphics{figs/witnesspassing/overviewfig}
\vspace{-1em}
\caption{Leader-based distributed system process flow: the process flow can be
	expressed using template functions and system-specific functions can
	be plugged into the template. Examples show multi-Paxos, 
	Raft~\cite{raft}, two-phase commit with external membership service, 
	and Lamport's distributed lock~\cite{lamportclock}.}
\label{fig:process-flow}
\vspace{-1em}
\end{figure*}

\section{Specifications for Leader Based Systems}
\label{sec:specs-for-leader-based-system}

\sysname{} specifies leader-based distributed systems with a generic
specification and a system-specific specification. 
The generic specification defines the high-level behavior of the leader-based 
distributed system and the system-specific specification, which is encapsulated 
within the generic specification describes the low-level behaviors. 

The generic specification obviates the need for the user to write specifications
of essential safety properties of the leader-based system and instead enables them to
focus on writing the system-specific parts. The
generic and system-specific specifications are designed in a modular fashion and
can be composed to form a full specification of a leader-based distributed system.

Modeling the leader-based system requires two kinds of actors in the system:
requesters and approvers. 
Requesters seek permission to perform actions, which approvers either authorize or deny.
This separation need not be physical as in some protocols, such as Raft, one node can act
both as a requester and approver simultaneously.
The generic specification for both requesters and approvers 
works as a template for writing system-specific
specifications and for common safety property proofs.
Safety properties can be verified over the generic specification once,
and the system-specific specification, which meets the pre-defined template in
the generic specification, is automatically guaranteed to be safe. The safety
properties that \sysname{} guarantees are linearizability of state update and
soundness of leader selection.

%Proofs about those generic functions also can be combined with the
%multiple properties of protocol-specific update functions later.
%For example, with the proper properties of update functions,
%linearizabilty can be proved with the generic specification.
%Then, if the concrete definition of protocol specific functions are valid with
%the pre-defined properties,
%the linearizability proof can be automatically achieved
%for the protocol.



%later compose them with the common specification and the proof.
%
%
%it first provides a way for users to implement the safe distributed systems
%by giving the place that the users has to fill out.
%the generic function also hides the detail of the implementation.
%by doing that clients that uses those two functions can use them
%without considering the detail of their implementation, which has a benefit in terms of
%compositionality, too.


%The generic specification consists of two parts.
%The first is about the specification that leader-based distributed systems
%commonly follow.
%The other is protocol-specific parts that are encapsulated in the
%generic specification and will be concretely implemented later.
%providing the generic specification for leader-based distributed systems
%has a huge advantage in the verification.
%it first provides a way for users to implement the safe distributed systems
%by giving the place that the users has to fill out.
%
%the generic function also hides the detail of the implementation.
%by doing that clients that uses those two functions can use them
%without considering the detail of their implementation, which has a benefit in terms of
%compositionality, too.
%
%one another advantage of having them is
%providing the generic template for the safety proof of those functions.
%Proofs about those generic functions also can be combined with the
%multiple properties of protocol-specific update functions later.
%For example, with the proper properties of update functions,
%linearizabilty can be proved with the generic specification.
%Then, if the concrete definition of protocol specific functions are valid with
%the pre-defined properties,
%the linearizability proof can be automatically achieved
%for the protocol.

%Two generic functions are defined as follows:
The generic specification includes two template functions for both actors that describe the
abstract behavior of a leader-based distributed system:
\begin{itemize}[leftmargin=*]
	\item $\ldrfunction$ (the requester's spec) and  $\ldrhfunction$ (the approver's spec) specify how a leader is elected, and
	\item $\opfunction$  (the requester's spec) and $\ophfunction$ (the approver's spec)  specify how distributed states in the system are
		updated.
\end{itemize}
The operations of a leader based system can be described using these functions
as illustrated in \pref{fig:process-flow}.
We first define the definitions that are necessary to understand the
functions and then explain both functions in detail.

\subsection{State Definition}
\label{subsec:state-definition}

\begin{figure}
\begin{small}
\raggedright

	\vspace{0.05in}
\textbf{Local State}\\
	\vspace{0.05in}
$
\begin{array}{llll}
\nodeid &:& Type & \mbox{(Node ID)}  \\
\termnum &:& Type & \mbox{(Term num)}^* \\
\seqnum &:& Type & \mbox{(Version num)}^*\\
\dsvalue &:& Type & \mbox{(Local object)}\\
\dstate &:=& (\termnum  \times \seqnum \times \dsvalue) & \mbox{(Local state)} \\
\end{array}
$
\\
\raggedleft

* : Total order required

\raggedright
	\vspace{0.05in}
\textbf{Global State}\\
	\vspace{0.05in}
$
\begin{array}{llll}
\fullset &:=& \set{\nodeid} & \mbox{(Full node ID set)} \\
\gstate &:=& \set{ \nodeid \mapsto \dstate ~\vert~ \forall \nodeid \in \fullset}
	& \mbox{(Global state)}\\
\end{array}
$
\\
	\vspace{0.05in}
\textbf{Network} \\
	\vspace{0.05in}
$
\begin{array}{llll}
\packet &: & Type & \mbox{(Network event)}\\
\networklog &:=& \mbox{list}\ \packet & \mbox{(Network log)}\\
\replay &:& \networklog \rightarrow  \gstate& \mbox{(Log replay function)}\\
\end{array}
$
\\
	\vspace{0.05in}
\textbf{Protocol-specific Functions}  \\
	\vspace{0.05in}
$
\begin{array}{llll}
	\updatefunc & := & \dstate \rightarrow (\seqnum \times \dsvalue) &
	\mbox{(Obj update function)} \\
\gldrfunction & := & \nodeid \rightarrow \networklog \rightarrow \networklog  & \mbox{(Protocol functions)} \\
\gopfunction & := & \nodeid \rightarrow \updatefunc \rightarrow \networklog \rightarrow \networklog  & \mbox{(Protocol functions)} \\

\sendfunction & := & \nodeid \rightarrow \dstate \rightarrow \networklog & \mbox{(Send function)}\\
\recvfunction & := & \nodeid \rightarrow \dstate \rightarrow \networklog & \mbox{(Recv function)}\\
\end{array}
$
\end{small}
\vspace{-1em}
\caption{Basic Definitions}
\label{fig:basic-state}
\vspace{-1.5em}
\end{figure}

\ignore{\wolf{in \pref{fig:basic-state} is $\networklog$ a type or a variable? if it's a type then
it should be $:= list \packet$ instead of $: list \packet$, if it's a variable it should be
$\replay : list \packet \rightarrow \gstate$. similarly for many of the definitions in the protocol-specific functions part}}
\ignore{\lucas{I concur. $\dstate$, $\networklog$, and everything in Protocol-specific
Functions should probably use $:=$ instead of $:$ based on how they're used
elsewhere. I've changed it myself, since this doesn't seem controversial.}}
\pref{fig:basic-state} presents the necessary definitions for the
generic specification.
Nodes must have unique identifiers of type $\nodeid$, which can be any type with decidable equality.
A term number of type $\termnum$ acts as a logical temporal indicator in the system.
Term numbers do not need to correspond to any physical clock,
but they are used to resolve ordering conflicts between operations within the system,
so they must be totally ordered.
Nodes also contain a version number of type $\seqnum$, which is associated with the sequence of updates
of the local object $\dsvalue$.
A local object is one node's partial view of the global distributed object.
Since each node's local state may not be exactly in sync globally due to network or
node failures, the version number indicates how up-to-date a node's state is.
\ignore{\wolf{is it true that if two nodes have the same version number then they must have identical state?}}
%Nodes may also contain additional system-specific state inside their distributed object.
\ignore{\wolf{is the local object $\dsvalue$ not the system-specific part?}}

The global state $\gstate$ is the collection of all the local states hosted by the
entire system, which is composed of the set of distributed nodes $\fullset$.
There is a partial map from each node in the distributed system ($\fullset$)
to its local state ($\dstate$), which is a tuple consisting of a term number,
a version number, and a local object.

Nodes in a distributed system communicate via the network,
which we treat as a shared resource.
Inspired by the approach in CCAL~\cite{concurrency},
the global state $\gstate$ can be reconstructed by
applying the log replay function $\replay$ to the
network log $l : \networklog$, which is a list of network events ($\packet$).
The effect of a call to either $\tplldrfunction$ or $\tplopfunction$ by a node is atomic,
but function calls by other nodes can be interleaved %\wolf{is this true of $\ldrhfunction$ and $\ophfunction$ too?}.
The interleaving is expressed by our network model, described in \pref{sec:low-level-implementation} in detail.
%\wolf{I don't understand the last part of this sentence.
%Does it mean the network model has a channel per protocol that is shared among nodes in that protocol,
%or is there one channel that all protocols share?}.
Our framework keeps track of each function call
within the network log and the replay function $\replay$ computes the
global state based on the network log.
\ignore{\wolf{not sure what the previous two sentences mean. is it saying we record calls to
$ldrfunction$ and $\opfunction$ in the network log? should that be deferred to where we
talk about witnesses?}}
Finally, \sysname{}'s generic specification is parameterized by some protocol-specific
functions that we explain later in this section.

\ignore{
The specify the leader election scheme

For example, multi-Paxos requires replaying the entire log where each log
entry is determined by a quorum of node states. The version number in each node
represents the log index that the node has recorded the state so far. A sharded key-value
store involves simply combining partitioned key-value ranges from all nodes and may
not maintain strongly consistent semantics that require comparing version numbers from
different nodes.

In detail, the specification parameterized with the player's id $\nodeid$,
a term number $\rho$, which is a temporal
indicator, state update functions $\mathcal{G}_{ldr}$ and $\mathcal{G}_{op}$,
and the log $\networklog$ of the distributed systems.

Leader based systems need to guarantee that there is at most one leader at all
times. Therefore, the leader is elected whenever $\rho$, our notion of time, is
updated and $\mathcal{G}_{ldr}$ should implement and guarantee the soundness of
leader election. A successful $\mathcal{G}_{ldr}$ call tags the argument of the
$\mathcal{F}_{ldr}$ function as leader $L$.
Mapping leader election scheme of Raft, which has an explicit notion of a leader,
is straightforward to this model. A coordination service that uses a distributed lock
may not have a strong leader concept but we can regard the node that holds the lock
as a short-lived leader and treat the process of acquiring the lock as $\mathcal{G}_{ldr}$
and assign unique $\rho$ to for each acquire and release lock phase. }

%$\mathcal{G}$ defines the system specific protocols that applies to $N$.

%The common features that our model is intrested in for $\mathcal{S}$
%are the leader node $L \in N$ which is elected for each $\rho$
%and a distributed object $O$ (e.g. an entire key-value store state hosted within
%multi-Paxos) maintained within $N$. Because $O$ is an abstract state maintained
%within a specific system over distributed nodes in $N$, extracting $O$ out of
%$N$ would be system specific (e.g. for multi-Paxos, the entire log should be
%replayed).
%\jiyong{We should associate version number to $O$.}

%They consist of a set of multiple nodes, so each node
%contains their identifier ($\nodeid$).

%Leader based systems need to guarantee that there is at most one leader at all
%times. Therefore, the leader is elected whenever $\rho$, our notion of time, is
%updated and $\mathcal{G}_{ldr}$ should implement and guarantee the soundness of
%leader election. A successful $\mathcal{G}_{ldr}$ call tags the argument of the
%$\mathcal{F}_{ldr}$ function as leader $L$.
%Mapping leader election scheme of Raft, which has an explicit notion of a leader,
%is straightforward to this model. A coordination service that uses a distributed lock
%may not have a strong leader concept but we can regard the node that holds the lock
%as a short-lived leader and treat the process of acquiring the lock as $\mathcal{G}_{ldr}$
%and assign unique $\rho$ to for each acquire and release lock phase.

%In this sense,
%systems contain $\termnum$,
%which works as a virtual time clock of the system, in it.
%Each node can contain their own term number in their state,
%but the number is used in the entire system for global synchronization.
%For example, the term number in Raft is a protocol-specific representation of
%this term number in our generic specification.

%On the other hand,
%distributed object can be viewed as a set of local copies that does not need to be strongly
%synchronized with other copies in other nodes.
%Therefore, distributed objects need an indicator
%to keep track of the version history of their update and contents.
%In this sense,
%each node contains a version number in its local state.
%For example, Raft and multipaxos use an index number as their version number.
%Due to the assumptions about possibilities of failures,
%the state definition contains two version numbers in it,
%which indicates the possibly partially written values and successfully written values.
%In Raft, for instance,
%the first version number is an index number, while
%the second is a committed index number.

%The last element in the state definition is an actual distributed object that
%contains application-specific datum.
%It could be a singleton value, a list of values, or user-defined typed values.
%With those generic form of data structures, we now be able to define specifications for
%two important functions, \textit{prepare} and \textit{commit} functions, in the leader-based system.

\subsection{Leader Election}
\label{subsec:leader-election}

%\lucas{I'd like to suggest we use ``selection'' rather than ``election'' unless
%we are specifically referring to a system in which each node in some nontrivial
%set gets some kind of say in which node becomes leader. Also, are we using
%``Requester'' and ``Approver'' just to avoid using the same terms as Paxos, or
%is there some semantically significant distinction?}
%\jiyong{I think leader election is a more general term than selection in the community.}

\paragraph{Requester}
The goal of leader election is to set a new term, give one node exclusive access to the
entire system, and synchronize every node's local state such that the
global state is prepared to be updated.

Using function definitions in \pref{fig:basic-state}, we define the template function for leader election as follows:
\begin{small}
$$
\begin{array}{l}
	\ldrfunction (nid: \nodeid) (g_{pre}\ g_{post}:  \gldrfunction)
	(tx: \sendfunction)(rx: \recvfunction)(l_1  :\networklog ) := \\
\ \ \ \mbox{\textbf{let}} \ l_2 := g_{pre}\ nid \ l  \ \mbox{\textbf{in}}\ \mbox{\textbf{let}}\ l_3 := tx(nid, \replay(l_2 \mdoubleplus l_1)[nid]) \ \mbox{\textbf{in}}  \\
\ \ \ \mbox{\textbf{let}} \ l_4 := rx(nid, \replay(l_3 \mdoubleplus l_2 \mdoubleplus l_1)[nid]) \
  \mbox{\textbf{in}}\\ 
\ \ \  \mbox{\textbf{let}} \ l_5 := g_{post}\ nid \ (l_4 \mdoubleplus l_3 \mdoubleplus l_2 \mdoubleplus l_1) \ \mbox{\textbf{in}} \ l_5. \\
\end{array}
$$
\end{small}
where $\replay(l)[nid]$ is a projection from the global state generated by the log replay function to 
the local stated of $nid$.
%\wolf{what does the $[nid]$ part of the $\replay(l)[nid]$ notation mean?}
%\jieung{projection from the global state to the local state mapped with $nid$}
%\lucas{It means lookup the local state belonging to $nid$ in the global state
%obtained from the replay function. What I find more confusing is why both
%$\sendfunction$ and $\recvfunction$ take an entire local state as an argument.
%This is highly unintuitive, and if correct needs explanation. Not only that, but
%$\ldrfunction$ is implicitly either monadic or stateful. In this otherwise
%purely functional context, this needs to be explicitly acknowledged or changed.
%One way or another, I think we need a better explanation of what state
%$\sendfunction$ changes.}
%\jiyong{I think abstracting out some details, if it does not obstruct explaining
%the proof or other parts of this paper, will increase the readability.}

%Intuitively, the function tries to get a control for the distributed object as well as
%updates the local distributed object mapped with the node id as an up-to-date status.
%The up-to-date status implies that the status that guarantees the strong consistency.
%The function also updates the round number too, which are
%encapsulated in the local state.

This function captures the common form of a leader election scheme, which sends requests to
and gets approval from a set of authoritative nodes.
First, $g_{pre}$ changes the local state of a candidate node to prepare
for a leader election and generates corresponding request messages.
Network messages are sent and received using $tx$ and $rx$, which define system-specific
communication patterns between the requester and the approvers.
Finally, $g_{post}$ determines the final outcome of the
leader election and executes any actions that are necessary before becoming the leader.

The table on the left side of \pref{fig:process-flow} lists concrete examples of the parameters of
$\ldrfunction$. For example, multi-Paxos requires a majority vote from the acceptors to
become the leader, a two-phase commit protocol that uses a membership service may delegate
a transaction coordinator selection to this service, and Lamport's lock requires all node's
approval to acquire the lock. Note that the transaction coordinator and the lock holder are
regarded as leaders. The typical post-election operations are checking whether the
previous leader left the system in a consistent state and making the state consistent
if necessary. 

\paragraph{Approver}
The other part of leader election is how the approvers handle requests.
This typically involves some protocol-specific check of the request's
term number, followed by a local state update, and then an acknowledgement
containing the new state. We express this pattern as follows:
\begin{small}
$$
\begin{array}{l}
	\ldrhfunction (nid: \nodeid) (g:  \gldrfunction)
	(tx: \sendfunction)(rx: \recvfunction)(l_1  :\networklog ) := \\
\ \ \ \mbox{\textbf{let}} \ l_2 := rx(nid, \replay(l_1)[nid]) \
  \mbox{\textbf{in}} \\
\ \ \ \mbox{\textbf{let}}\ l_3  := g\ nid \ (l_2 \mdoubleplus l_1) \ \mbox{\textbf{in}} \\
\ \ \ \mbox{\textbf{let}} \ l_4 :=  tx(nid, \replay(l_3 \mdoubleplus l_2 \mdoubleplus l_1)[nid]) \ \mbox{\textbf{in}} \ l_4.
   \\
\end{array}
$$
\end{small}

Clearly, to prove any interesting properties of $\ldrfunction$ or $\ldrhfunction$
the system-specific state update functions must be restricted in some way.
For example, the term number modified by protocol-specific functions in $\ldrfunction$
need to increase monotonically in most leader-based distributed systems.
Additionally, $g$ in $\ldrhfunction$ should not touch the value inside
the distributed object in order to separate the leader election and the commit operation.
We discuss more about those requirements that the parameters must satisfy and what properties we
are able to prove in \pref{sec:prove-safety-with-witness}.


\subsection{Commit}
\label{subsec:commit}

\paragraph{Requester}
The commit function has a similar format to the leader election function, but
includes an object update function $u : \updatefunc$:
%One another key part of leader based distributed systems is a operation function.
%The way to operate the change usually depends on the system and the current status.
%the internal definition of the commit function can be defined as follows:
\begin{small}
$$
\begin{array}{l}
\opfunction (nid: \nodeid) (u : \updatefunc) (g_{pre}\ g_{post}:  \gopfunction)
	(tx: \sendfunction)\\
	(rx: \recvfunction)
	(l_1  :\networklog ) := \\
\ \ \ \mbox{\textbf{let}} \ l_2 := g_{pre}\ u \ l_1  \ \mbox{\textbf{in}}\   l_3 := tx(nid, \replay(l_2 \mdoubleplus l_1)[nid]) \ \mbox{\textbf{in}}  \\
\ \ \ \mbox{\textbf{let}} \ l_4 := rx(nid, \replay(l_3 \mdoubleplus l_2 \mdoubleplus l_1)[nid]) \
	\mbox{\textbf{in}} \\
\ \ \ \mbox{\textbf{let}} \ l_5 := 	 g_{post}\  u \ (l_4 \mdoubleplus l_3 \mdoubleplus l_2 \mdoubleplus l_1) \ \mbox{\textbf{in}}\ l_5.
\end{array}
$$
\end{small}
The object update function defines how the system updates the local object and
the version number depending on the local state of each node.
The update function is encapsulated in the message that is sent to the target node
via the send function ($tx : \sendfunction$).

Examples of how $\opfunction$ function is used are found on the right side
of \pref{fig:process-flow}. The number of recipients of the commit request differs depending
on the system; it could be all nodes in the system or just a few targeted nodes.
For the protocols that require more than 2 rounds in their commit phases, such as 
two-phase commit, $\opfunction$ should be called multiple times and $g_{pre}$ and
$g_{post}$ should have a flag to handle different functions that correspond to
each round. 

%\jiyong{Can we do 2 round protocols for commit using this format? Sending execution 
%function seems like a limiting factor.}
%\jieung{we can always send an identity function in the specification even though the low level 
%Intuitively, the operation function tells how the distributed object can actually be manipulated.
%The function looks similar to the leader election, but the biggest difference is the existence
%of update function $\updatefunc$.
%The update function defines how it update the distributed object and the sequence number
%depending on the local state itself.
%The update function is encapsulated in the packet message when the $\sendfunction$ send
%the message.
%Then the specification can be used with any arbitrary
%update function to specify the behavior of the protocol.
\paragraph{Approver}
When a requester triggers a commit operation, the approvers need to
handle the operation and update the local view of the distributed object if
necessary. Unlike $\opfunction$, $\ophfunction$ does not take an update function as an argument
because it is already in the message from the requester.
To retrieve the update function from the received message $\ophfunction$ requires
an auxiliary function, $\mathrm{proj}_{f}$, which extracts the update function from the network log.
\ignore{\lucas{I fixed the above paragraph a bit, but the last part is problematic. I
don't know what this sentence means: All those behaviors are also hidden in the
$\gldrfunction$ as follows:}}
\vspace{-0.2em}
\begin{small}
$$
\begin{array}{l}
	\ophfunction (nid: \nodeid) (g:  \gopfunction)
	(tx: \sendfunction)(rx: \recvfunction)(l_1  :\networklog ) := \\
\ \ \ \mbox{\textbf{let}} \ l_2 := rx(nid, \replay(l_1)[nid]) \
  \mbox{\textbf{in}} \\
\ \ \ \mbox{\textbf{let}} \ u := \mathrm{proj}_{f} \ (l_2 \mdoubleplus l_1, nid) \
  \mbox{\textbf{in}} \\
\ \ \ \mbox{\textbf{let}}\ l_3  := g\ u\ nid \ (l_2 \mdoubleplus l_1) \ \mbox{\textbf{in}} \\
\ \ \ \mbox{\textbf{let}} \ l_4 := tx(nid, \replay(l_3 \mdoubleplus l_2 \mdoubleplus l_1)[nid]) \ \mbox{\textbf{in}}  \ l_4.
   \\
\end{array}
$$
\end{small}
\vspace{-1em}

\ignore{
\subsection{Proofs with Generic Specification}
\label{subsec:generic-spec-proof}


\wolf{this section seems more like an introduction to witnesses than a discussion about proofs with the generic specification}
The generic specification provides a template for leader-based distributed protocols and hides unnecessary details from users.
It also provides a guideline for proving functional correctness when connecting the specification with a low-level implementation written in C or Assembly.

It, however, needs further items to prove safety properties of distributed systems efficiently.
Based on CCAL, and our generic specification, 
the state of the distributed system is modeled as a network history, which we can refer the 
status of other nodes.
The network history, however, usually contains unnecessary events in it due to the network failure assumptions, packet reordering or duplication, that most distributed systems have to consider. 
Therefore, having more precise, locally built, and globally consistent data structure to aid the safety proof of the distributed system is desired. 
In this sense, we introduce the witness and witness-passing. 
}


\ignore{
\subsection{Properties}
\label{subsec:properties}
With following the generic specification, 
\sysname{} guarantees that those operations will not be interfered by other operations, 
even though they generate multiple events while their operations. 

\begin{theorem}[Interference-Free]

\end{theorem}
Regardless of the detail in the function definition 


The generic specification can be used to verify common properties of
leader-based distributed systems. For instance, linearizability~\cite{herlihy90}
is a property that can guarantee that the system is making state transitions
without exposing any anomalous state.
\lucas{This doesn't sound like what I understand linearizability to be. I was
under the impression that linearizability is satisfied when the challenges and
responses in a history of events can be reordered into a correct, consistent
sequential history. I don't know what it means to ``expose anomalous state''.}

If we can safely assume that object update function $\updatefunc$ is applied by
a single valid leader and the function call makes atomic state changes, this
will lead to easy verification of the linearizability properties.
\lucas{Are there multiple linearizability properties? Maybe we should elaborate,
or simply stick to ``property''?}

However, constructing a proof for linearizability requires evidence for the
assumptions. Therefore, generic specifications alone are not sufficient for the
verification of common properties of leader-based distributed systems.
\lucas{Could we be more specific about which assumptions we mean?}

\jiyong{I think this subsection should talk about what properties are proved for
free if we use \sysname{} rather than saying that the generic specification is
insufficient to verify the common properties. So we should say the generic spec
requires X, Y, and Z, and this makes the proof possible. We should also sketch
the proof as well.}
\lucas{Ah, yes. This is a good point, Ji-Yong. I think you're right that we
could emphasize what we can do rather than what we can't.}
%The high level specification with proper constraints about update function
%can be used for verifying generic properties of
%leader-based distributed systems.
%
%For instance, linearizabilty~\needcite{linearizability paper}
% is a common feature that may be required in
%all leader based distributed systems.
%
%Let's assume that
%all $\updatefunc$ in the previous section
%guarantees that the sequential number and the committed sequential number monotonically.
%With this constraint,
%verifying that
%each commit function
%guarantees linearizability.
%
%However,
%providing the proof object about linearizability
%also requires us to connect all commit function applications as well as all leader election functions.
%In this sense,
%only providing
%generic specifications are not sufficient
%for the verification of leader-based distributed systems.
}
