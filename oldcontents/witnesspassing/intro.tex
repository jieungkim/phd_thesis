\section{Introduction}
\label{sec:intro}

\topic{Distributed systems are difficult to verify.}

Distributed systems are challenging to formally model, reason about, and verify
due to their inherent concurrency and weak failure assumptions. Distributed
nodes run concurrently over an asynchronous network and both the node and the
network link can fail at any moment. To clear these hurdles a distributed
protocol must have sophisticated error handling and typically relies on implicit
global invariants, which complicates formal reasoning about the system.

\topic{There is a need to verify multiple distributed systems for practical
reasons.}

While even verifying a single distributed system is challenging, in practice
distributed applications rely on several distributed systems. An application
might employ different distributed systems for distinct functionalities (e.g.
consensus~\cite{vivaladifference}, distributed transactions~\cite{gray:2006},
and distributed locks~\cite{chubby, zookeeper} as part of a high reliability
distributed database) or it might use systems that achieve the same goal (e.g.
multi-Paxos~\cite{paxosmadesimple, rvrpaxos} vs. Raft~\cite{raft}) in different
parts of the application depending on performance considerations or simple
preference. Therefore, to realize a verified distributed system environment,
methodologies to extend formal reasoning to multiple distributed systems are
necessary.

\topic{Leader based systems are widely used but is not studied well as a whole}

We find that distributed systems that realize strong semantics are typically
designed under a common pattern: systems exploit a leader node
(or a centralized coordinator) explicitly or implicitly to coordinate
distributed state changes. Indeed, for simplicity of management and understanding,
this leader-based scheme is commonly used to implement critical distributed
functions. For example, multi-Paxos and Raft elect a leader to replicate states
across multiple nodes, two-phase commit employs a transaction manager to
coordinate transactions over multiple resource managers, and coordination
services grant a lock to a requester to have mutually exclusive access to a
distributed shared state.

While the leader-based scheme has a huge presence in the design of distributed systems,
little attention has been paid to formally modeling and studying the common properties
of leader-based distributed systems as a whole. Previous work mostly focused
on verifying individual leader-based distributed systems~\cite{ironfleet, cppraft}
or on general approaches to verify arbitrary distributed systems by relaxing network
models, finding better automation schemes, and isolating and modularizing the
proof structure~\cite{verdi, disel, modular}. We argue that formally
modeling and studying the class of leader-based distributed systems can yield greater
insight into and expedite verification of many systems in that category.

\topic{We model a leader based distributed system using a common specification.}
\subtopic{Covers all leader based system.}

Therefore, we propose \sysname{}, a verification framework for
leader-based distributed systems that promotes the understanding of
a variety of leader-based distributed systems and facilitates the verification
of each system. \sysname{} demonstrates how seemingly very different distributed systems,
such as multi-Paxos, Raft, and distributed locks, can be modeled and verified under
a generic specification as long as they follow the leader-based design.
\sysname{} includes a formal model of leader-based distributed systems and
proofs of generic properties of the model.
It also acts as a proof template that can be instantiated with a particular leader-based
system to show that the general properties hold for it.

%\jieung{hope to shorten the previous paragraph, but will rephrase it later}

%In this paper, we focus on generalizing the leader-based distributed system
%(i.e., the distributed system that uses the leader-based protocol) to propose a
%formal model to reason about and verify various leader-based systems under a
%common framework. The common framework includes a general specification of the
%leader based distributed system, a proof of common characteristics of the
%system that are exposed by the specification, and detailed low-level
%specifications and their proof of a particular leader-based system that one
%wants to verify using the framework.

We identify a few common characteristics of leader-based distributed systems:
first, they use a logical clock under different names such as round number,
term, timestamp, or epoch, to order operations and to tag the leader's
leadership period;
and second, they take strongly consistent steps in the sense that a
sequence of successful operations by the leader takes effect and is made visible
system-wide in the same sequential order (a linearizable order).
We propose a generic specification that models all leader-based systems using a
term number $\termnum$, template functions $\tplfunction$, and
a version number $\seqnum$. $\termnum$ represents the term in which a leader's leadership is valid,
$\tplfunction$ describes common behaviors of leader-based distributed systems,
and $\seqnum$ is tagged to the system state to order successful calls to $\tplfunction$.

\subtopic{Intro to the specification.}

\sysname{} models leader-based systems using two template functions:
1) $\tplldrfunction$, which elects a new leader of the system and
2) $\tplopfunction$, which the elected leader issues over the entire system
to mutate the state. These functions work as a high-level specification or a
template to elect a leader and execute operations over the entire system.
$\tplldrfunction$ and $\tplopfunction$ take the term number $\termnum$ as an identifier
and corresponding state update functions $\gldrfunction$ or
$\gopfunction$ that specify how a system modeled under \sysname{}
actually elects a leader or reaches a new state, respectively (Figure~\ref{fig:process-flow}).
$\tplfunction$ is designed to be generic enough to host most
leader-based distributed system and $\tplfunction$ and $\protocolfunction$
constitute the full specification of a leader-based distributed system.

%The state $\mathcal{S}$ is the distributed system which encapsulates a
%distributed state $\dobj$.
%$\mathcal{G}$ should implement strongly consistent semantics
%such that $\mathcal{F}$ that uses $\mathcal{G}$ can mutate the distributed
%state $\dobj$ atomically.

%\wolf{is the distinction between $\mathcal{F}$ and $\mathcal{G}$ important? Also, could we give the function types?}
%
%For example, to model multi-Paxos using \sysname{}, $\ldrfunction$
%elects one node in $\fullset$ as the leader using a
%protocol defined by $\gldrfunction^{mp}$ and $\opfunction$
%mutates $\dobj$ by running Paxos protocols to append the state
%changes to $\dobj$ into the state machine replication log using
%$\gopfunction^{mp}$. One of the main roles of $\gopfunction^{mp}$ is to
%implement consensus protocol on a single Paxos instance which is an entry of the log.
%The correctness of $\gopfunction^{mp}$ can be verified similar
%to how other literatures~\cite{sdpaxos, dpaxos, paxosepr} have verified Paxos consensus,
%but \sysname{} extends this verified single step to guarantee the correctness of
%an infinite sequence of these steps to model how distributed systems host and
%update a distributed object $\dobj$ in a general way.
%\sysname{} allows any leader-based distributed systems to plug in their
%behaviors on $\fullset$ to maintain $\dobj$ in a form of the function
%$\protocolfunction$ as illustrated in Figure~\ref{fig:examples} and detailed in Section~\ref{sec:xxx}.
%\wolf{I don't think this paragraph does much to clarify how one can use \sysname{} or what it gains you.
%It makes it sound like you just verify your system like usual and then plug it in to $\gldrfunction$
%or $\gopfunction$ but it doesn't explain how that helps}
%\wolf{Maybe this paragraph should be cut and replaced with a pointer to a later section (3 maybe)
%for more details}

%The model expressed by $\mathcal{F}$ and $\mathcal{G}$ is similar to
%to the specification of CASPaxos~\needcite{CASPaxos} which applies arbitrary
%functions atomically to a distributed shared object, or that of a state machine
%replication~\needcite{smr}.

\subtopic{Can verify linearizability of state mutation in a common way.}

%\wolf{can we list these assumptions?}
By making a few assumptions  about $\protocolfunction$
such as monotonic increasing of $\seqnum$ in the distributed object,
the immutability of previous committed values, and atomicity of the resulting
state, \sysname{} provides proofs of few common properties of leader-based distributed systems:
linearizability of state updates and the soundness (uniqueness at term $\termnum$)
of the leader.
Therefore \sysname{} provides a reusable proof template in the sense that these properties
are given ``for free'' once $\protocolfunction$ has been shown to satisfy the assumptions.
In addition to specifying the system behavior,
the state update function $\protocolfunction$ is responsible for exposing necessary
states and information, which we call the witness, to the template for the proof.

\topic{Internally we use a witness based verification approach.}
\subtopic{Witness makes easier reasoning.}

A witness is an abstract data structure that simplifies reasoning about and
verifying properties of distributed systems. Although we make use of witnesses
in \sysname{}, they are applicable in more general systems as well. A witness is
a logical component of messages sent between distributed nodes that share what
each node has seen so far. The contents of this data structure are
protocol-specific and could be the sending node's own state or an observed state
of another node. As this information is passed around and accumulates, it can
act as evidence to demonstrate how each node reached its current state and to
justify a node's next decision with respect to the protocol. The behavior of a
node can then easily be verified in relation to the entire distributed system.
% through primarily local reasoning by using the witness.
%and the linearizability of entire
%distributed system state update becomes easily deducible.
%\wolf{we should make the distinction between local and global reasoning clearer}

\subtopic{Witness also generates necessary information to the template.}
\subtopic{We show the witness based approach can be composed.}

Another advantage of witnesses is that they are composable. Witness data
structures that are used to verify different components of the system can be
combined to set the ground for verifying the entire system behavior or the
interaction between system components. For example, $\tplldrfunction$ uses every
node's vote history $\ldrwitness$ as a witness to elect a sound leader and to
justify that leader's use of $\tplopfunction$. Then, the composition of witnesses
$\opwitness$, which is created during the execution of $\tplopfunction$, and
$\ldrwitness$ becomes the source of what function $\protocolfunction$ passes to
the proof template to prove the linearizability of the entire system.

%\wolf{this could also probably be shortened/cut and deferred to a more detailed discussion in section 4}

Proving the correctness of the state update function $\protocolfunction$ is equivalent to
verifying a distributed system while leaving the verification for linearizability
and soundness of the leader. However, modeling and verifying different systems
under the same template allows a deeper understanding of subtle differences among systems.
A comparison of commonalities and differences in state update functions
and proofs yields such insight which we outline in Section~\ref{sec:examples}.

%\jiyong{Also compare with other distributed system verification framework
%papers: e.g. DISEL, other group of Paxos verification paper.}
%
%Few previous works also propose ways to verify distributed systems in a modular way or with compositionality.~\needcite{DISEL, OOPLSA17}.
%However, they do not provide a generic way to prove  \jieung{Is it true with OOPSLA17 and PLDI18?}
%key properties of
%leader based systems, such as
%mutual exclusiveness of leaders at a particular virtual time
%and the linearizabilty of the log that they have manipulated.

\topic{As an example we study a multi-Paxos system in detail}

To illustrate how a leader-based system is verified in \sysname{},
we take multi-Paxos as an example.
%and Raft~\cite{raft} and Lamport's
%distributed lock~\cite{lamportclock} as secondary examples.

\sysname{} uses the certified concurrent abstraction layer (CCAL)~\cite{concurrency}
approach and extends CCAL with a network model, witnesses, and the generic model
and proof template of leader-based distributed systems. Thanks to CCAL, we
can connect our proofs about the high-level specifications down to their C implementations
and we can easily modularize and compose the proofs and witnesses.
We demonstrate that \sysname{} can effectively model different
leader-based systems and facilitate the verification of their common and
distinct properties while also yielding great insight into these systems.

This paper makes the following three contributions:
\begin{itemize}[leftmargin=*]
\item We propose a general framework to model and verify leader-based
	distributed systems where the framework enables automatic verification
	of linearizability and soundness of the leader and easy comparison of
	different leader based distributed systems.
\item We propose a novel witness-passing scheme that facilitates
	reasoning about distributed systems in a modular way
	and provides insight for how distributed system protocols work and
	interact with each other.
\item We detail the safety proof of Paxos and the linearizability and leadership
	proof of multi-Paxos using our framework and compare the proofs with
	those of Raft, two-phase commit and Lamport's distributed lock using \sysname{}.
\end{itemize}

%The rest of the paper is organized as follows.
%Section~\ref{sec:background} provides background information about the
%leader-based distributed system and our verification scheme and
%Section~\ref{sec:spec} describes the specification of the generic model of the
%leader-based distributed systems.
%Section~\ref{sec:witness-passing-semantics} details the formal definitions of
%our verification approach using the witness.
%Sections~\ref{sec:paxos-verification}-\ref{sec:evaluation} provide examples of
%our framework and verification approach applied to multi-Paxos and other systems
%and evaluate our proof methodology.
%Section~\ref{sec:related} investigates the related work and
%Section~\ref{sec:conclusion} presents our conclusion.
%\jiyong{We can remove this paragraph if we need space.}

%=========================================
%
%\topic{Rationale behind our approach.}
%To understand why the write-witness-passing scheme is useful, one should first understand how distributed systems are designed.
%Distributed systems have evolved to hide complex protocols using simple abstractions and to send as little information as possible between nodes to save network bandwidth.
%Messages sent over the network may be lost depending on network assumptions and information received over the network is often discarded right after it is used to update any relevant local states.
%The code for each node often blindly executes an operation without the global view of the entire distributed system and assumes that all other nodes are working correctly.
%Therefore, the context that can be extracted from the code for a local node is typically not enough to reason about the validity of the node's state against the entire distributed system.
%
%
%
%%Compared to ad-hoc systems such as a peer-to-peer system with
%
%
%%Distributed systems, especially state machines form the underlying base of many applications these days.
%%Unfortunately, verifying these systems is difficult because of the inherent concurrency and the possibility of failure in both the nodes and the network.
%%For distributed nodes to collaborate and overcome these failures seamlessly,
%%distributed systems must employ sophisticated protocols.
%%\topic{Existing non-machine checkable proofs are less useful in practice.}
%%Although many of these distributed protocols have pencil-and-paper proofs of their correctness,
%%their subtle and complex nature makes them difficult to implement faithfully in actual code.
%%Even though the industry rigorously applies various testing strategies
%%for software development, there are continuous reports about distributed software bugs that can shut down entire data centers~\cite{awsdown, gmaildown}.
%
%\topic{Interactive theorem provers created opportunities to verify distributed systems.}
%Machine-checkable verification tools open up new opportunities to provide distributed systems
%with end-to-end correctness guarantees by
%verifying low-level implementations of distributed code and linking them with safety proofs of the abstract protocols.
%Specifically, theorem provers allow line-by-line verification of the code
%with support for partial proof-automation.
%Previous works have used
%both automated tools such as Z3~\cite{moura08} and
%Dafny~\cite{dafny} as well as
%interactive tools, such as Coq~\cite{coq}.
%\ignore{
%The most common tools are the ones based on SMT solvers, such as Z3\cite{moura08} and
%Dafny\cite{dafny}, which are well automated but works for only first-order logic and decidable problems,
%and Coq\cite{coq}, which is less automated but works on high-order logic.}
%
%\topic{But distributed system verification is still difficult.}
%Regardless of which tool one uses,
%verifying distributed system code with an interactive theorem prover requires much more work
%than with a hand-written proof.
%The verification must cover every low-level corner case that is mostly related to the underlying network error
%or optimization.
%In addition, the collective view
%of all distributed nodes and the network -- which we call the \globalstate{} --
%should be created and made available to the proof because key safety properties of distributed protocol
%always related to not with a single node but with all nodes in the system.
%Thus, even given a high-level proof of a theorem for a distributed protocol,
%there is still a significant proof burden to bridge the gap between the code and the model.
%
%\topic{Reasons why others have failed: verdi, ironfleet, sergey et al., disel, etc.}
%For this reason, proofs of distributed protocols done using interactive theorem provers often simplify the \globalstate{}
%and rely on additional tools or assumptions to fill in the missing pieces.
%For example, in Ironfleet's~\cite{ironfleet} model, all distributed nodes are connected via an asynchronous network,
%and they show that the code refines the \globalstate{}.
%However, in part due to the expressiveness limitations of Dafny, Ironfleet's verification relies on pencil-and-paper proofs to show
%that a realistic, arbitrarily-interleaved network refines their more restrictive \globalstate{}.
%Verdi~\cite{verdi} similarly models a global state but assumes an ``idealized'' network and carries out refinement proofs to show that the code refines the \globalstate{}.
%It then relaxes its assumptions by automatically applying valid transformations to the code, such as adding sequence numbers to tolerate packet duplication.
%However, starting with an assumption of an ideal network is not suitable for verifying systems such as Paxos~\cite{paxos} that assume a faulty network.
%% which the same authors showed the safety proof later in a separate paper~\cite{cppraft}. % TODO: fit this reference in another way
%Several other papers suggest methodologies to verify distributed systems using interactive theorem provers,
%but they focus on specific topics such as automation~\cite{modular} or isolating protocols~\cite{disel} and do not fully address this problem.
%
%\topic{We propose a new and easy-to-understand distributed system proving techniques: new global model + witness-passing.}
%To fill in this gap, we propose a \globalstate{} of a distributed system where the proof can be written entirely in Coq,
%and a novel write-witness-passing scheme that can promote the understanding of distributed system protocols and simplify the verification process.
%Our \globalstate{} includes an asynchronous network, and the states in the \globalstate{} are constructed by composing the operations and local state of each node.
%Write-witness-passing adds a logical data structure to the messages sent between nodes that remembers what each node has seen so far.
%The contents of this data structure could come from the sending node's own state or from observations of other nodes' state.
%As this information accumulates it can show how each node reached its current state, with evidence demonstrating the validity of each transition.
%Using these witnesses, the behavior of a node can easily be verified with respect to the \globalstate{} through primarily local reasoning.
%
%\topic{Rationale behind our approach.}
%To understand why the write-witness-passing scheme is useful, one should first understand how distributed systems are designed.
%Distributed systems have evolved to hide complex protocols using simple abstractions and to send as little information as possible between nodes to save network bandwidth.
%Messages sent over the network may be lost depending on network assumptions and information received over the network is often discarded right after it is used to update any relevant local states.
%The code for each node often blindly executes an operation without the global view of the entire distributed system and assumes that all other nodes are working correctly.
%Therefore, the context that can be extracted from the code for a local node is typically not enough to reason about the validity of the node's state against the entire distributed system.
%
%\topic{Our design: 1) Network model: we don't make any extra assumptions}
%Our \globalstate{}'s network is asynchronous and allows that packets can be dropped, delayed, reordered, interleaved, and duplicated, but never corrupted,
%which most other works on distributed system verification also assume.
%Such a realistic network model is necessary because verification based on a weaker model will be invalid in an actual deployment.
%Depending on the need, our network model can sometimes be refined to a more restrictive model, but, because of the simulation relation,
%properties proved using this model are also guaranteed to hold for the realistic one.
%Existing work sometimes assumes that nodes operate atomically between send and receive (for clients) or receive and send (for servers)~\cite{verdi},
%but our model does not have any such additional assumptions.
%
%\topic{Our design: 2) Our global model.}
%State in our \globalstate{} is a collection of all local states that are affected by the network.
%To prove correctness of the whole system, we must show that the interactions among the distributed nodes are correct.
%Our model of the global state is not very different from other work, but the write-witness-passing scheme takes advantage of the state in an unique way.
%
%\topic{Our design: 3) Why witness-passing: how it works easier to reason and prove.}
%While typical proofs of distributed systems involve showing that a local node's behavior refines the \globalstate{}~\cite{verdi, ironfleet},
%write-witness-passing works in the opposite direction;
%we start from a \globalstate{} and bring necessary global state information into the local state.
%The imported state is what the other nodes have witnessed at the time of sending messages.
%This information provides the context that is necessary for a local node to reason about its correctness within the entire distributed system,
%but was not required to simply execute the distributed protocol.
%The imported global state constitutes a witness-tree that keeps track of the path and evidence for how a node's current state was reached.
%This structure can be used for checking invariants and carrying out inductive proofs of the protocol.
%The witness-tree has partial information about the entire system state, but only the parts that are relevant to the node currently holding the tree.
%Thus, the verification can take place within the local context of a node without having to worry about other complex states in the rest of the distributed system.
%Because the information in the witness-tree was taken from the global state, an invariant that the data in the tree corresponds to something in the \globalstate{} naturally holds.
%In addition to easier verification, a proof based on write-witness-passing provides insight into why the protocol works,
%because the verification takes place in a local context that more closely mirrors the implementation.
%
%We use Paxos as an example to demonstrate how our \globalstate{} and write-witness-passing scheme can facilitate the verification of distributed systems.
%Paxos is a good example to explore the power of write-witness-passing because it requires communication with at least a majority of acceptors,
%and the weak network assumptions require reasoning about failure cases.
%Therefore, being able to handle a weak network model and having a clear sight on the global view of the system are necessary to verify the system.
%The Paxos consensus protocol is also notoriously difficult to understand just by observing the information that is passed around.
%Write-witness-passing can gather necessary global state into a tree to provide a clearer insight into how the protocol works.
%
%\begin{figure}
%\includegraphics[scale=.70]{figs/overall_structure}
%\caption{Overall Structure of Distributed System Verification with Write-Witness-Passing.
%All important components are explained in the later sections; (1) in Sect.~\ref{subsec:network-primitives} and
%Sect.~\ref{subsec:low-level-network-syntax-and-semantics}; (2) in Sect.~\ref{subsec:network-primitives} and Sect.~\ref{subsec:functional-correctness};
%(3) in Sect.~\ref{subsec:distributed-transition-semantics} and Sect.~\ref{subsec:witness-passing-semantics-in-paxos}
%(4) in Sect.~\ref{subsec:witness-write}, Sect.~\ref{subsec:distributed-transition-semantics-with-witness-passing}, and Sect.~\ref{subsec:witness-passing-semantics-in-paxos};
%(5) in Sect.~\ref{subsec:paxos-safety} and Sect.~\ref{subsec:extensibility-of-verified-paxos}; and
%(6) in Sect.~\ref{subsec:extensibility-of-verified-paxos}}
%\label{fig:overall-structure}
%\end{figure}
%
%To realize the write-witness-passing scheme, we use certified concurrent abstraction layers (CCAL)~\cite{concurrency} as the base verification framework
%and build necessary components such as the \globalstate{}, which includes the network model and node states, and the state transition framework within the \globalstate{}.
%The contextual refinement scheme that is proposed by the CCAL approach adds more benefits to our distributed system verification framework,
%such as enabling vertical and horizontal composition of verified protocols.
%Figure~\ref{fig:overall-structure} shows the overall structure of
%distributed system verification with write-witness-passing, and the important components are numbered in the figure.
%In a later section, we describe those components one by one, and
%we show how our framework and write-witness-passing can be used to prove Paxos leader election and reconfiguration, as well as other distributed protocols.
%
%
%This paper makes the following contributions:
%\begin{itemize}
%	\item We propose a general distributed system verification approach with the capability to link Coq-verified specifications with executable C code without relying on any external verification tools.
%	\item We propose a novel write-witness-passing scheme that facilitates local reasoning about distributed systems and provides insight into how distributed system protocols work.
%	\item We present a complete safety proof of Paxos using our verification framework and sketch how our framework can be used to verify other distributed systems.
%\end{itemize}
%
%
%The remaining parts of this paper are organized as follows.
%Section~\ref{sec:overview} is an overview of our verification approach using Paxos.
%Section~\ref{sec:witness-passing-semantics} describes in detail the formal definitions of our verification approach and of write-witnesses.
%Sections~\ref{sec:paxos-verification}-\ref{sec:evaluation} provide examples of
%our verification approach applied to Paxos and variants of Paxos, and evaluate
%our proof methodology.
%Section~\ref{sec:related} investigates related work and gives our conclusions.
%
%\topic{Benefit of CCAL: 1) network model is flexible, 2) vertical and horizontal composition.}
%
%\topic{Contributions:
%1) provide simple way to represent consensus protocols as well as for safety proofs of those protocols,
%2) provide the way to link those representations with low-level implementations (scalable, reusable way),
%3) verify Paxos using the approach with small human efforts.}

%\jiyong{We need to know what are the typical ways that others model the global state to verify distributed systems.}
%\jieung{
%\begin{enumerate}
%\item Ironfleet: takes too much human effort. Some parts are treated as assumptions (network reduction is not able to be verified)
%\item ESOP18, Verdi: made atomic handler and collect those atomic handlers to define global transition systems - connecting local behaviours with global transition systems. for the global properties, they need to reason about the state transitions for all the packets due to their representation.  Human efforts is high
%\item DISEL: horizontal composition. They argue that they can reuse their verification when it combined with other protocols. But, they cannot support vertical composition, which seems that they only can verify multiple distributed systems together if they are clearly divided.
%\item OOSPLA17, PLDI18 (automations): OOSPLA17 cannot generate the the runnable code. they cannot be linked with executable code, which is desired - they works with Paxos variants well, but have questions about other distributed systems. For PLDI18, they argue that they verified Raft and MultiPaxos, but for the MultiPaxos, they are unclear that what they have proved. they are not able to verify network reduction like Ironfleet, and they are not able to support concurrency yet (but.. I need to recompare PLDI18 paper again. PLDI18 paper also assume the all synthesis as a TCB
%\end{enumerate}
%}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% some brain storming
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Distributed protocol is important but complex:\\
%Several works verify distributed protocols either using automated tools or using interactive theorem provers\\
%people knows that interactive theorem provers are subtle\\
%But, it has benefits:\\
%Not even with its expressiveness, we can connect protocol layer verification with the low-level implementation \\
%Also, re-usability can be achieved using contextual refinement - this one cannot be achieved by automated system (contextual refinement)
%
%And, Paxos, immutability, is actually unbounded.
%In this sense, it is a little bit hard for automated approaches to prove that one in general (need to check PLDI18 and OOPSLA 17 papers)
%
%We want to claim that the complexity is not because of using interactive theorem prover,
%
%We propose  a way that dramatically simplify the proof of distributed system
%
%1. witness passing \\
%2. global transition system \\
%3. simple enough to understand the distributed system in a few minute \\
%4.compositionality \\
%5. and other benefits (link the proof with low-level implementation )
%
