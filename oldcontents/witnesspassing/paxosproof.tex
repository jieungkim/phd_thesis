% paxos verification example

\section{Paxos Verification}
\label{sec:paxos-verification}

As a running example of our approach, 
we implement Paxos using C, 
and then prove functional correctness and safety of our implementation using Coq.
Figure~\ref{fig:paxos-proposer-example} shows the source code for slightly 
optimized version of 
Phase 1 (Prepare) of Paxos  (in  Fig.~\ref{fig:paxos-pseudocode}
with  multiple auxiliary functions in underlying layers. 
Due to the space limit, we focus on those two functions in this section.
The whole implementation can be found in the follow site: \url{https://sites.google.com/site/witnesspassing/}.


\begin{figure}
\begin{minipage}{\linewidth}
\noindent
\begin{multicols}{2}
\lstinputlisting[numbers = left, language = C]{source_code/paxos_verify_example.c}
\end{multicols}
\end{minipage}
\caption{Parts of Paxos Implementation to build  $LPAX_{impl}[i]$}
\label{fig:paxos-proposer-example}
\end{figure}

\newcommand{\paxset}{\mathrm{SET}_{\mathrm{Paxos}}}
\newcommand{\paxpropset}{\mathrm{PSET}_{\mathrm{Paxos}}}
\newcommand{\paxaccset}{\mathrm{ASET}_{\mathrm{Paxos}}}

\subsection{Environment}
\label{subsec:environment}

Verifying Paxos requires assumptions on environment.
We assume there is an arbitrary number of acceptors and proposers in the system.
Each acceptor or proposer use unique integer number as their node identifiers, and two sets for node identifiers of acceptors and proposers
are represented by $\paxaccset$ and $\paxpropset$, respectively. 
For the simplicity,  we have omitted leaner in the system.
We also assume that the network communication can trigger packet duplication, delay, reordering, and loss as our network model assumes. 

We assign five channels for the communication of Paxos verification. 
The first channel is for the communication from proposers to acceptors. 
Proposers can add send packets and acceptors can add receive packets in the channel. 
The second  and the third  are 
for the communications from acceptors to proposers and between proposers, respectively.
The third is for the distributed applications based on our verified Paxos. 
We briefly discuss how we use them in Sect.~\ref{subsec:extensibility-of-verified-paxos}.
The fourth channel is for writing ghost packets.
In our implementation, only proposers can write ghost packets in this channel because acceptors do not have any purely local transitions.
The last one is the reserved one for other services in the future, and it can be divided into multiple subchannels later.

We do not assume the possibility of message corruptions as well as the existence of adversaries. 
All nodes that are participated in Paxos in our implementation are either acceptors or proposers, and they are honest.


\subsection{Functional Correctness}
\label{subsec:functional-correctness}

Verifying functional correctness is based on the  CCAL
as discussed in Sect.~\ref{subsec:link-with-low-level-code-verification}.
The bottom layer based on the node $i$, $LPAX_{btm}[i]$, works as shim of our verification that contains network related primitives 
including ``send'' and ``receive''.
Based on the bottom layer, 
the purpose of functional correctness proof is providing 
the abstraction layer,  $LPAX_{impl}[i]$, which contains the primitives that 
corresponds to the functionality of Paxos,
``prepare'' and ``write'' primitives for proposers and 
accept handlers that can be divided into ``prepare handler'' and ``accept handler'' primitives for acceptors.

The layers for the functional correctness proof are divided into three parts.
The first part is for the abstraction of Paxos related local states. 
Those layers add several setter and getter primitives that access 
the local states such as \texttt{get$\_$paxos$\_$rnd} and  \texttt{set$\_$paxos$\_$rnd} in the Fig.~\ref{fig:paxos-proposer-example}.
The second is for the functional correctness of the implementation of acceptor handlers, and the top-most layer of the second part provides primitives for accepter handlers including \texttt{prepare$\_$handler} in it. 
The last part is for providing the abstraction layer that contains primitives corresponding to the implementation of proposer's functionality, 
and the top-most layer of the third part is $LPAX_{impl}[i]$, which contains all primitives 
related to Paxos in it. 

This process also includes network reductions.
Two kinds of network reductions has been done while 
building layers for proposer's codes,
and they are exactly same with the network reductions in Fig.~\ref{fig:network-reduction}.
The interface for the one of them are shown in the Fig.~\ref{fig:paxos-proposer-example}, 
\texttt{broadcast}. 
The primitive only record one send packet from $i$ and other multiple packets via the result of the environmental context 
in the network history, while the underlying implementation performs multiple 
send operations to broadcast the same messages to all acceptors.

As a result, we provide the theorem 
that shows the implementation of Paxos ($Pax_{impl}$) plus a program $P$ in C or Assembly running on the shim layer $LPAX_{btm}[i]$ faithfully refines  the program $P$ running on $LPAX_{impl}[i]$.
The functional correctness theorem is formally defined in Thm.~\ref{thm:contextual-refinement}.

\begin{theorem}
\label{thm:contextual-refinement}

\noindent$\forall{}P.\sem{LPAX_{btm}[i]}{Pax_{impl} \oplus P} \refines_R \sem{LPAX_{impl}[i]}{P}$
\end{theorem}

\ignore{
The set also can be used when we distinguish the communication channel too. 
By using the set, layers can horizontally combined layers that are disjoint and one of two is 
for acceptors and the other is for proposers. 

The layers for the acceptors only required us to build two layers due to its simplicity. 
For the proposers, however, broadcast and wait$\_$quorum involves multiple network communications in them, and it requires the simplification of network log and environmental context discussed in Sect.~\ref{subsec:link-with-low-level-code-verification}. 
Two simplifications has been used, in the broadcasting  and the busy waiting. 
Both contains the loop in their implementations and it could increase the complexity of the 
global state transition machines if they exist in the high-level specifications. 
To reduce the complexity, we have simplified the log and the environmental context in two places. 

}

\subsection{Write-Witness-Passing Semantics in Paxos}
\label{subsec:witness-passing-semantics-in-paxos}

Functional correctness proof using contextual refinement provides a way to show that our implementation is correct and matched with the specifications. 
It also provides a certified abstraction layer $LPAX_{impl}[i]$ that contains the all primitives related to Paxos in it.

The next step is introducing the distributed transition semantics with write-witness-passing 
via two separate steps discussed in Sect.~\ref{subsec:distributed-transition-semantics} and Sect.~\ref{subsec:distributed-transition-semantics-with-witness-passing}.
To provide them, we define the network replay function $(\replay_{PAX})$ that handles all necessary cases for Paxos. 
For example, 
the following case in the replay function:
\lstinputlisting[numbers = left]{source_code/paxos_acceptor_case.v}
corresponds to the \texttt{prepare$\_$handler} in Fig.~\ref{fig:paxos-proposer-example}, and thus the 
high-level specification of the aceptor handler  primitive in  $LPAX_{impl}[i]$.

We also introduce two ghost packets that help us to build the replay function. 
One of them is related to \texttt{set\_new\_rnd} and  \texttt{qrm\_prepare\_reset}   
in Fig.~\ref{fig:paxos-proposer-example}, which locally increase 
the round number of node $i$ and initialize the local state before 
starting the prepare phase. 
By following this approach, building the layer $LPAX_{abs}[i]$, which enables us to 
calculate all local states for the node in $\paxset$ ($\paxset = \paxpropset \uplus \paxaccset$), is possible.

Adding the write-witness in the definition of $LPAX_{abs}[i]$
is the next step of our write-witness-passing style verification. 
Adding the write-witness is how we instantiate the variables and abstract functions in Fig.~\ref{fig:witness-witness-formal}.Some of them
The concrete definition of some of those variables and functions are as follows:
\begin{itemize}
\item $\termnum$: The ballot number in Paxos is the round number. Round numbers are elements of natural numbers, thus 
they are totally ordered. 
\item $\dstate$: In our implementation, the stored value is unsigned integer numbers. This is for the simplification. Using the value with more
complex types are possible for the $\dstate$.  
\item $\nodeid$: we use  integer numbers as node identifiers. 
\item $\accsset$: $\paxaccset$, which is a set that contains all node identifiers for acceptors in the system. The value can be treated as 
a constant value in our Paxos verification because our implementation does not allow reconfiguration.
\item $\witness_{\mathrm{el}}$ : The instantiate of this witness element is possible by using the above definitions. Among the all fields in 
the witness, we remove $\accsset$ for this Paxos verification because that is a constant value.
\item $\isquorums$: The concrete definition for Paxos is checking the cardinality of the set $accs$ according to the 
the cardinality of $\accsset$. If the number of elements of $\accsset$ is $2N + 1$, the number of elements in $accs$ 
needs to be bigger than  $N + 1$ if the write attempt wants to proceed its operation.
\end{itemize}

We provide all of those definitions in our implementation. 
For example, the followings are for ``$\isquorums$'', ``$\witness_{\mathrm{el}}$'', and ``$\witness$`` written in Coq:
\lstinputlisting[numbers = left]{source_code/paxos_witness_definition.v}

With the instantiated definitions, we also define  the network replay function $(\replay_{PAX\witness})$ that returns the state with the following type,
$$\mbox{option} \ \{\lstate{{PAX\witness}_i}~\vert~ \forall i.\ i \in \paxset\} \ \ \ \ \ \ \ (\mbox{where}\ \lstate{{PAX\witness}_i} : 
(\mathbb{N} \times \mathbb{N} \times \mathbb{Z} \times \witness))$$
,and also possible to build the layer $LPAX_{abs\witness}[i]$ that uses the network replay function, $(\replay_{PAX\witness})$.
Providing the contextual refinement theorem from the bottom layer to the layer is also possible, and the theorem is
stated in Thm.~\ref{thm:contextual-refinement-witness}.

\begin{theorem}[Contextual Refinement]
\label{thm:contextual-refinement-witness}
\noindent$\forall{}P.\sem{LPAX_{btm}[i]}{Pax_{impl} \oplus P} \refines_R \sem{LPAX_{abs\witness}[i]}{P}$
\end{theorem}


\subsection{Paxos Safety}
\label{subsec:paxos-safety}

The main safety property that we verify with our implementation is about the consistency in the consensus which 
is stated in Thm.~\ref{thm:immutability}.

\begin{theorem}[Immutability]
\label{thm:immutability}
Assuming that there are two nodes  $i$ and $j$, which are members of $\paxpropset$,
and the corresponding local states are  $\lstate{PAX\witness_i}$ and 
$\lstate{PAX\witness_j}$, respectively.
If both nodes succeed in the Phase 2 (Write) of Paxos, 
the stored value in both local states are same, which can be stated as\ $\lstate{PAX\witness_i}.\dstate  = \lstate{PAX\witness_j}.\dstate$.
\end{theorem}

Proving the theorem requires two important sub lemmas. 
The first one is related to the uniqueness of the write attempt with a particular ballot number, $\termnum$.

\begin{lemma}[write$\_$once]
\label{lemma:write-once}
Let's assume that there are two write send packets, $\msg_{\witness_1}$ and $\msg_{\witness_2}$
in the network ${\networklog}_{\witness}$. 
If those two messages are associated with the same round number $\termnum$, 
their messages are same as stated as $\msg_{\witness_1} = \msg_{\witness_2}$.
\end{lemma}

Proving the lemma is related to the fundamental property of $\termnum$.
Since all ballot numbers are unique as discussed in Sect.~\ref{subsec:distributed-transition-semantics-with-witness-passing}, 
We can prove that there will be only one write message in the network history that corresponds to the particular ballot number. 
The proof of this lemma does not facilitate the properties of  write-witness-passing. 
The next and the most crucial lemma, however, use properties of  write-witness-passing in the proof.

\begin{lemma}[write$\_$lift]
\label{lemma:write-lift}
Assuming that there is a round number $\termnum_1$, which succeed the write on majority of acceptors with the messages
$\msg_{\witness_1}$ 
Then, for all write attempts associated with the round number $\termnum_2$ always try to write  
the same value on acceptors when $\termnum_1 < \termnum_2$, which is stated as 
$\msg_{\witness_1}.\dstate = \msg_{\witness_2}.\dstate$.
\end{lemma}

Proving the lemma requires the induction on all write attempts between $\termnum_1$ and $\termnum_2$. 
To apply the induction on the number of write attempts, we make an auxiliary function, \texttt{nth$\_$send} as follows:
\lstinputlisting[numbers = left]{source_code/nth_send.v}


Proofs using the number achieved by  \texttt{nth$\_$send} implies that all cases are associated with a particular write attempt. 
In particular, 
for each write attempt in between $\termnum_1$ and $\termnum_2$,
we need to prove that 
there is a proper witness for the write in the network history, 
which satisfies the fact that the witness is  a subset of acceptors that raise the quorum
as well as the fact that the value of $\msg_{\witness_2}$ comes from the acceptor who is a participant of the quorum. 

To prove them, we facilitate generic properties of our write-witness-passing for Paxos,
which is the instance of the properties in Fig.~\ref{fig:witness-witness-formal}.
Those properties can be achieved with the refinement when adding witnesses in our states. Thus we do not need to search all the network history to find out them. 

As have shown in this section, 
our safety proof mostly relies on local aspects of the distributed systems. 
One lemma, Lemma~\ref{lemma:write-once} require us to 
prove global invariant of the distributed protocols, 
but other parts do not need  global reasoning at all because 
each write-witness provide the proper projection from the whole network history to the pieces of evidence regarding 
the attempt. 
Besides, 
proofs do not need any complex case analysis 
for network errors such as packet duplication, reordering, and lost.
Whatever some of those errors occur with the write attempt, 
each write always have the valid write-witness that always satisfy the generic properties. 
In this sense, write-witness-passing makes our proofs tremendously easy.  

\ignore{
\begin{theorem}[Contextual Refinement with Immutability]
\noindent$\forall{}P.\sem{L_{abs}[i]}{Pax_{impl} \oplus P}$
\end{theorem}
}

\subsection{Extensibility of Verified Paxos}
\label{subsec:extensibility-of-verified-paxos}

Distributed system verification has a high cost compared to design and implementation.
Some distributed systems, however, are usually served as bases of other distributed systems. 
For example, Paxos usually works as a tool to provide consensus for other distributed programs.
Thus, providing the extensible proofs for them are desirable. 
Our verification approach provides extensible, scalable, and reusable proofs not only for the functional correctness but also for safety properties. 

The immutability property provides that all state transitions in $\sem{LPAX_{abs\witness}[i]}{P}$ with a program $P$ always preserve consistency related to the Paxos states. 
In the layer, there are no direct transitions that modify the Paxos states except the transitions with the replay function,  $\replay_{PAX\witness}$.
Therefore, the layer built on the of the layer can access the states related to Paxos by only calling the primitives that use $\replay_{PAX\witness}$.
Thus, the above layers on $LPAX_{abs\witness}[i]$ always satisfy consistency property regardless of the program $P$. 

