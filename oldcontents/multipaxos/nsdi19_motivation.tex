\section{Background}

\subsection{A Least Common Denominator API}
\label{sec:sysbackground}

\cuttext{
\begin{figure}
\centering
\includegraphics[page=4]{pics/pics-small.pdf}
\caption{The \WOR{} decouples high-level abstractions from low-level protocols (grayed arrows). \label{fig:abstractions}}
\end{figure}
}

We stated that various systems hide \WOR{} functionality behind high-level APIs. We examine different classes of systems\cuttext{; Figure \ref{fig:abstractions} shows the relationships between them} to make two points: most systems are similar in their use of a \WOR{} kernel; but they hide it behind APIs that hinder flexibility, reusability, and performance. While some of these APIs can be implemented over each other, none of them acts naturally as a lowest common denominator for all others. The \WOR{} fills this gap.

% (e.g., coordination APIs are often implemented over a State Machine Replication API)
%We classify each API as low-level, intermediate-level, and high-level. 

%\medskip
%\smallskip
%\noindent 
\textbf{State Machine Replication (SMR) / Multi-Paxos} systems allow arbitrary (but deterministic) application code to be replicated, via an interface that allows servers to propose new commands and learn them via an upcall. The SMR API is general and easy to use; however, it limits applications by not exposing the underlying address space of \WORs{}. In a sense, SMR imposes a sequential write / sequential read interface on an address space of \WORs{}. The SMR interface can be implemented via multiple protocols; in the other direction, however, Multi-Paxos protocols are exclusively used to support an SMR interface.%, and designed for the sequential write / sequential read API.

%\medskip
%\smallskip
%\noindent 
\textbf{Shared logs} provide an append/read API to applications. Unlike in SMR, applications can directly read from \WOR{} instances, examining the history of commands. However, as with SMR, applications cannot directly write to \WOR{} instances; all writes must be funneled through the shared log API, which imposes a total order on commands. In effect, a shared log imposes a sequential write / random read interface on an address space of \WORs{}.

%\medskip
%\smallskip
%\noindent 
\textbf{Group communication (GC)} systems allow sending messages to groups of servers; each message is atomically delivered with ordering guarantees. Each slot in the total or partial order of messages to the group is effectively a write-once register; the message send primitive acts as a write operation. As with SMR, the GC send/receive API can be viewed as imposing a sequential write / sequential read interface on an address space of \WORs{}.

%\medskip
%\smallskip
%\noindent 
\textbf{Coordination services} (e.g., Chubby and ZooKeeper) typically expose a filesystem-like API to applications. Such an API is ideal for use cases such as membership management and leadership election, but is awkward at best for the replication of arbitrary data or general-purpose ordering of commands. These systems are usually implemented over SMR, GC, or shared log APIs. 

%\medskip
%\smallskip
%\noindent 
\textbf{Transaction coordinators} are responsible for coordinating transactions across distributed state. In effect, they are manipulating a set of \WORs{}, each one representing the prepare/abort decision for a participant so that an atomic commit happens across the system. Concurrency control is usually implemented via an orthogonal mechanism such as locking. 
%Interestingly, transactions can be implemented over a shared log as well, in which case the order of the \WORs{} in the log acts as a source of timestamps for concurrency control.
%\nsdijy{
%Interestingly, transactions can be implemented over a global shared log, in which case the order of the \WORs{} in the log acts as a source of timestamps for concurrency control. Depending on the implementation, the API can impose both sequential and random write and read on an address space of \WORs{}.}
% or multiple partitioned logs (per data or per partition)

%\smallskip
%\noindent
\cuttext{
\textbf{Log-structured filesystems} typically layer write-once behavior over a conventional address space. While this layering was originally intended to exploit disk sequentiality,
% (and subsequently, to tolerate flash idiosyncrasies),
%log-structured filesystems routinely leverage the write-once nature of the address space to provide failure atomicity, multi-versioned access, fast cloning, consistent mirroring, and historical snapshots. In such systems, the write-once semantics are implemented by the filesystem via locking, indexing, and write-ahead logging.
log-structured filesystems routinely leverage the write-once nature of the address space to provide failure atomicity, multi-versioned access, fast cloning, consistent mirroring, and historical snapshots. In such systems, the write-once semantics are implemented via locking, indexing, and write-ahead logging.}

%Although the \WOR{} concept had been explored for theoretical reasoning by others (Section~\ref{}), we identify the \WOR{} as the least common denominator ``programming" abstraction that can enable easy and efficient construction of the systems described above.
We argue that \WORs{} represent a least common denominator interface: all the systems described above can be implemented easily and efficiently over a \WOR{}.% We now describe \sysname{} and the \WOR{} abstraction.}
%We argue that \WORs{} represent a least common denominator interface: all the systems described above can be implemented easily and efficiently over a \WOR{}.% We now describe \sysname{} and the \WOR{} abstraction.}
% it offers applications.

%CS	--> SMR (
%	--> SL
%	--> GC (ZooKeeper)
%BS	--> SMR
%	--> SL


%\begin{figure}
%\begin{center}
%    \begin{tabular}{ | l | l | l | l | l |}
%    \hline
%    System & Durability & Concurrency Control & Failure Atomicity & Consistency\\ \hline
%    LFS & Yes & No & Yes & No\\ \hline
%    SMR & Yes & Yes & Yes & Yes\\ \hline
%    \hline
%    \end{tabular}
%\end{center}
%\caption{Different systems and their use of WORs}
%\end{figure}

