\section{Extensibility of Write-Witness-Passing Semantics}
\label{sec:witness-passing-semantics-with-paxos-variants}
In this section we sketch how write-witness-passing can be applied to several distributed systems.
We mention how our write-witness-passing help the verification of variants of Paxos as well as other distributed protocols.

\subsection{Multi-Paxos}
\label{subsec:multi-paxos}
Paxos as it was originally presented only reaches consensus for a single value, but real systems
typically need to decide values for a set of slots.
These multiple-decision versions of Paxos are broadly referred to as Multi-Paxos, and although there
are many variants, they share some common features.
The simplest implementation is to run a new instance of Paxos for each slot, but better performance
can be achieved by choosing a node to be the leader.
Choosing a leader requires a consensus algorithm itself, but once one has been elected, if it is
guaranteed to be the only node trying to write to a set of slots, then it can skip the prepare phase after the
first round.

Because the safety of Multi-Paxos depends on very similar invariants to Single-Paxos, witness-passing
also works in much the same way.
The witnesses collected from the prepare phase remain the same, but now they will be reused in multiple
writes.
To demonstrate that this is safe, the leader should be able to prove that it actually won the election.
We can use witnesses again for this purpose, but this time they are collected from the participants in the
leader election instead of the acceptors.
How exactly the leader is given these witnesses depends on the details of the leader election algorithm,
but, by the end of the election, it should have evidence that shows it received enough votes to win.

\subsection{Vertical Paxos}
\label{subsec:vertical-paxos}
Paxos is designed to tolerate some amount of node failures, but each crash brings the system closer
to this threshold.
It is therefore desirable to allow the system to be reconfigured by adding new nodes and replacing
old ones.
In standard Paxos this can only happen between writes to different slots, never between rounds for
the same slot.
Vertical Paxos \cite{vertpaxos} is designed to support dynamic reconfiguration of acceptor and leader nodes,
where dynamic means consecutive rounds for the same slot can have different configurations.
Configurations are decided round-by-round by a separate master process and include the set of
acceptors and the single leader to be used that round.
Unlike standard Paxos, Vertical Paxos allows the quorums of acceptors for the prepare and write
phases to differ with the restriction that all write quorums must have a non-empty intersection
with all other quorums.
The common case is to let every acceptor be a prepare quorum on its own, which implies that the only
possible write quorum is the set of all acceptors.
The main challenge that dynamic reconfiguration introduces is that leaders must learn what value an
acceptor from an earlier round and possibly a different configuration voted for.
This can prevent removing old acceptors from the system because they might still need to be consulted in the
prepare phase of a later round.
To solve this, the master process tracks the highest \emph{complete} round number, which is a round
in which a value was successfully written, or one where any value can be proposed.
With this extra information, the leader is guaranteed to only have to communicate with acceptors from
rounds as most as early as the last complete round, so older acceptors can safely be removed from the system.

Vertical Paxos is a variant of Multi-Paxos, so write-witness-passing can be used in largely the same way
as before for the communication between a leader and the acceptors.
The key difference is in the communication between a leader and the master process.
To guarantee that a write is safe, the max complete round sent to the leader must actually be complete.
If the master, in addition to sending the complete round number, also sends a witness demonstrating its
completeness, then checking that this invariant holds during verification becomes almost trivial.
The master would update this witness every time it updates the max complete round by simply storing the
message indicating that a successful write just took place in that round.

\subsection{Raft}
\label{subsec:raft}
Raft \cite{raft} is an alternative to Paxos with leader election and reconfiguration built in.
Every node stores a log of commands along with the terms in which they were decided.
New commands are proposed by clients to the leader, which attempts to get the other nodes to store
that command in their logs.
Initially all nodes begin as candidates and an election round begins with one of them broadcasting a
request for votes along with its current term number, the length of its log, and the term of the last
element of its log.
Each node votes yes if it has not already voted this term, the candidate's term is larger than its
own, and the candidate's log is at least as up-to-date as its own.
A candidate becomes the leader when it receives a yes vote from a majority of nodes, at which point
it begins sending out heartbeats with its term number to inform the other nodes of the result of the
election.
To replicate a log entry, the leader broadcasts a message with its term, the new values to be
replicated, and the index and term of the log entry just before the new ones.
A follower can reject the request if the leader's term is too small, or if its own log does not match
the leader's at the index before the new values.
Otherwise it updates its log by first deleting any entries that conflict with the new values as
well as everything that follows the conflict, then appending the rest of the new values that are not already in the
log.
Reconfiguration in Raft is handled by first switching to a joint configuration that contains the union of the nodes
from both the old and new configurations.
Configuration changes are communicated as log entries and are replicated as normal except that consensus now requires
agreement from a majority of nodes in the new configuration.
Once the leader sees that the joint configuration has been committed, it can try to commit the new configuration,
and only when that has succeeded can old nodes be removed.

Write-witness-passing can be applied to all three of Raft's main components.
In leader election, each node includes a witness with a copy of its log in its vote so it is easy to check that a
new leader must have in its log all the values committed by a majority of nodes up to that point.
Witnesses also include the logs during replication, which guarantees that a majority of the nodes' logs match the leader's exactly for
the newly committed entries and the terms match for the previous entry.
Maintaining the invariant that only one value can be decided per term implies that the entire
log must then be the same.
Because reconfiguration reuses much of the machinery from log replication,
the write-witness-passing technique can also be reused without much change.
The main modification that must be made is that upon a configuration change,
the witnesses' definition of $ASET$ (see Figure \ref{fig:witness-witness-formal}) must be updated.

\subsection{Other Systems}
\label{subsec:other-systems}
Write-witness-passing is an effective reasoning tool even for distributed systems other than Paxos variants.
\ignore{ % Chain Replication doesn't fit this pattern so maybe it's just confusing to say this
Any system that fits the pattern of broadcasting a request then collecting responses can benefit
from witness-passing.
}
For example, two-phase commit is a protocol where a single coordinator tries to atomically commit a
transaction among multiple participant nodes.
Similar to Paxos, in the first phase the coordinator tries to get confirmation that the transaction
can be committed by asking each node.
If every node responds that the command is valid locally, then the coordinator sends back a
commit message; otherwise it tells the participants to abort and roll back the transaction.
Using write-witness-passing, the responses from the participants would contain a piece of their
state as evidence that the transaction is valid.

Another system that write-witness-passing fits into is chain replication \cite{chainreplication}.
In this protocol, all writes are sent to a single head node.
The head then forwards the value to the next node in the chain, which continues passing it down
until it reaches the tail.
Reads can only be performed at the end of the chain, so a value is ``committed'' once it reaches the
tail.
A witness in this case could contain the sequence of write messages from all of the earlier nodes in
the chain.
This would make it clear that the value stored at the tail is the same as the one from the original write message.


\ignore{
\subsection{Extensibility of distributed protocols}

Most distributed transactions assume correctness of underlying consensus protocols to guarantee the basic safety. 
In this sense, re-usability of the proofs as well as implementations are desirable.
We use \textit{contextual refinement} approach to enable this extensible feature of our verification.

\jieung{This section may be mostly related to contextual refinement...}
\ignore{
\jieung{EPaxos}
\jieung{2PC}
\jieung{CorfuDB}
}
}