\section{Introduction}

\bulletpoint{this paragraph rambles; what do we want to say?}

%Modern distributed applications are composed of distributed systems that provide replication, logging, and transactions to achieve properties such as durability, concurrency control, failure atomicity, high availability, and strong consistency.
%While the high-level APIs and implementations of such systems vary widely, the properties provided by them and the protocols used to provide the properties are similar. 
%Still, developers re-implement the system in slightly different ways to obtain different APIs and performance characteristics despite the difficulty of implementing distributed systems correctly.

Cloud-scale platforms offer developers a number of storage and coordination services that expose simple, data-centric interfaces. At first glance, these services are diverse: they provide different APIs such as key-value stores, block stores, shared logs, object stores, and filesystems. However, the protocols used by these systems to provide properties such as durability, failure atomicity, consistency, and concurrency control are quite similar. Thus, codebases are often highly redundant, re-implementing protocols such as Paxos~\cite{paxos} and Two-Phase Commit (2PC)~\cite{2PC} with slight variations. Each variation leads to different APIs and performance characteristics, but can introduce subtle code and protocol bugs.

\bulletpoint{we introduce the WOR}
In this paper, we explore a data-centric abstraction for distributed systems called the write-once register (WOR). The \WOR{} has a simple API: a client can \textit{\prepare{}} a \WOR{}; \textit{write} to a captured \WOR{}; and \textit{read} the \WOR{}. The \WOR{} offers linearizable consistency and is safe for concurrent accesses: if multiple clients attempt to \prepare{} and write the same \WOR{}, only one will succeed.

%Because distributed protocols that offer strong semantics are hidden behind the simple API, a verified \WOR{} can facilitate verifying distributed systems that use the \WOR{}.

\WORs{} can be naturally implemented via the Paxos protocol (with modifications to support quorum reads), offering durability and availability against a minority of storage servers failing. In fact, the \WOR{} \api{\prepare{}}/\api{write} API mirrors the phases of single-shot Paxos. \WORs{} can also be implemented via other protocols such as Primary-Backup or Chain Replication~\cite{chainreplication}, obtaining different durability and availability guarantees.

%\WORs{} can be naturally implemented via the Paxos~\cite{paxos} protocol (with a first-class quorum read support), offering durability and availability against a minority of storage servers failing. In fact, the \WOR{} \api{\prepare{}}/\api{write} API mirrors the phases of the single-shot Paxos protocol. \WORs{} can be implemented via other replication protocols such as Primary-Backup or Chain Replication~\cite{chainreplication}. %They can also be implemented over existing key-value stores such as SimpleDB~\cite{simpledb} via conditional put operations, in which case they offer the durability and availability guarantees of the underlying store. Fast, volatile \WORs{} can be implemented on a single in-memory server, while \WORs{} offering single-node durability are a natural fit for new forms of NVRAM~\cite{crosspoint}.

\nsdinew{
Most distributed services embed \WORs{}, but hide them underneath a higher-level API:}
\begin{itemize}[leftmargin=*]
\item{\textbf{\textit{A sequence of \WORs{}}} is often used to impose a total order, but hidden behind restrictive interfaces such as replicated state machines~\cite{smr, rvrpaxos}, shared logs~\cite{corfu}, groups~\cite{GC, horus}, namespaces~\cite{chubby, zookeeper}, filesystems, databases~\cite{hyder}, or objects~\cite{tango}. Often, the implementation of the \WOR{} is fused with the machinery that implements the high-level API.}
\item{\textbf{\textit{A set of \WORs{}}} represents decisions taken by participants in distributed transaction protocols such as 2PC; the final commit decision for a transaction is a function of these \WORs{}. In fault-tolerant protocols, each decision \WOR{} is either layered inefficiently over a replicated state machine, or entwined with a transaction coordination logic~\cite{gray:2006}.} %the logic for coordinating transactions~\cite{gray:2006}.}
\end{itemize}

%Our proposal is unsurprising from a theoretical viewpoint: prior work has pointed out the equivalence of consensus and a write-once register~\cite{herlihy1991wait,stickyregister}.

%We argue that the \WOR{} should be a first-class system-building abstraction. By providing single-shot consensus via a simple yet versatile data-centric API, the \WOR{} acts as the bottom layer in a modular stack for building strongly consistent distributed systems. The resulting modularity has two benefits. First, it enables \textit{simple} systems: the code and logic for consensus can be provided by a small number of high-quality implementations (e.g. Paxos and Chain Replication) and reused across different systems. Second, it enables \textit{verified} end-to-end systems: with a portable layered verification approach~\cite{deepspec}, the \WOR{} implementation can be verified once and layered over a verified operating system (e.g., CertiKOS) to enable full-stack verification from the application to the OS. Applications above the \WOR{} abstraction can be implemented and verified easily without dealing with the complexity of distributed asynchrony and failures. 
We argue that the \WOR{} should be a first-class system-building abstraction. By providing single-shot consensus via a simple yet versatile data-centric API, the \WOR{} acts as the bottom layer in a modular stack for building strongly consistent distributed systems. The resulting modularity has two benefits. First, it enables \textit{simple} systems: the code and logic for consensus can be provided by a small number of high-quality implementations (e.g., Paxos and Chain Replication) and reused across different systems. Second, it enables \textit{verified} end-to-end systems. With a portable layered verification approach~\cite{deepspec, concurrency}, the \WOR{} implementation can be verified once and reused for the verification of applications that use the \WOR{}. The application can be verified easily without dealing with the complexity of distributed asynchrony and failures. Also, the \WOR{} can be layered over a verified OS to enable full-stack verification from the application to the OS. 
%The WOR abstraction encapsulates all the complexity related to
%distributed protocols, while all code above the WOR consists of simple
%data-centric commands on WOR instances.

%with a portable layered verification approach~\cite{deepspec}, the \WOR{} implementations can be verified once and  combined with a layered OS and distributed system to enable full-stack verification from the application to the hardware.

%the resulting end-to-end systems can themselves be verified using a portable layered verification approach~\cite{deepspec} that results in full-stack verification all the way from the application to the hardware. 

% We posit that separating the \WOR{} cleanly from the remainder of the system and exposing it as a programming abstraction can simplify existing systems while making it easier to construct new systems.  

% the first-class system-building abstraction, the correctness of a \WOR{}'s underlying implementation and protocol is crucial. Consequently, we present a formal verification of a \WOR{} implementation using a portable layered verification approach~\cite{deepspec} and show how it can be useful for verifying distributed systems.

\begin{figure}
\centering
\includegraphics[page=1]{pics/pics-small.pdf}
\caption{\sysname{} architecture: clients can access a shared address space of write-once registers.\label{fig:arch1}}
\vspace{-0.1in}
\end{figure}

%Accordingly we present the design, implementation, and verification of \sysname{} (contracted from \textbf{W}rite-\textbf{O}nce-\textbf{R}ead-\textbf{M}any Address \textbf{Space}), which provides applications with a shared address space of durable, highly available, and strongly consistent \WORs{} (see Figure \ref{fig:arch1}). \sysname{} divides the address space into contiguous write-once segments (\WOSes{}), which act as coarse-grained units for allocation, notification, reconfiguration, and garbage collection. Internally, each \WOR{} is implemented via a conventional single-shot Paxos instance; \sysname{} can be viewed as a system to organize, access, and manipulate these Paxos instances via data-centric APIs. Applications built over \sysname{} consist entirely of \prepare{}/write/read commands on the write-once address space, rather than message-passing protocols. We implement \sysname{} via a combination of a client-side library and storage servers. We formally verify both the client-side library and the server code written in C using Coq proof assistant. We verify the functional correctness of the code and the property (i.e consistency, availability and fault tolerance) that the client library and the server collaboratively achieves, and show that our verification can be linked to a fully verified OS (CertiKOS~\cite{certikos:osdi16}) to create the first fully verified software stack from the OS to distributed application layers. 
Accordingly, we present the design, implementation, and verification of \sysname{} (contracted from \textbf{W}rite-\textbf{O}nce-\textbf{R}ead-\textbf{M}any Address \textbf{Space}), which provides applications with a shared address space of durable, highly available, and strongly consistent \WORs{} (see Figure \ref{fig:arch1}). \sysname{} divides the address space into contiguous write-once segments (\WOSes{}), which act as coarse-grained units for allocation, notification, reconfiguration, and garbage collection. Internally, each \WOR{} is implemented via a conventional single-shot Paxos instance; \sysname{} can be viewed as a system to organize, access, and manipulate these Paxos instances via data-centric APIs. We implement \sysname{} via a combination of a client-side library and storage servers. We formally verify the client-side library and the server code written in C using the Coq~\cite{coq} proof assistant. We verify the functional correctness of the code, as well as distributed properties (e.g., write-once semantics) achieved collaboratively by the client library and the server code. % and show that our verification can be easily extended and linked to applications as well as a fully verified OS (CertiKOS~\cite{certikos:osdi16}).
% applications with a write-once segment abstraction (\WOS{}) that organizes collections of \WORs{} into segments for easy reconfiguration, efficient garbage collection, and fast batched operations across multiple \WORs{}.
%are easy to develop and deploy, avoiding message-passing protocols in favor of simple read/write commands on \sysname{}.

%random-read-random-write access to WORs
%separates WOR (durability, etc.); one high-quality implementation of WOR
%simplicity enables verification
Applications built over \sysname{} consist entirely of \prepare{}/write/read commands on the write-once address space, rather than message-passing protocols. As a result, they are easy to develop and verify. We implement three applications over \sysname{}: WormPaxos, a Multi-Paxos implementation; WormLog, a distributed shared log; and WormTX, a distributed, fault tolerant transaction coordinator. All these applications are built entirely over the \WOR{} API, yet provide efficiency comparable to or better than handcrafted implementations. Specifically, we do not `open the Paxos box' while implementing these applications; the logic for consensus and durability remains strictly contained within the \WOR{} abstraction. In contrast, state-of-the-art implementations for all three applications require the complex melding of Paxos logic with other protocols to obtain efficiency. Further, separating out the \WOR{} enables novel design points: for example, a shared log that uses Paxos (rather than Chain Replication) to replicate each command, supporting appends in just two round-trips in the failure-free case.
%is the 3-commit variant novel?
%; the WOR abstraction encapsulates all the complexity related to distributed coordination
%

%the single implementation of the \WOR{} abstraction in \sysname{} acts as the sole source of consistency, concurrency control, durability, and failure atomicity in the system. 
%Verification
%The WOR abstraction encapsulates all the complexity related to
%distributed protocols, while all code above the WOR consists of simple
%data-centric commands on WOR instances. \nsdijy{This separation
%comes with an added benefit: the complex protocol underlying the WOR and the applications built on top have a clear interface
%and well-structured code, making system components more modular than in a monolithic
%distributed system design.}

%We implemented \sysname{} with verification in mind: we divided the code in modular layers so that each layer can be verified and reused easily. Each layer is composed of C source code, translated C source code into coq by a verified CompCert compiler, low level specification of the code that defines how the memory state is transitioned by the code, high level specification that illustrates the high level behavior of the code, refinement proofs from high level specification to low level specification and from low-level specification to the translated code, and proofs about how the proofs in different layers link together to form a verified software system. All these correspond to the functional correctness proof, which guarantees that our code works correctly as we specified. With functional correctness we know that for example our client library and the server individually works correctly. To verify that the client and server observes a global property, for example consensus, another level of verification is necessary. Based on the high level specification, we write lemmas and theorems to verify that our high level specification of each components collectively satisfies the global property. The global property we proved are consistency (written value to wor never changes), fault tolerance (consistency is maintained as long as the majority lives), availability/liveness (System makes progress as long as the majority of servers are alive.

\sysname{} and its modular \WOR{} design facilitate verification of distributed systems. Contextual refinement, the key technique in a layered verification approach (detailed in Section~\ref{sec:background})~\cite{deepspec}, allows for the code above the \sysname{} API to be verified easily and incrementally. Applications can be verified without having to deal with the complexity of distributed coordination, which is encapsulated within the \WOR{} layer. To verify an application's correctness against \sysname{}, we simply link its proof to the top-most layer proof of \sysname{}. Similarly, we can easily link the bottom-most layer proof of \sysname{} to CertiKOS~\cite{certikos:osdi16}, a fully verified OS, enabling a verified system stack from the distributed application to the OS, excluding only the hardware and the network. The linking ensures that verified software components interact with each other correctly as verified without leaving any anomalous corner cases~\cite{shimlayer}. As a result, we can verify each layer once and reuse the proof multiple times to easily expand the verified code base.


%Verification of applications can also hugely benefit from \sysname{}. We show that contextual refinement, which is the key to the layered verification approach (detailed in Section~\ref{sec:background}), encapsulates the complexity of distributed coordination within \sysname{} and allows the application to be easily verified as non-distributed code; still, verified distributed properties in \sysname{} are guaranteed to hold in the application. Applications verified on top of \sysname{} are guaranteed to use both the client and server code of \sysname{} correctly such that they use the system interface only in a defined way and shares the same semantics about the interface with \sysname{}. Verifying the application on \sysname{} requires only linking a modular top-most layer proof of \sysname{} with the application. Similarly, we can easily link the proofs of \sysname{} to CertiKOS~\cite{certikos:osdi16}, a fully verified OS and present a verified end-to-end stack from the OS to distributed application.

%Our verification model assumes non-Byzantine network: packets can be arbitrarily delayed, lost, and/or duplicated, but never corrupted. Applications built on top of WormSpace are easy to verify: the applications can directly use the verified proof from the \sysname{} layer and do not have to verify the distributed protocols. High order logic based verification enables easy extension and migration of our proofs. Similarly, we show that our system can be linked to a verified OS, CertiKOS, easily leading an end-to-end verified software from OS to distributed system.

%Moreover, the verification of the WOR needs
%to be done only once across all applications. \nsdijy{Thus, verifying a distributed system on top of \WORs{} becomes as easy as verifying a non-distributed system.}

%the consensus algorithm underlying the
%WOR and the applications built on top have a clear interface
%and well-structured code, making them simpler to verify than a monolithic
%distributed system.

%We forked the \sysname{} code and modified a subset of it to create a
%second implementation (in particular, single-threaded clients for the
%\WOR{} and \WOS{} abstractions and the WormPaxos application) within
%the CertiKOS framework and verified the resulting software stack.


%Modularity leads to easier verification. 
%\nsdijy{We forked the \sysname{} code and modified a subset of it within
%the CertiKOS framework~\cite{certikos:osdi16} for the verification of the software stack.}
%CertiKOS is built in the Coq proof assistant~\cite{coq} and supports a layered approach for building formally verified systems in C and assembly. 
%\nsdijy{Our \WOR{} and \WOS{} designs fit very well with the layered approach, where each layer can be verified once and reused multiple times to verify layers above.}
%This opens the door to a single, high-performance codebase that is simultaneously fast and correct.

%Our implementation is the first Multi-Paxos written in a low-level language (C) where the code first Multi-Paxos written in a low-level language (C) where the code itself is fully verified. 
%\nsdijy{Our implementation is the first Multi-Paxos written in C where the code itself and the underlying OS stack are fully verified.}
%\hernan{We would have to prove that this version is "fast".}

%By simplifying the application logic, we are able
%to develop distributed systems that are simultaneously fast and correct.


% The simplicity of \WOR{} applications comes with an added benefit: since all code above the \WOR{} consists of simple data-centric commands on \WOR{} instances, the resulting code is simple to verify. While the \WOR{} implementation itself is a complex distributed protocol and difficult to verify, this needs to be done only once across all applications. In particular, we implement a Paxos-based \WOR{} and our applications within the Certikos OS~\cite{certikos:osdi16} \jyshin{(cite added) -- in addition to within Linux --} and verify the resulting software stack. By simplifying application logic, we enable distributed systems that are fast and safe; for example, our Multi-Paxos implementation is the first one written in a low-level, high-performance language (C) where the code itself is fully verified.

%\nsdijy{
%In this paper, we make three contributions:
%\begin{itemize}
%\item{We identify the \WOR{} that is not exposed in most distributed systems and present a simple, data-centric \WOR{} API as a first-class programming abstraction.}
%\item{Combining a modular \sysname{} design with layered verification approach of CertiKOS, we show that the end-to-end verification (starting from the OS layer) of a distributed system is feasible and can be easy.}
%\item{Finally, we build three popular distributed applications on \sysname{} and show that our applications perform comparable to or better than state-of-the-art implementations.}
%\end{itemize}
%}

In this paper, we make three contributions. First, we identify the \WOR{} abstraction inherent in many distributed systems and present a simple, data-centric \WOR{} API as a first-class programming abstraction. Second, we implement three distributed applications over this API; for each one, our modular design easily allows new configurations with different performance and availability properties, while matching or surpassing the performance of an existing monolithic implementation in a similar configuration. Finally, we show that the modular design of the resulting systems, when combined with the layered verification approach, facilitates the reuse of software correctness proofs, and enables verification that crosses distributed system/application boundaries.

%\nsdijy{
%In this paper, we make three contributions. First, we identify the \WOR{} abstraction inherent in many distributed systems and present a simple, data-centric \WOR{} API as a first-class programming abstraction. Second, we build three popular distributed applications on \sysname{} and show that their performance on \sysname{} matches or even surpasses that of state-of-the-art implementations. Finally, by leveraging the layered verification approach on our modular \sysname{} design, we show that the end-to-end verification (starting from the OS) of a distributed system is feasible and can be made easy.
%}
