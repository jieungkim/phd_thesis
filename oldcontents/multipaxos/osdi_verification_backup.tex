\section{Formal Verification}

\sysname was designed with a clean abstraction and modularity in mind. This
design is well suited for the verification approach of the CertiKOS
framework~\cite{deepspec, certikos:osdi16}, where
% code pieces are encapsulated
% as abstraction layers and verified once. Each layer provides an interface that
% can be called multiple times by higher layers in the stack.
one can split a system into a stack of layers and reason about each part in
isolation. Each layer can implement, for example, memory accesses or concurrency
interleavings by calling functions from the lower layer and hide its details to
the upper layer.
%layers.
%Each layer can use functions provided by the lower layers and hide its details to the upper layers.
This methodology facilitates the formal design and verification of large systems
implemented in low-level codes (C and assembly), such as operating system
kernels. CertiKOS provides Coq~\cite{coq} libraries to formally specify, verify,
and chain layers for compiling them into binary code.

We forked a minimal working subset of the \sysname{} stack to verify it in the
CertiKOS framework. It comprises the core of the system: a single-threaded
version of the Paxos-\WOR{}, \WOS{} and \wormspace{} modules. We organized the
\WOR{} into 17 CertiKOS layers, the \WOS{} into 3 layers, and the \wormspace{}
into 2 layers. The \WOR{} layers include initialization, communication, acceptor
and proposer/learner functionalities, and a fault-tolerant mechanism that
repeats the Paxos protocol up to a limit.

% CertiKOS imposes some restrictions to the C code to simplify the verification.
% For instance, functions only take integer arguments and return integers
% (including pointers), and pointers are only used in exceptional cases. In
% particular,
CertiKOS is built around (a modified version of) the CompCert verified
compiler~\cite{compcert,leroy09,deepspec}, so it accepts the same subset of C
(C99). Currently, CertiKOS does not have a network library, so we maintain the
same network interface, but use a dummy network stack implementation that can be
replaced with a network library that becomes available in the future. Also,
calling a function implemented in an upper layer is not yet supported, thus we
cannot verify the \api{listen} function of the \WOS{}.


\subsection{Proof Strategy}

We focused on verifying the essential safety properties of each
module. %\footnote{CertiKOS supports the verification of liveness properties,
% which we leave for future work.}
In the first place, we must guarantee that \WORs{} are immutable, meaning that
once a value is written to a \WOR{}, it cannot be modified.
% The immutability property of the \WOR{} is that once a value is written to a
% \WOR{}, it cannot be modified.
% More precisely, if the register stores some
% previously written value, it is only possible to rewrite the same value.
Moreover, we must assure that the owner of a \WOS{} is the only one who can
write valid data into it, that all \WORs{} in the \WOS{} up to its tail are
written, and that a \WOS{} can be allocated only once. Here we show how to
prove immutability, which is the core property of any consensus-based system.

In CertiKOS, the developer provides two related specifications: a low-level spec
that is automatically extracted from C code, and a high-level spec that mirrors
the C code but in a functional style~\cite{deepspec}. Both define the
transitions of the system state at different levels of abstraction and
granularity. When reasoning about distributed systems that are specified as
state transition systems, it is essential to find and prove inductive
invariants, which simplify the proof of the main theorems. In practice, the best
known method to verify them is through global invariants, that is, formulas that
express properties of all the system components
simultaneously~\cite{Lamport:1977}. In CertiKOS, however, one models the
execution of a single machine and its environment, so it is not possible
(without modifying the framework) to state formulas that refer both to client
and server code.

For proving the Paxos-based \WOR{}, our strategy is to find disjoint
invariants for the acceptor and the client. The client variables do not appear
in the acceptor invariants and vice versa, except for a history variable of
network messages that is common to both. Our proof includes two invariants for
the acceptor that do not mention client variables: $V_a$ is a conjunction of
properties about its internal variables, and $M_a$ refers to the messages the
acceptor sends to the environment. Similarly, we found invariants $V_c$ and
$M_c$ for the client. Then, in the proof of $V_c$ and $M_c$, we only need to
assume that $M_a$ holds: the messages the client receives have the expected
format and properties of a message generated by an acceptor. Paxos is resilient
to (non-Byzantine) network failures so the assumptions we made about the
received messages do not jeopardize the correctness proofs.

\def\tlaplus{TLA$^+$\xspace}

Finding the correct formulas for the invariants is a trial and error process
where the client and acceptor invariants affect the proof of each other. To find
them, we first specified the acceptor and the client in \tlaplus as two separate
programs and proved immutability. In \tlaplus~\cite{tlaproofs}, one does not
verify low-level code, but high-level specifications of distributed systems. Its
advantage is that it provides a model checker and more automated proof methods
than Coq, speeding up the proof writing process. The model-checker helped us to
quickly catch simple bugs, while we needed to write the \tlaplus proof to ensure that the invariants were indeed inductive.

Once we had the invariants proved in \tlaplus, we translated them to Coq and
used them in the proofs of the CertiKOS layers for the \WOR{}. We tried to
obtain a minimal set of required invariants, without redundancies: $V_a$ has 5
invariants, $M_a$ has 7, $V_c$ has 14 and $M_c$ has 6. Some of the invariants
are trivial, some were adapted from Lamport's original \tlaplus proof, while
others were carefully derived by analyzing the algorithm. Most invariants are
just required to prove other invariants, while only four are actually applied
directly during the proof of the main immutability theorem.

\subsection{Verification Beyond \sysname{}}

We consider two factors as indicators for the effort required to verify the code
above \sysname{}: the code size and the distributed nature of the code. The
implementation of the distributed consensus protocol in a \WOR{} makes the code
size to be much larger and the proof to be more difficult than the layers above.
The \WOS{} and the \wormspace{} layers are unaware of distributed protocols, so
they have small code sizes and relatively straightforward proofs. We expect that
the verification effort of applications on top of \sysname{} to be proportional
to that of the \WOS{} and the \wormspace{} layers. Indeed, code sizes of
applications we show in Section~\ref{sec:eval} are an order of magnitude smaller
than that of \sysname{} and applications mostly rely on distributed protocols
provided by \sysname{} rather than their own. Hence, we expect the verification
on \sysname{} to be much simpler than verifying a monolithic distributed
application from scratch.

%As a quick indicator of the effort required to verify the code, we consider two
%axis: the code size and the distributed or sequential nature of the programs.
%The implementation of the distributed consensus protocol makes the size of \WOR
%to be much larger than the sequential code above. This makes the proofs in \WOR
%more difficult, while they are relatively straightforward in \WOS and
%\wormspace. We expect that the verification effort of the (sequential)
%applications on top of \sysname will be proportional to that of \WOS and
%\wormspace. Indeed, the code sizes of the applications we show in
%Section~\ref{sec:eval} (Table~\ref{tbl:loc}) are an order of magnitude smaller
%than that of \sysname{}.
