\section{Related Work}

\textbf{Distributed systems:} A number of abstractions similar to the \WOR{} exist in theoretical distributed systems, including sticky registers~\cite{stickyregister}, consensus objects~\cite{herlihy1991wait}, and the Paxos register~\cite{li2007paxos}; these are abstractions for theoretical reasoning. \nsdinew{However, we propose the \WOR{} as a programming abstraction and build a system exposing the \WOR{} APIs.} Other theoretical work points out the link between fault-tolerant atomic commit and consensus~\cite{frolund2001implementing, hadzilacos1990relationship}. \nsdinew{Single writer many reader registers, which can be written multiple times, can be used to implement a \WOR{} using a protocol like Disk Paxos~\cite{diskpaxos}.}


%A number of abstractions similar to the \WOR{} exist in theoretical distributed systems, including sticky registers~\cite{stickyregister}, consensus objects~\cite{herlihy1991wait}, and the Paxos register~\cite{li2007paxos}; however, these are abstractions for theoretical reasoning, rather than for programming or code verification. Other theoretical work points out the link between fault-tolerant atomic commit and consensus~\cite{frolund2001implementing, hadzilacos1990relationship}. SWMR (single writer many reader) registers are atomic registers that support a single writer (which is allowed to write multiple times) and many readers. SWMRs can be used to implement a \WOR{} using a protocol like Disk Paxos~\cite{diskpaxos}.

%A number of abstractions similar to the \WOR{} exist in theoretical distributed systems. Sticky registers~\cite{stickyregister}
%are essentially equivalent to \WORs{}. Consensus objects are described in \cite{herlihy1991wait}; they are implemented by consensus protocols and provide functionality equivalent to sticky registers. The Paxos register~\cite{li2007paxos} is another theoretical construct relating registers to Paxos; however, it is an abstraction for reasoning rather than programming, and exposes the details of the consensus protocol rather than hiding them. Frolund and Guerraoui~\cite{frolund2001implementing} suggest implementing transactions with write-once registers. Hadzilacos~\cite{hadzilacos1990relationship} describes the difference between the atomic commit and consensus problems, pointing out that the ``decision is a write-once variable''.

%SWMR (single writer many reader) registers are atomic registers that support a single writer (which is allowed to write multiple times) and many readers. SWMRs can be used to implement a \WOR{} using a protocol like Disk Paxos~\cite{diskpaxos}.

%The Paxos Register~\cite{li2007paxos} -- this looks clearly different from what we do, but how precisely?\\
%The Paxos Register~\cite{li2007paxos} presents the classic single-degree non-Byzantine and Byzantine Paxos algorithms using the analogy of a ``register". Here, a register corresponds to the
%value stored in the acceptors, and reading and writing a register corresponds,
%respectively, to the \prepare{} and accept phases of the original algorithm.
%Place in context with Fast Paxos~\cite{fastpaxos}, Disk Paxos~\cite{diskpaxos}, Cheap Paxos~\cite{cheappaxos}. Are these different implementations of a WOR?

\nsdinew{
Distributed applications often use services that embed consensus or replication protocols, such as Chubby~\cite{chubby} and Zookeeper~\cite{zookeeper}. \sysname{} supports a more primitive abstraction compared to these services.
%Horus~\cite{horus} is a modular stack for group communication that led to a verification effort called Ensemble~\cite{ensemble}. 
Distributed transaction systems~\cite{janus, tapir} often combine transaction and consensus protocols, `opening the Paxos box' to implement optimizations. These could conceivably be implemented over the \WOR{} in similar fashion to the optimizations in Section \ref{sec:wormtx}.}

%The \sysname{} APIs could conceivably be used to implement similar optimizations without rewiring the Paxos protocol.

%rococo
%. Protocols that `open the Paxos box' cannot be directly supported by \sysname{}, but as shown with WormTX, \sysname{} APIs can enable optimizations while hiding the Paxos detail.}
%; \sysname{} can be viewed as an equivalent for Paxos-based systems. Interestingly, the modularit of Horus led to a verified group communication system called Ensemble~\cite{ensemble}.}
%; it can be used to create drop-in replacements for these services, as well as new variants with different performance and fault-tolerance properties
%\nsdijy{
%Distributed applications often use services that embed consensus or replication protocols, such as Chubby~\cite{chubby}, Zookeeper~\cite{zookeeper}, and CORFU~\cite{corfu}, as sources of consistency, availability, and durability. \sysname{} can be used similarly, but it supports a more primitive (\WOR{}) abstraction compared to these services. Therefore, \sysname{} can become the foundation not only for the applications but also for the distributed services. \sysname{} hides the details of distributed protocols under simple data-centric APIs and fills in the gap between the sophisticated protocol and its easy and flexible use.
%}
%~\cite{paxos, chainreplication, vivaladifference}
%Sinfonia implements a transactional address space~\cite{aguilera2007sinfonia}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bulletpoint{ironfleet and verdi is for standalone distsys verification. Our focus is connecting verified software pieces}
\textbf{Verification:} Applying machine-checkable formal verification to real-world systems has been actively explored in recent years. IronFleet~\cite{ironfleet} and Verdi~\cite{verdi} propose distributed system verification approaches and use Multi-Paxos/Raft as a verification target. IronFleet separates the verification into implementation, specification, and protocol layers; the first two layers are similar to a single \sysname{} layer, and the protocol layer is similar to the \sysname{} \ghostlayer{}. Verdi focuses on writing and verifying system code under an idealized network model first, and then adapting the proofs to a more realistic network model, whereas we assume an unreliable network to begin with. \nsdinew{While both papers propose a systematic way to verify standalone distributed systems, \sysname{} enables extensible verification via a modular layer-based verification approach, where the proofs can be reused and connected with new verified application layers.}

It is well known that modularity leads to ease of verification. DISEL~\cite{disel} verifies independent distributed protocols in isolation and horizontally combines them. Taube et al.~\cite{modular} explores modularity for automated distributed system verification.
Prior work has examined a layered storage system verification for crash safety~\cite{vijay,fscq, pushbuttonfs} and a modular Paxos verification~\cite{dpaxos,sdpaxos}.
%Prior work has examined layered logical storage stacks to simplify storage system verification for crash safety~\cite{fscq, pushbuttonfs,vijay}.
\sysname{} shares the same insight about modularity, but leverages contextual refinement to provide incremental and extensible verification; enables both vertical and horizontal composition of layers; \nsdinew{and verifies correctness of practical C based programs in a concurrent and distributed environment.}

%. Contextual refinement encapsulates proofs in each layer, enables both vertical and horizontal composition of layers, and facilitates verifying \sysname{} layer correctness against a high-order concurrent and distributed environment, which is simply passed as a context.
%Our verification approach can reason about different protocols independently in separate layers; our layered verification encapsulates the verification details and enable horizontal and vertical compositions. 

Formal verification plays a key role for guaranteeing the correctness of security features~\cite{vale, komodo, ironclad, expressos}. While \sysname{}'s proof does not focus on security, adding security features to the system and guaranteeing the security properties across \sysname{} and application layers is a direction for future work.  

\sysname{} uses the same CCAL approach~\cite{deepspec, concurrency} as CertiKOS~\cite{certikos:osdi16}. While CertiKOS demonstrated the power of CCAL by verifying an entire OS, \sysname{} showed that CCAL can be extended to connect verified systems and applications and \nsdinew{to model and verify distributed systems on an asynchronous network.}


%FSCQ filesystem~\cite{fscq} uses a chain of modules to verify . While \sysname{} layers mostly depend on only one layer, FSCQ modules often dependend on multiple modules for verification. Yggdrasil~\cite{pushbuttonfs} also introduces layers to verify a filesystem. While Yggdrasil verifies each layer's implementation refines the specification, the refinement relation between layers 


%There have been many efforts to verify distributed systems in the systems and programming languages communities. The approaches that have been used have different strengths, weaknesses and philosophies.

%IronFleet~\cite{ironfleet} is built on the Dafny language, which allows the developer to annotate functions with pre- and post-conditions that are automatically proved by an underlying SMT (satisfiability modulo theories) solver.
%Dafny code can be compiled into C\# and eventually into assembly~\needcite{ironclad}. The verification of distributed protocols in IronFleet requires refinement proofs among three layers: implementation, distributed protocol, and high level specifications. The verification of distributed protocols is not fully machine checked because it requires hand written proof to show that the atomic protocol step of the implementation is equivalent to an interleaved protocol steps in the real world. Also it is not clear whether the verification of a system can be easily linked to the verification of other applications or systems.
%\cmt{As far as I know, their verification style is monolithic. They did not mention about modular verification with the capability of compositions even in the sequential program modules - JK}

\cmt{Our system does handles interleaving using Coq (precisely, using our framework - JK). Linking to other application proofs is part of our design (but other software should be verified in a similar manner using the deep spec??)}
\cmt{Yes. we provide linking only when two  programs were  verified on top of our certified abstraction layer approach. Linking verified software based on different verification frameworks (e.g. certified abstraction layer and VST - Princeton -) is an ongoing research. - JK}

%Verdi~\cite{verdi} presents a distributed system verification tool chain, where developers can specify and implement the system using a functional language in Coq. The initial step of the development assumes a perfect network model and later a transformer in the tool chain converts the system for a more realistic network and fault model. The tool chain can extract executable OCaml code from the transformation. However, OCaml is rarely used to develop a high performance distributed system in real world and it is not clear whether Verdi can model and verify interleavings of atomic protocol steps that is hand proven in IronFleet and machine proved in our system.

\cmt{And, the verification in Verdi is not linked with the executable assembly code. They have to trust compiler (for the executable OCaml code) to guarantee that their running system formally refines their  specifications. - JK}

%DISEL~\needcite{DISEL} is another distributed system verification framework developed by overlapping authors of Verdi. DISEL enables multiple distributed protocols to be composed and verified in a system. DISEL lets protocols that touches disjoint states to be verified separately and later to be composed by using a send-hook that restricts the interfering behaviors among protocols. Similarly, the ghost layer in \sysname{} can compose multiple distributed protocols. Each protocol isolated by the network model can be verified independently which preserves modularity. Similar to the send-hook, the high level specification $h$ that uses multiple protocols and is used in the ghost layer can guarantee that the protocols do not interfere with each other. Such multi-protocol verification is shown in our application which employs their own distributed protocols on top of \sysname{}.

\cmt{Do we need to combine them in the ghost layer? I think providing disjointability is not tied with the specific layer but with the recv and send primitive specs in the layer. I think ``the ghost layer can guarantee that the protocols do not interfere with each other'' is a little bit confusing. Let's discuss it - JK}

% A push button verification approach, which is based on the Z3 SMT solver, was used to verify a filesystem~\needcite{} and an OS~\needcite{}. Its primary benefit is a low verification burden: careful writing of the specification for the SMT solver can automate the verification process and SMT solver yields a counter example for a failed verification. Push button verification mostly focuses on the functional correctness proofs and its tool chain that compiles the code to C or binary is not fully verified. The push button approach currently does not support verifying concurrency nor concurrent distributed systems.

%FSCQ

% Model checking exhaustively checks all possible states in the system. Because of its exhaustiveness, there is a state explosion problem.





% This work is the first to present an end-to-end formal proof of a version of
% Paxos, from a high-level Coq specification to executable C code.
% We rely on the CertiKOS framework~\cite{certikos:osdi16} for the specification,
% implementation, verfication and compilation of the \sysname applications.
%We can mention two lines of work on the verification of distributed systems
%through mechanically-checked proofs.
% There are several lines of work on verifying distributed systems through
% machine-checkable proofs. One  deals with high-level specifications languages
% for reasoning about the program logic of the algorithms, for instance, in the
% TLA$^{+}$ Proof System~\cite{lamport:2011, pastry, chand:2016}, or in
% Isabelle/HOL~\cite{diskpaxos:proof, charron:formal}. Here, obtaining executable
% code is not a priority or is not even possible.

%Recent work on the verification of distributed systems allows the extraction of
%executable code from high-level specifications. Ironfleet~\cite{ironfleet}
%compiles Dafny programs annotated with pre- and post-conditions into C\#. They
%have verified safety and liveness of a replicated-state machine library
%that supports state transfer, log truncation, dynamic view-change timeouts, batching and a reply cache,
%and a sharded key-value store. Verdi~\cite{verdi} extracts OCaml code from a Coq
%specification of the Raft algorithm.
%EventML~\cite{eventml,schiper} is connected
%to the NuPRL proof assistant and allows the extraction of classic ML.
%PSync~\cite{psync} is a program logic based on the Heard-Of model~\cite{heardof}
%with a runtime implementation embbeded in Scala. DistAlgo~\cite{distalgo} is a
%high-level domain-specific language that can be compiled into Python.
%
% More recently, generic frameworks were built for writing formal high-level
% models of distributed systems from which one can extract certified executable
% code.
%
%All of these frameworks implement some kind of stratification of its
%specifications to simplify the verification. For instance,
%Ironfleet~\cite{ironfleet} systems are organized in three layers (for the
%high-level spec, the distributed protocol and the implementation) linked by
%refinement, and the Verdi toolchain~\cite{verdi} uses what they call
%\emph{verified system transformers} to refine specifications through verified
%compilation. %While they introduce ad-hoc layers,
%CertiKOS~\cite{deepspec} provides a flexible and generic layer calculus.
%In this work we have demonstrated that it is possible to verify executable code
%of distributed systems, in particular the \sysname library, by exploiting the
%flexible and generic layer calculus of CertiKOS, even when the distributed
%programs are modeled as disjoint single-machine specifications.
%
%\nsdijy{
%These frameworks implement a stratification of their
%specifications to simplify the verification. For instance,
%Ironfleet systems are organized in three layers linked by
%refinement, and the Verdi toolchain uses
%verified system transformers to refine specifications through verified
%compilation. %While they introduce ad-hoc layers,
%CertiKOS~\cite{deepspec} provides a flexible and generic layer calculus.
%In this work we have demonstrated that it is possible to verify executable code
%of distributed systems by exploiting the
%flexible and generic layer calculus of CertiKOS, even when the distributed
%programs are modeled as disjoint single-machine specifications.
%}

% Hawblitzel et al.~\cite{ironfleet} have used Ironfleet to prove correct two
% distributed systems: a replicated-state machine library that supports state
% transfer, log truncation, dynamic view-change timeouts, batching and a reply
% cache, and a sharded key-value store. Ironfleet is a framework built around
% Dafny, a high-level language that can be compiled into C\# using the .Net
% compiler on Windows. One can annotate a Dafny program with pre- and
% post-conditions which are, in many cases, automatically proved by SMT solvers.

% Liveness properties are proved in Ironfleet by embedding the temporal logic of
% TLA$^+$ into Dafny. Dafny does not support concurrency and networking. The
% network stack is externally plugged and part of the trusted code base. In this
% work we do the same, but in CertiKOS it would be possible to eventually
% implement verified network drivers and protocols~\cite{certikos:pldi15}.
% %
% Wilcox et al.~\cite{verdi} developed the Verdi framework and used it to verify
% an implementation of the Raft algorithm (a proof of linearizability), a
% primary-backup replication system, and a distributed key-value store. Verdi is
% built in Coq, from where OCaml code can be automatically extracted.  Verdi
% allows to specify different fault models that gradually introduce failures such
% as packet drops, reordering and duplication into the specification.
% %
% Schiper et al~\cite{schiper} implemented in EventML~\cite{eventml} an atomic
% broadcast service based on Multi-Paxos and used the NuPRL proof assistant to
% verify safety.
% %
% Dr\u{a}goi et al.~\cite{psync} specified and verified a version of single-decree
% Paxos in PSync, which is based on the Heard-Of model.
% %
% Model checking is also used to verify high-level specifications of distributed
% systems. [Konnov et al. - A Short Counterexample Property for
% Safety and Liveness Verification of Fault-Tolerant Distributed Algorithms ]


% [ironfleet] Hawblitzel, C., Howell, J., Kapritsos, M., Lorch, J.R., Parno, B.,
% Roberts, M.L., Setty, S., Zill, B.: IronFleet: Proving practical distributed
% systems correct. In: Proceedings of the 25th Symposium on Operating Systems
% Principles. pp. 1–17 (2015)

% [verdi] Wilcox, J.R., Woos, D., Panchekha, P., Tatlock, Z., Wang, X., Ernst,
% M.D., Anderson, T.: Verdi: A framework for implementing and formally verifying
% distributed systems. In: Proceedings of the 36th ACM SIGPLAN Conference on
% Programming Language Design and Implementation. pp. 357–368 (2015)

% Schiper, N., Rahli, V., van Renesse, R., Bickford, M., Constable, R.L.:
% Developing correctly replicated databases using formal tools. In: Proceedings
% of the 44th Annual IEEE/IFIP International Conference on Dependable Systems
% and Networks. pp. 395–406. IEEE CS Press (2014)

% [eventml] PRL Project: EventML. http://www.nuprl.org/software/\#WhatisEventML
% (Last released September 21, 2012)

% [PSync] Drăgoi, C., Henzinger, T.A., Zufferey, D.: Psync: A partially
% synchronous language for fault-tolerant distributed algorithms. In:
% Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of
% Programming Languages. pp. 400–415 (2016)

% EventML [32] provides expressive primitives and combinators for implementing
% distributed systems. EventML programs can be automatically abstracted into
% formulae in the Logic of Events, which can then be used to verify the system in
% NuPRL [5]. The ShadowDB project implements a total-order broadcast service using
% EventML [36]. The implementation is then translated into NuPRL and verified to
% cor- rectly broadcast messages while preserving causality. A replicated database
% is implemented on top of this verified broadcast service. Unlike vard (described
% in Section 8), the database itself is unverified.
% [32] V. Rahli. Interfacing with proof assistants for domain specific programming using EventML. In Proceedings of the 10th International Workshop On User Interfaces for Theorem Provers, Bremen, Germany, July 2012.
% [5] R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. Implementing Mathemat- ics with The Nuprl Proof Development System. Prentice Hall, 1986.
% [36] N. Schiper, V. Rahli, R. van Renesse, M. Bickford, and R. L. Constable. Developing correctly replicated databases using formal tools. In Proceedings of the 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), pages 395–406, Atlanta, GA, June 2014.


% [distalgo] Y. A. Liu, S. D. Stoller, B. Lin, and M. Gorbovitski. From clarity to efficiency for distributed algorithms. In G. T. Leavens and M. B. Dwyer, editors, Proceedings of the 27th Annual ACM SIGPLAN Con- ference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2012, part of SPLASH 2012, Tucson, AZ, USA, October 21-25, 2012, pages 395–410, 2012.
