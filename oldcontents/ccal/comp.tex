\begin{figure*}[th]
\begin{small}
\begin{mathpar}
\inferrule{
  \disjointunion{m_1}{m_2}{m}
}{
  \nextblock{m} = \max(\nextblock{m_1}, \nextblock{m_2})
}(\textsc{Nb})
\and
\inferrule{
  \disjointunion{m_1}{m_2}{m}
}{
  \disjointunion{m_2}{m_1}{m}
}(\textsc{Comm})
\and
 \inferrule{
  \disjointunion{m_1}{m_2}{m}  \\
  \load{m_2}{\ell} = \some{v}
}{
  \load{m}{\ell} = \some{v}
}(\textsc{Ld})
\and
\inferrule{
  \disjointunion{m_1}{m_2}{m}
}{
  \disjointunion{m_1}{\store{m_2}{\ell}{v}}{\store{m}{\ell}{v}}
}(\textsc{St})
\and
\inferrule{
  \disjointunion{m_1}{m_2}{m} \\
  \nextblock{m_1} \leq \nextblock{m_2} 
}{
  \disjointunion{m_1}{\alloc{m_2}{l}{h}}{\alloc{m}{l}{h}}
}(\textsc{Alloc})
\and
\inferrule{
  \disjointunion{m_1}{m_2}{m} \\
  \nextblock{m_1} \leq \nextblock{m_2}
}{
  \disjointunion{m_1}{\liftnextblock{m_2}{n}}{\liftnextblock{m}{n}}
}(\textsc{Lift-R})
\and
\inferrule{
  \disjointunion{m_1}{m_2}{m} \\
  \nextblock{m_1} \leq \nextblock{m_2}
}{
  \disjointunion{\liftnextblock{m_1}{n}}{m_2}{\liftnextblock{m}{n - (\nextblock{m} - \nextblock{m_1})}}
}(\textsc{Lift-L})
\end{mathpar}
\end{small}
\caption{Algebraic memory model} \label{fig:algmem}
\end{figure*}

\subsection{Thread-Safe Compilation and Linking}
\label{sec:comp}

In this section, we show how to adapt Gu et al.'s CompCertX verified
separate compiler \cite[\S 6]{dscal15} to handle programs that call scheduling primitives.
Section~\ref{subsec:phthreadlayer} shows how thread-local layer interfaces  allow us to
give \emph{C style} specifications to scheduling primitives
($\commc{yield}$ and $\commc{sleep}$) which are partly implemented in assembly.
Thus, code of each thread can be verified at the C level over $\Lhthread[c][t]$ and 
individual threads can then be composed
into programs on $\Lbthread[c]$ by Thm.~\ref{thread_composition}.
However, it is still challenging to show that the compiled programs at the assembly level
are also compatible with this parallel composition
because
of a small snag which we glossed over until now: \emph{stack frames}.
In the CompCert memory model~\cite{leroy08},
whenever
a function is called, a fresh memory block has to be allocated in the
 memory for its stack frame. This means that, on top of the thread-local layer $\Lhthread[c][t]$, a function called within a thread will allocate its stack frame
into the thread-private memory state, and conversely, a thread is
never aware of any newer memory blocks allocated by other
threads. In comparison, on top of the CPU-local layer $\Lbthread[c]$, all stack frames have to be allocated
in the CPU-local memory (i.e.\, \emph{thread-shared} memory) regardless of which thread they belong to;
thus, in the thread composition proof, we need to account
for all such stack frames.

Our solution is based on a special \emph{memory
extension} \cite[\S 5.2]{leroy08} that only removes the access permissions of some memory 
blocks(See Fig.~\ref{fig:mem}). 
To enable the  thread composition, we extended the semantics of $\commc{yield}$ and $\commc{sleep}$ on the thread-local layer $\Lhthread[c][t]$. Besides generating a $c.\yield/c.sleep$ event, such a scheduling primitive also allocates  \emph{empty} memory blocks 
as ``placeholders" for other threads' new stack frames during this $\commc{yield}/\commc{sleep}$.
These empty blocks are the ones without any access permissions.
We write ``$\nextblock{m}$'' to denote the total number
of blocks in $m$, and write ``$\liftnextblock{m}{n}$'' as the memory   extended
from $m$ by allocating $n$ new
empty blocks. 

With the extended semantics for scheduling primitives, we can prove
that a ternary relation ``$\disjointunion{m_1}{m_2}{m}$'' holds between the
private memory states $m_1, m_2$ of two disjoint thread sets and the
thread-shared memory state $m$ after the parallel composition. This relation among memory states is called the ``algebraic memory model'', which is defined by the axioms shown in Fig.~\ref{fig:algmem}.
 
Rule \textsc{Nb} states that the block number of the composed memory $m$  is equal to  ``$\max(\nextblock{m_1}, \nextblock{m_2})$.''
Rule \textsc{Comm} says that the parallel memory composition is
commutative. Rule \textsc{Ld} and \textsc{St} state that the behaviors of memory load and store (over $m_1$ or $m_2$) are preserved by the composed memory $m$. It is because that every non-shared memory block of $m_1$ either does not exist in $m_2$ or corresponds to an empty block in $m_2$, and vice versa.

%These properties guarantee that all the threads' private memory states are compatible.
%scheduling primitives like $\commc{yield}/\commc{sleep}$ are well behaved. 

All the remaining rules  in Fig.~\ref{fig:algmem} share the condition
``$\nextblock{m_1} \leq \nextblock{m_2}$.'' This condition indicates that thread 2 is ``more-recently scheduled/running'' because only \emph{running}
thread  can allocate memory blocks. 
Thus, memory allocations on $m_2$ can be preserved by the composed memory $m$ (see Rule \textsc{Alloc}).
In addition, if thread 2 is still the next scheduled thread and there are $n$ new stack frames allocated by threads other than $\set{1,2}$, we can then simply allocate $n$
 empty blocks in $m_2$, which will be preserved by $m$ (see Rule \textsc{Lift-R}). If thread 1 is the next thread to run, after allocating $n$ new empty blocks to $m_1$, the composed memory $m$ only need to allocate the blocks that have not been captured by $m_2$ (see Rule \textsc{Lift-L}).

Based on the parallel composition for two memory states, we can use Rule \textsc{Lift-R}  and
\textsc{Lift-L} to generalize to $N$ threads by saying that
$m$ is a composition of the private memory states ``$m_1, \dots, m_N$''
of $N$ threads (on a single processor) if, and only if, there exists a
memory state $m'$ such that $m'$ is a composition of ``$m_1, \dots,
m_{N-1}$'' and $\disjointunion{m_N}{m'}{m}$ holds.
For example, 
let $m_1, m_2$ two partial memory states containing the thread-private
memories of two disjoint thread sets. Then, we say that global memory
state $m$ is \emph{a disjoint union} of $m_1$ and $m_2$ (written $\disjointunion{m_1}{m_2}{m}$)
if, and only if, all the following conditions hold:
$\mathsf{nb}(m) = \max(\mathsf{nb}(m_1), \mathsf{nb}(m_2))$; $\forall i$,
memory extension from $\mathsf{liftnb}(m_i, \mathsf{nb}(m) - \mathsf{nb}(m_i))$ to $m$;
and no valid common memory locations in both $m_1$ and $m_2$;
then we satisfy the algebraic memory model axioms of Fig.~\ref{fig:algmem}.

