%\sectskip
\section{Limitations and Future Work}
\label{sec:limit}
%\asectskip

%\zhong{
%Here we address all potential loose-ends.
%\begin{itemize}
%\item any lessons learned?
%\item concurrency and contextual refinement
%\item liveness properties 
%\item compcert memory references vs. capabilities (security properties)
%\item resource usages (stack usages)
%\item interrupts and interrupt handler
%\end{itemize}
%}

\paragraph{Trusted computing base}
Currently, there is still some gap between the bottommost layer of our
verified kernel, {\it PreInit}, and the real X86 hardware.
In the {\it PreInit} layer, some of the hardware virtualization
instructions such as {\it vmrun}, {\it vmload}, {\it vmsave}
are not modeled. It also lacks the model for interrupt related hardware
instruction like {\it cli}, and {\it sti}. The code that
is used to load the ELF binaries is also axiomatized in the layer.

The \mCTOS{} kernel also relies on a bootloader, and a pre-initialization
module, which initializes the drivers, e.g.,
serial, disk, console, {\it etc}, required by \mCTOS{}.
The verification of these modules are
left for future work. Device drivers are not verified
because our current machine semantics lacks device models for
expressing the corresponding semantics.

Finally, the CompCert assembler for converting assembly into machine
code is also not verified. We also assume the correctness of the Coq
proof checker and its code extraction mechanism.

%The following is no longer accurate: now these switches are fully
%verified.
%% \item some assembly code generated for the switches between ring0
%% and ring3, and between the host and the guest. Our machine
%% semantics % ($\LSem{L}$) models these switches as pseudo
%% primitives. They can be verified if we model more detailed hardware
%% behaviors and instructions in our machine model.
%% C functions, such as memcpy, are not supported by the current 
%% CompCert memory model and thus can not be verified in $\ClightX{L}$.
%% On the other hand, they can be implemented in assembly and verified 
%% at the assembly level, which we leave for future work.
% Do we really have any code in the kernel (I mean, apart from the
% bootloader and preinit) having the following features?
%% \item Some C features are not supported by the current CompCert, e.g.
%% functions with varying number of arguments, and the GCC-style inline
%% assembly. They could be verified in assembly, which we leave for future work.

\paragraph{Expressivity of context code} 
Our assembly-level machines do not cover the full x86 instruction sets 
and many other hardware features. This means that our correctness results 
only apply to programs in this subset. However, additional instructions 
and features can be easily added if they have simple or no interaction
with our kernel. 

\paragraph{Concurrency}
Our current certified kernels assume a runtime environment consisting
of a single processor, but extending it to support multicore
concurrency is already under way. Our choice of using contextual refinement 
to connect layers is motivated partly by its
deep connection with the work on concurrent
objects~\cite{herlihy90,herlihy08book}.

In \CTOS, all primitives introduced at each abstraction layer are
assigned ``atomic'' specifications. Such ``atomicity'' is easy to
establish in the sequential setting when interrupts are turned off.
In the concurrent setting (and even with preemption and all the
interleavings), we would still want the underlying kernel
implementation module to behave like its sequential counterpart 
in all contexts. This is the essence of {\em linearizability}~\cite{herlihy90}.

Recent work on concurrency verification~\cite{liang13,filipovic10} has
shown that contextual refinement is precisely equivalent to
linearizability. In fact, by
varying the observable context and the assumption about the scheduler,
Liang~{\em{}et al}~\cite{liang13} have shown that termination-sensitive
contextual refinement (which we use in \CTOS) is precisely equivalent
to linearizability plus a specific liveness property (i.e., 
wait-freedom, lock-freedom, obstruction-freedom, starvation-freedom
or deadlock-freedom).

These results suggest that by using contextual
refinement, \CTOS\ can isolate and encapsulate fine-grained concurrent
interleavings inside the implementation of each kernel object within a
single layer. Non-blocking fine-grained concurrent data structures can have
very sophisticated local invariants, but they are not exported to
other parts of the kernel. This makes the \CTOS\ architecture much
more appealing and extensible.

\paragraph{Interrupts} Like most existing verified kernel efforts,
we assume that interrupts are only enabled in user or guest mode. The
challenges in handling interrupts and preemption are similar to those
for concurrency. Feng {\em et al.}~\cite{feng08:vstte} verified a
practical thread implementation with hardware interrupts and
preemption~\cite{feng08:aim} by using a variant of concurrent
separation logic~\cite{ohearn:concur04}. Their proofs are interesting
in that they decompose the thread implementation into one sequential
layer (with interrupts disabled) and another concurrent one
(with interrupts enabled). We believe that similar approaches can
be readily supported in our \CTOS\ framework.

% This part is mostly covered in Section 5 now, we shouldn't need it anymore
\begin{comment}
\paragraph{Security and information flow}
We also plan to utilize the extensible, layered framework of
\CTOS{} to guarantee that information flow or security properties are never
broken by a valid layer implementation. For example, consider proving
a variant of the end-to-end confidentiality property known in the
literature as \emph{noninterference}. Informally, the property says
that the observable behavior of a program is independent of the
initial values of some particular high-security data (i.e., there is
no flow of information from the high-security data to the observable
events produced by the program). We define the specification of a
program as the (partial) mapping from initial state to final state,
and call a specification ``noninterfering'' if it satisfies the
property just described. Our goal is then to prove that, at any layer
$L_i$, if all the primitives implemented in layer $L_{i-1}$ have
noninterfering specifications, then a program written in layer
$L_i$ using those primitives will also be noninterfering. We
have found that such a goal is achievable via instrumentation of the
CompCert-style memory model with security labels, and
intelligently placed label checks within the operational
semantics. Note that these security labels are abstract state---they
do not actually exist in the concrete machine, and thus they do not
add any execution overhead.

We also intend to leverage our \CTOS\ architecture to generalize the
integrity and noninterference properties of seL4~\cite{murray13,sewell11}
beyond the purely access-control-based policy that parameterizes the 
properties. Rather than explicitly storing pieces of an access control 
policy in capabilities and passing them between kernel objects, we wish 
to reason about label-based policies via a purely static instrumented 
machine. Another way to view this goal is with respect to the HiStar 
operating system~\cite{zeldovich06}. In HiStar, all kernel objects have
an attached security label. Label checks are performed during kernel 
execution to prevent undesirable information flows, though no formal 
guarantees regarding information flow are stated or proved. Our goal 
can be viewed, then, as taking HiStar's security labels, migrating them 
from the actual machine into the realm of static verification, and 
proving extensible, end-to-end information-flow guarantees. Through this 
process, we also anticipate that security policies (given through 
specifications) will become clearer and more declarative.
\end{comment}

