%\sectskip
\section{Layer Design and Verification}
\label{sec:spec}
%\asectskip
We verify the C2 kernel based on the sequential machine model
described in Sec.XXX.
Instead of verifying a complex kernel in one shot,
we define a series of logical abstraction layers, which serve
as increasingly higher-level specifications for an increasing portion
of the kernel code. We design these abstract layers in a way such
that complex interdependent kernel components are untangled and
converted into a well-organized kernel-object stack with clean
specification.  In this section we present the layer design process
and common principles we have followed in our development.

\subsection{Defining abstraction layers}
\label{subsec:layer_def}
Our framework specifies an abstraction layer
using three components:
a collection of \emph{private objects},
a collection of \emph{atomic objects},
and the invariants which the atomic and private objects satisfy
at any point of the execution.
These three components define a logical view of
a subset of the kernel code
and extend our language with
an abstract specification of that code.
On top of this logical view, more code is introduced and
verified.

\paragraph{Private object} is the abstraction of the thread's
private data. 
Similar to the single-core setting (REFER XXX),
a private object consists of an \emph{abstract state} 
(severing as the abstraction of the underline private memory),
and a collection of primitives
(severing as the specifications of the methods
that manipulating that piece of the private memory).
Figure~\ref{fig:spec:object} shows how to build private objects.

\paragraph{Atomic objects}
As shown in Sec.XXX,
the sequential machine model
contains a \emph{small} set of atomic objects,
which generates a single event
and the object itself is constructable by replaying the logical log.

Figure~\ref{fig:spec:object} shows how to build atomic objects
based on the atomic objects, private objects,
and the shared memory at underlay.
Since the shared memory accesses are modeled using \emph{local copy},
the \code{push/pull} operations have to be synchronized 
using underlay's atomic objects.
The verification of functions accessing shared data inside the kernel
is a procedure to show that all shared memory accesses 
are well-synchronized and its invocation can be viewed as atomic.

For example, the physical page allocator scans the \emph{shared} allocation table
and returns the first free page.
Its accesses to the shared table are protected by \emph{atomic lock objects},
such that its \code{push/pull} operations are safe to execute.
By showing that the allocator implementation
satisfy the specification, which generates a single \code{palloc} event,
an atomic allocator object is introduced and can be used to reason about
other kernel modules at higher layers (\cf Sec.\ref{sec:base:memm}).

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{figs/build_object}
\vspace*{-8pt}	
\end{center}
\caption{Introduce layer object}
\label{fig:spec:object}
\vspace*{-10pt}
\end{figure}

\paragraph{Layer invariant}
Each abstraction layer specifies a predicate
on the private objects' abstract states
and the logical log,
which is the invariant $\inv_{\set{i}}$ hold for the execution on CPU $i$
(\cf Sec.XXX).
We have to show that this invariant $\inv_{\set{i}}$ is preserved
by all primitives of private objects and atomic objects.
The proofs for atomic  objects also rely on the
invariant of the context CPUs (\ie, $\inv_{\bar{\set{i}}}$).

In previous verification efforts, even for private objects,
proving invariants has typically been challenging~\cite{klein2009sel4},
especially that the invariants might be temporarily violated within the function body.
For example, adding a new node to a doubly-linked list
temporarily violates invariants that the list is well formed.

However, in our layered approach,
we do not have to set up the all the invariants at a single step.
Take the thread queue (implemented as doubly-linked list) in C2 kernel as an example.
When verifying the concrete implementation, we do not pose the well-formedness invariant
over the queue at that layer.
We only prove the invariant after the queue and its operations be introduced as a private object and the primitives.
In this way,
since the abstract primitives are atomic,
there is no longer a point in the execution
at which the invariants have to be temporarily violated.

\subsection{Contextual Refinement}
The contextual refinement relation between
the two layers (one with concrete implementation and the other
with the private and atomic object) ensures that any kernel/user context code 
(\ie, threads on other CPUs and other modules on the same CPU)
linking with the more abstract layer retains an
equivalent behavior when linking with the corresponding
concrete implementation running on the layer.

\paragraph{Contextual refinement for private objects}
As shown in Fig.~\ref{fig:spec:object},
to establish the contextual refinement relation
between concrete memory and the private object,
we use memory permissions~\cite{leroy08} at the higher layer
to prevent the context code
from accessing the private memory.
Note that these permissions do \emph{not}
correspond to a physical protection mechanism,
but instead are entirely logical:
they ensure that the higher-level abstract machine
gets stuck whenever it executes
code that directly accesses this private memory without going through the provided
primitives. By proving that our kernel is safe (it will not go wrong),
we guarantee that this situation will not happen.

\paragraph{Contextual refinement for atomic objects}
To establish the contextual refinement relation
for atomic objects, the main proof body is about the invariants proof.
We have to show that for any environment context $\oracle_{\bar{\set{i}}}$
that satisfy the context invariant $\inv_{\bar{\set{i}}}$.
Thus, the environment context linked with CPU $i$'s atomic object
is equivalent to the one linked with the concrete implementation,
where interleaving might happen within the function body.

\paragraph{Layer refinement}

\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{figs/refine_layer}
\vspace*{-8pt}	
\end{center}
\caption{Contextual refinement between layers}
\label{fig:spec:refine_layer}
\vspace*{-10pt}
\end{figure}

The first layer \emph{PreInit} (\ie, $L_0$)
is based on the \emph{sequential machine model} $\mach{s}$.
As shown in Fig.\ref{fig:spec:refine_layer},
kernel modules
are verified as a stack of layers
building 
on top of the $\mach{s}$.
Although the layers are built
on behave of a particular $\text{CPU}_i$,
layers at other CPUs are symmetric.
After the scheduler module is verified,
we move one step forward
and decompose the execution on $\text{CPU}_i$
into a collection of \emph{per-thread execution}.
By introducing the \emph{software scheduler}
$\oracle_{ss}$ (\ie, reflecting the scheduling algorithm),
multi-threads execution on the same CPU 
can be composed similarly to the multi-core composition
(\cf Sec.~\ref{sec:base:procm}).
Thus, user programs can be verified
locally using the atomic specifications of kernel's
system calls,
and be composed using our framework.




